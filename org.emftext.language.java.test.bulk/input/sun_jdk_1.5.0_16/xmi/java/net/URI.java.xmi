<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="URI.java">
  <comments>/*&#xA; * @(#)URI.java&#x9;1.40 05/11/28&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>net</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/InvalidObjectException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../nio/ByteBuffer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../nio/CharBuffer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>charset</namespaces>
    <classifier xsi:type="classifiers:Class" href="../nio/charset/CharsetDecoder.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>charset</namespaces>
    <classifier xsi:type="classifiers:Class" href="../nio/charset/CharsetEncoder.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>charset</namespaces>
    <classifier xsi:type="classifiers:Class" href="../nio/charset/CoderResult.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>charset</namespaces>
    <classifier xsi:type="classifiers:Class" href="../nio/charset/CodingErrorAction.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>charset</namespaces>
    <classifier xsi:type="classifiers:Class" href="../nio/charset/CharacterCodingException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>cs</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/nio/cs/ThreadLocalCoders.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <classifier xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <comments>// for javadoc</comments>
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <classifier xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="URI">
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="6052424284110960213"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// Note: Comments containing the word &quot;ASSERT&quot; indicate places where a</comments>
        <comments>// throw of an InternalError should be replaced by an appropriate assertion</comments>
        <comments>// statement once asserts are enabled in the build.</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="scheme">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// -- Properties and components of this instance --</comments>
        <comments>// Components of all URIs: [&lt;scheme>:]&lt;scheme-specific-part>[#&lt;fragment>]</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="fragment">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// null ==> relative URI</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="authority">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Hierarchical URI components: [//&lt;authority>]&lt;path>[?&lt;query>]</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="userInfo">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Registry or server</comments>
        <comments>// Server-based authority: [&lt;userInfo>@]&lt;host>[:&lt;port>]</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="host">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="port">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// null ==> registry-based</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="path">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// -1 ==> undefined</comments>
        <comments>// Remaining components of hierarchical URIs</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="query">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// null ==> opaque</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="schemeSpecificPart">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// The remaining fields may be computed on demand</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="hash">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="decodedUserInfo">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Zero ==> undefined</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="decodedAuthority">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="decodedPath">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="decodedQuery">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="decodedFragment">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="decodedSchemeSpecificPart">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:Field" name="string">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The string form of this URI.&#xA;     *&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
    </members>
    <members xsi:type="members:Constructor" name="URI">
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// The only serializable field</comments>
        <comments>// -- Constructors and factories --</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="URI">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.136"/>
          </typeReference>
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.17">
            <arguments xsi:type="literals:BooleanLiteral"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Used internally</comments>
        <comments>/**&#xA;     * Constructs a URI by parsing the given string.&#xA;     *&#xA;     * &lt;p> This constructor parses the given string exactly as specified by the&#xA;     * grammar in &lt;a&#xA;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;>RFC&amp;nbsp;2396&lt;/a>,&#xA;     * Appendix&amp;nbsp;A, &lt;b>&lt;i>except for the following deviations:&lt;/i>&lt;/b> &lt;/p>&#xA;     *&#xA;     * &lt;ul type=disc>&#xA;     *&#xA;     *   &lt;li>&lt;p> An empty authority component is permitted as long as it is&#xA;     *   followed by a non-empty path, a query component, or a fragment&#xA;     *   component.  This allows the parsing of URIs such as&#xA;     *   &lt;tt>&quot;file:///foo/bar&quot;&lt;/tt>, which seems to be the intent of&#xA;     *   RFC&amp;nbsp;2396 although the grammar does not permit it.  If the&#xA;     *   authority component is empty then the user-information, host, and port&#xA;     *   components are undefined. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> Empty relative paths are permitted; this seems to be the&#xA;     *   intent of RFC&amp;nbsp;2396 although the grammar does not permit it.  The&#xA;     *   primary consequence of this deviation is that a standalone fragment&#xA;     *   such as &lt;tt>&quot;#foo&quot;&lt;/tt> parses as a relative URI with an empty path&#xA;     *   and the given fragment, and can be usefully &lt;a&#xA;     *   href=&quot;#resolve-frag&quot;>resolved&lt;/a> against a base URI.&#xA;     *&#xA;     *   &lt;li>&lt;p> IPv4 addresses in host components are parsed rigorously, as&#xA;     *   specified by &lt;a&#xA;     *   href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;>RFC&amp;nbsp;2732&lt;/a>: Each&#xA;     *   element of a dotted-quad address must contain no more than three&#xA;     *   decimal digits.  Each element is further constrained to have a value&#xA;     *   no greater than 255. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li> &lt;p> Hostnames in host components that comprise only a single&#xA;     *   domain label are permitted to start with an &lt;i>alphanum&lt;/i> &#xA;     *   character. This seems to be the intent of &lt;a&#xA;     *   href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;>RFC&amp;nbsp;2396&lt;/a>&#xA;     *   section&amp;nbsp;3.2.2 although the grammar does not permit it. The&#xA;     *   consequence of this deviation is that the authority component of a&#xA;     *   hierarchical URI such as &lt;tt>s://123&lt;/tt>, will parse as a server-based &#xA;     *   authority. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> IPv6 addresses are permitted for the host component.  An IPv6&#xA;     *   address must be enclosed in square brackets (&lt;tt>'['&lt;/tt> and&#xA;     *   &lt;tt>']'&lt;/tt>) as specified by &lt;a&#xA;     *   href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;>RFC&amp;nbsp;2732&lt;/a>.  The&#xA;     *   IPv6 address itself must parse according to &lt;a&#xA;     *   href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;>RFC&amp;nbsp;2373&lt;/a>.  IPv6&#xA;     *   addresses are further constrained to describe no more than sixteen&#xA;     *   bytes of address information, a constraint implicit in RFC&amp;nbsp;2373&#xA;     *   but not expressible in the grammar. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> Characters in the &lt;i>other&lt;/i> category are permitted wherever&#xA;     *   RFC&amp;nbsp;2396 permits &lt;i>escaped&lt;/i> octets, that is, in the&#xA;     *   user-information, path, query, and fragment components, as well as in&#xA;     *   the authority component if the authority is registry-based.  This&#xA;     *   allows URIs to contain Unicode characters beyond those in the US-ASCII&#xA;     *   character set. &lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param  str   The string to be parsed into a URI&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If &lt;tt>str&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @throws  URISyntaxException&#xA;     *          If the given string violates RFC&amp;nbsp;2396, as augmented&#xA;     *          by the above deviations&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="URI">
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.66">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.5"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.6"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.62">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.0/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.4"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.136"/>
          </typeReference>
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.17">
            <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.0/@variable"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scheme">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="userInfo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="host">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="port">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="query">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fragment">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a hierarchical URI from the given components.&#xA;     *&#xA;     * &lt;p> If a scheme is given then the path, if also given, must either be&#xA;     * empty or begin with a slash character (&lt;tt>'/'&lt;/tt>).  Otherwise a&#xA;     * component of the new URI may be left undefined by passing &lt;tt>null&lt;/tt>&#xA;     * for the corresponding parameter or, in the case of the &lt;tt>port&lt;/tt>&#xA;     * parameter, by passing &lt;tt>-1&lt;/tt>.&#xA;     *&#xA;     * &lt;p> This constructor first builds a URI string from the given components&#xA;     * according to the rules specified in &lt;a&#xA;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;>RFC&amp;nbsp;2396&lt;/a>,&#xA;     * section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p>&#xA;     *&#xA;     * &lt;ol>&#xA;     *&#xA;     *   &lt;li>&lt;p> Initially, the result string is empty. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If a scheme is given then it is appended to the result,&#xA;     *   followed by a colon character (&lt;tt>':'&lt;/tt>).  &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If user information, a host, or a port are given then the&#xA;     *   string &lt;tt>&quot;//&quot;&lt;/tt> is appended.  &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If user information is given then it is appended, followed by&#xA;     *   a commercial-at character (&lt;tt>'@'&lt;/tt>).  Any character not in the&#xA;     *   &lt;i>unreserved&lt;/i>, &lt;i>punct&lt;/i>, &lt;i>escaped&lt;/i>, or &lt;i>other&lt;/i>&#xA;     *   categories is &lt;a href=&quot;#quote&quot;>quoted&lt;/a>.  &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If a host is given then it is appended.  If the host is a&#xA;     *   literal IPv6 address but is not enclosed in square brackets&#xA;     *   (&lt;tt>'['&lt;/tt> and &lt;tt>']'&lt;/tt>) then the square brackets are added.&#xA;     *   &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If a port number is given then a colon character&#xA;     *   (&lt;tt>':'&lt;/tt>) is appended, followed by the port number in decimal.&#xA;     *   &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If a path is given then it is appended.  Any character not in&#xA;     *   the &lt;i>unreserved&lt;/i>, &lt;i>punct&lt;/i>, &lt;i>escaped&lt;/i>, or &lt;i>other&lt;/i>&#xA;     *   categories, and not equal to the slash character (&lt;tt>'/'&lt;/tt>) or the&#xA;     *   commercial-at character (&lt;tt>'@'&lt;/tt>), is quoted.  &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If a query is given then a question-mark character&#xA;     *   (&lt;tt>'?'&lt;/tt>) is appended, followed by the query.  Any character that&#xA;     *   is not a &lt;a href=&quot;#legal-chars&quot;>legal URI character&lt;/a> is quoted.&#xA;     *   &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> Finally, if a fragment is given then a hash character&#xA;     *   (&lt;tt>'#'&lt;/tt>) is appended, followed by the fragment.  Any character&#xA;     *   that is not a legal URI character is quoted.  &lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;/ol>&#xA;     *&#xA;     * &lt;p> The resulting URI string is then parsed as if by invoking the {@link&#xA;     * #URI(String)} constructor and then invoking the {@link&#xA;     * #parseServerAuthority()} method upon the result; this may cause a {@link&#xA;     * URISyntaxException} to be thrown.  &lt;/p>&#xA;     *&#xA;     * @param   scheme    Scheme name&#xA;     * @param   userInfo  User name and authorization information&#xA;     * @param   host      Host name&#xA;     * @param   port      Port number&#xA;     * @param   path      Path&#xA;     * @param   query     Query&#xA;     * @param   fragment  Fragment&#xA;     *&#xA;     * @throws URISyntaxException&#xA;     *         If both a scheme and a path are given but the path is relative,&#xA;     *         if the URI string constructed from the given components violates&#xA;     *         RFC&amp;nbsp;2396, or if the authority component of the string is&#xA;     *         present but cannot be parsed as a server-based authority&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="URI">
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.66">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.4"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.62">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.0/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.136"/>
          </typeReference>
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.17">
            <arguments xsi:type="literals:BooleanLiteral"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.0/@variable"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scheme">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="authority">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="query">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fragment">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a hierarchical URI from the given components.&#xA;     *&#xA;     * &lt;p> If a scheme is given then the path, if also given, must either be&#xA;     * empty or begin with a slash character (&lt;tt>'/'&lt;/tt>).  Otherwise a&#xA;     * component of the new URI may be left undefined by passing &lt;tt>null&lt;/tt>&#xA;     * for the corresponding parameter.&#xA;     *&#xA;     * &lt;p> This constructor first builds a URI string from the given components&#xA;     * according to the rules specified in &lt;a&#xA;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;>RFC&amp;nbsp;2396&lt;/a>,&#xA;     * section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p>&#xA;     *&#xA;     * &lt;ol>&#xA;     *&#xA;     *   &lt;li>&lt;p> Initially, the result string is empty.  &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If a scheme is given then it is appended to the result,&#xA;     *   followed by a colon character (&lt;tt>':'&lt;/tt>).  &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If an authority is given then the string &lt;tt>&quot;//&quot;&lt;/tt> is&#xA;     *   appended, followed by the authority.  If the authority contains a&#xA;     *   literal IPv6 address then the address must be enclosed in square&#xA;     *   brackets (&lt;tt>'['&lt;/tt> and &lt;tt>']'&lt;/tt>).  Any character not in the&#xA;     *   &lt;i>unreserved&lt;/i>, &lt;i>punct&lt;/i>, &lt;i>escaped&lt;/i>, or &lt;i>other&lt;/i>&#xA;     *   categories, and not equal to the commercial-at character&#xA;     *   (&lt;tt>'@'&lt;/tt>), is &lt;a href=&quot;#quote&quot;>quoted&lt;/a>.  &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If a path is given then it is appended.  Any character not in&#xA;     *   the &lt;i>unreserved&lt;/i>, &lt;i>punct&lt;/i>, &lt;i>escaped&lt;/i>, or &lt;i>other&lt;/i>&#xA;     *   categories, and not equal to the slash character (&lt;tt>'/'&lt;/tt>) or the&#xA;     *   commercial-at character (&lt;tt>'@'&lt;/tt>), is quoted.  &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If a query is given then a question-mark character&#xA;     *   (&lt;tt>'?'&lt;/tt>) is appended, followed by the query.  Any character that&#xA;     *   is not a &lt;a href=&quot;#legal-chars&quot;>legal URI character&lt;/a> is quoted.&#xA;     *   &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> Finally, if a fragment is given then a hash character&#xA;     *   (&lt;tt>'#'&lt;/tt>) is appended, followed by the fragment.  Any character&#xA;     *   that is not a legal URI character is quoted.  &lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;/ol>&#xA;     *&#xA;     * &lt;p> The resulting URI string is then parsed as if by invoking the {@link&#xA;     * #URI(String)} constructor and then invoking the {@link&#xA;     * #parseServerAuthority()} method upon the result; this may cause a {@link&#xA;     * URISyntaxException} to be thrown.  &lt;/p>&#xA;     *&#xA;     * @param   scheme     Scheme name&#xA;     * @param   authority  Authority&#xA;     * @param   path       Path&#xA;     * @param   query      Query&#xA;     * @param   fragment   Fragment&#xA;     *&#xA;     * @throws URISyntaxException&#xA;     *         If both a scheme and a path are given but the path is relative,&#xA;     *         if the URI string constructed from the given components violates&#xA;     *         RFC&amp;nbsp;2396, or if the authority component of the string is&#xA;     *         present but cannot be parsed as a server-based authority&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="URI">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
          <arguments xsi:type="literals:NullLiteral"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.1"/>
          <arguments xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.2"/>
          <arguments xsi:type="literals:NullLiteral"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.3"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scheme">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="host">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fragment">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a hierarchical URI from the given components.&#xA;     *&#xA;     * &lt;p> A component may be left undefined by passing &lt;tt>null&lt;/tt>.&#xA;     *&#xA;     * &lt;p> This convenience constructor works as if by invoking the&#xA;     * seven-argument constructor as follows:&#xA;     *&#xA;     * &lt;blockquote>&lt;tt>&#xA;     * new&amp;nbsp;{@link #URI(String, String, String, int, String, String, String)&#xA;     * URI}(scheme,&amp;nbsp;null,&amp;nbsp;host,&amp;nbsp;-1,&amp;nbsp;path,&amp;nbsp;null,&amp;nbsp;fragment);&#xA;     * &lt;/tt>&lt;/blockquote>&#xA;     *&#xA;     * @param   scheme    Scheme name&#xA;     * @param   host      Host name&#xA;     * @param   path      Path&#xA;     * @param   fragment  Fragment&#xA;     *&#xA;     * @throws  URISyntaxException&#xA;     *          If the URI string constructed from the given components&#xA;     *          violates RFC&amp;nbsp;2396&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="URI">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.136"/>
          </typeReference>
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.17">
            <arguments xsi:type="literals:BooleanLiteral"/>
          </next>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.66">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arguments>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
          </arguments>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scheme">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ssp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fragment">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a URI from the given components.&#xA;     *&#xA;     * &lt;p> A component may be left undefined by passing &lt;tt>null&lt;/tt>.&#xA;     *&#xA;     * &lt;p> This constructor first builds a URI in string form using the given&#xA;     * components as follows:  &lt;/p>&#xA;     *&#xA;     * &lt;ol>&#xA;     *&#xA;     *   &lt;li>&lt;p> Initially, the result string is empty.  &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If a scheme is given then it is appended to the result,&#xA;     *   followed by a colon character (&lt;tt>':'&lt;/tt>).  &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If a scheme-specific part is given then it is appended.  Any&#xA;     *   character that is not a &lt;a href=&quot;#legal-chars&quot;>legal URI character&lt;/a>&#xA;     *   is &lt;a href=&quot;#quote&quot;>quoted&lt;/a>.  &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> Finally, if a fragment is given then a hash character&#xA;     *   (&lt;tt>'#'&lt;/tt>) is appended to the string, followed by the fragment.&#xA;     *   Any character that is not a legal URI character is quoted.  &lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;/ol>&#xA;     *&#xA;     * &lt;p> The resulting URI string is then parsed in order to create the new&#xA;     * URI instance as if by invoking the {@link #URI(String)} constructor;&#xA;     * this may cause a {@link URISyntaxException} to be thrown.  &lt;/p>&#xA;     *&#xA;     * @param   scheme    Scheme name&#xA;     * @param   ssp       Scheme-specific part&#xA;     * @param   fragment  Fragment&#xA;     *&#xA;     * @throws  URISyntaxException&#xA;     *          If the URI string constructed from the given components&#xA;     *          violates RFC&amp;nbsp;2396&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="create">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a URI by parsing the given string.&#xA;     *&#xA;     * &lt;p> This convenience factory method works as if by invoking the {@link&#xA;     * #URI(String)} constructor; any {@link URISyntaxException} thrown by the&#xA;     * constructor is caught and wrapped in a new {@link&#xA;     * IllegalArgumentException} object, which is then thrown.&#xA;     *&#xA;     * &lt;p> This method is provided for use in situations where it is known that&#xA;     * the given string is a legal URI, for example for URI constants declared&#xA;     * within in a program, and so it would be considered a programming error&#xA;     * for the string not to parse as such.  The constructors, which throw&#xA;     * {@link URISyntaxException} directly, should be used situations where a&#xA;     * URI is being constructed from user input or from some other source that&#xA;     * may be prone to errors.  &lt;/p>&#xA;     *&#xA;     * @param  str   The string to be parsed into a URI&#xA;     * @return The new URI&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If &lt;tt>str&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the given string violates RFC&amp;nbsp;2396&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="y">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@catcheBlocks.0/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Throwable.class.xmi#//@classifiers.0/@members.12"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@catcheBlocks.0/@parameter"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@catcheBlocks.0/@statements.0/@variable"/>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="parseServerAuthority">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Operations --</comments>
        <comments>/**&#xA;     * Attempts to parse this URI's authority component, if defined, into&#xA;     * user-information, host, and port components.&#xA;     *&#xA;     * &lt;p> If this URI's authority component has already been recognized as&#xA;     * being server-based then it will already have been parsed into&#xA;     * user-information, host, and port components.  In this case, or if this&#xA;     * URI has no authority component, this method simply returns this URI.&#xA;     *&#xA;     * &lt;p> Otherwise this method attempts once more to parse the authority&#xA;     * component into user-information, host, and port components, and throws&#xA;     * an exception describing why the authority component could not be parsed&#xA;     * in that way.&#xA;     *&#xA;     * &lt;p> This method is provided because the generic URI syntax specified in&#xA;     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;>RFC&amp;nbsp;2396&lt;/a>&#xA;     * cannot always distinguish a malformed server-based authority from a&#xA;     * legitimate registry-based authority.  It must therefore treat some&#xA;     * instances of the former as instances of the latter.  The authority&#xA;     * component in the URI string &lt;tt>&quot;//foo:bar&quot;&lt;/tt>, for example, is not a&#xA;     * legal server-based authority but it is legal as a registry-based&#xA;     * authority.&#xA;     *&#xA;     * &lt;p> In many common situations, for example when working URIs that are&#xA;     * known to be either URNs or URLs, the hierarchical URIs being used will&#xA;     * always be server-based.  They therefore must either be parsed as such or&#xA;     * treated as an error.  In these cases a statement such as&#xA;     *&#xA;     * &lt;blockquote>&#xA;     * &lt;tt>URI &lt;/tt>&lt;i>u&lt;/i>&lt;tt> = new URI(str).parseServerAuthority();&lt;/tt>&#xA;     * &lt;/blockquote>&#xA;     *&#xA;     * &lt;p> can be used to ensure that &lt;i>u&lt;/i> always refers to a URI that, if&#xA;     * it has an authority component, has a server-based authority with proper&#xA;     * user-information, host, and port components.  Invoking this method also&#xA;     * ensures that if the authority could not be parsed in that way then an&#xA;     * appropriate diagnostic message can be issued based upon the exception&#xA;     * that is thrown. &lt;/p>&#xA;     *&#xA;     * @return  A URI whose authority field has been parsed&#xA;     *          as a server-based authority&#xA;     *&#xA;     * @throws  URISyntaxException&#xA;     *          If the authority component of this URI is defined&#xA;     *          but cannot be parsed as a server-based authority&#xA;     *          according to RFC&amp;nbsp;2396&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// We could be clever and cache the error message and index from the</comments>
        <comments>// exception thrown during the original parse, but that would require</comments>
        <comments>// either more fields or a more-obscure representation.</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.68"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.136"/>
          </typeReference>
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.17">
            <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          </next>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="normalize">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Normalizes this URI's path.&#xA;     *&#xA;     * &lt;p> If this URI is opaque, or if its path is already in normal form,&#xA;     * then this URI is returned.  Otherwise a new URI is constructed that is&#xA;     * identical to this URI except that its path is computed by normalizing&#xA;     * this URI's path in a manner consistent with &lt;a&#xA;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;>RFC&amp;nbsp;2396&lt;/a>,&#xA;     * section&amp;nbsp;5.2, step&amp;nbsp;6, sub-steps&amp;nbsp;c through&amp;nbsp;f; that is:&#xA;     * &lt;/p>&#xA;     *&#xA;     * &lt;ol>&#xA;     *&#xA;     *   &lt;li>&lt;p> All &lt;tt>&quot;.&quot;&lt;/tt> segments are removed. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If a &lt;tt>&quot;..&quot;&lt;/tt> segment is preceded by a non-&lt;tt>&quot;..&quot;&lt;/tt>&#xA;     *   segment then both of these segments are removed.  This step is&#xA;     *   repeated until it is no longer applicable. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If the path is relative, and if its first segment contains a&#xA;     *   colon character (&lt;tt>':'&lt;/tt>), then a &lt;tt>&quot;.&quot;&lt;/tt> segment is&#xA;     *   prepended.  This prevents a relative URI with a path such as&#xA;     *   &lt;tt>&quot;a:b/c/d&quot;&lt;/tt> from later being re-parsed as an opaque URI with a&#xA;     *   scheme of &lt;tt>&quot;a&quot;&lt;/tt> and a scheme-specific part of &lt;tt>&quot;b/c/d&quot;&lt;/tt>.&#xA;     *   &lt;b>&lt;i>(Deviation from RFC&amp;nbsp;2396)&lt;/i>&lt;/b> &lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;/ol>&#xA;     *&#xA;     * &lt;p> A normalized path will begin with one or more &lt;tt>&quot;..&quot;&lt;/tt> segments&#xA;     * if there were insufficient non-&lt;tt>&quot;..&quot;&lt;/tt> segments preceding them to&#xA;     * allow their removal.  A normalized path will begin with a &lt;tt>&quot;.&quot;&lt;/tt>&#xA;     * segment if one was inserted by step 3 above.  Otherwise, a normalized&#xA;     * path will not contain any &lt;tt>&quot;.&quot;&lt;/tt> or &lt;tt>&quot;..&quot;&lt;/tt> segments. &lt;/p>&#xA;     *&#xA;     * @return  A URI equivalent to this URI,&#xA;     *          but whose path is in normal form&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.71">
          <arguments xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="resolve">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="uri">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Resolves the given URI against this URI.&#xA;     *&#xA;     * &lt;p> If the given URI is already absolute, or if this URI is opaque, then&#xA;     * the given URI is returned.&#xA;     *&#xA;     * &lt;p>&lt;a name=&quot;resolve-frag&quot;>&lt;/a> If the given URI's fragment component is&#xA;     * defined, its path component is empty, and its scheme, authority, and&#xA;     * query components are undefined, then a URI with the given fragment but&#xA;     * with all other components equal to those of this URI is returned.  This&#xA;     * allows a URI representing a standalone fragment reference, such as&#xA;     * &lt;tt>&quot;#foo&quot;&lt;/tt>, to be usefully resolved against a base URI.&#xA;     *&#xA;     * &lt;p> Otherwise this method constructs a new hierarchical URI in a manner&#xA;     * consistent with &lt;a&#xA;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;>RFC&amp;nbsp;2396&lt;/a>,&#xA;     * section&amp;nbsp;5.2; that is: &lt;/p>&#xA;     *&#xA;     * &lt;ol>&#xA;     *&#xA;     *   &lt;li>&lt;p> A new URI is constructed with this URI's scheme and the given&#xA;     *   URI's query and fragment components. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> If the given URI has an authority component then the new URI's&#xA;     *   authority and path are taken from the given URI. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> Otherwise the new URI's authority component is copied from&#xA;     *   this URI, and its path is computed as follows: &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;ol type=a>&#xA;     *&#xA;     *     &lt;li>&lt;p> If the given URI's path is absolute then the new URI's path&#xA;     *     is taken from the given URI. &lt;/p>&lt;/li>&#xA;     *&#xA;     *     &lt;li>&lt;p> Otherwise the given URI's path is relative, and so the new&#xA;     *     URI's path is computed by resolving the path of the given URI&#xA;     *     against the path of this URI.  This is done by concatenating all but&#xA;     *     the last segment of this URI's path, if any, with the given URI's&#xA;     *     path and then normalizing the result as if by invoking the {@link&#xA;     *     #normalize() normalize} method. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;/ol>&#xA;     *&#xA;     * &lt;/ol>&#xA;     *&#xA;     * &lt;p> The result of this method is absolute if, and only if, either this&#xA;     * URI is absolute or the given URI is absolute.  &lt;/p>&#xA;     *&#xA;     * @param  uri  The URI to be resolved against this URI&#xA;     * @return The resulting URI&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If &lt;tt>uri&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.70">
          <arguments xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="resolve">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a new URI by parsing the given string and then resolving it&#xA;     * against this URI.&#xA;     *&#xA;     * &lt;p> This convenience method works as if invoking it were equivalent to&#xA;     * evaluating the expression &lt;tt>{@link #resolve(java.net.URI)&#xA;     * resolve}(URI.{@link #create(String) create}(str))&lt;/tt>. &lt;/p>&#xA;     *&#xA;     * @param  str   The string to be parsed into a URI&#xA;     * @return The resulting URI&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If &lt;tt>str&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the given string violates RFC&amp;nbsp;2396&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.27">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="relativize">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="uri">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Relativizes the given URI against this URI.&#xA;     *&#xA;     * &lt;p> The relativization of the given URI against this URI is computed as&#xA;     * follows: &lt;/p>&#xA;     *&#xA;     * &lt;ol>&#xA;     *&#xA;     *   &lt;li>&lt;p> If either this URI or the given URI are opaque, or if the&#xA;     *   scheme and authority components of the two URIs are not identical, or&#xA;     *   if the path of this URI is not a prefix of the path of the given URI,&#xA;     *   then the given URI is returned. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> Otherwise a new relative hierarchical URI is constructed with&#xA;     *   query and fragment components taken from the given URI and with a path&#xA;     *   component computed by removing this URI's path from the beginning of&#xA;     *   the given URI's path. &lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;/ol>&#xA;     *&#xA;     * @param  uri  The URI to be relativized against this URI&#xA;     * @return The resulting URI&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If &lt;tt>uri&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.72">
          <arguments xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toURL">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="URL.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="MalformedURLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a URL from this URI.&#xA;     *&#xA;     * &lt;p> This convenience method works as if invoking it were equivalent to&#xA;     * evaluating the expression &lt;tt>new&amp;nbsp;URL(this.toString())&lt;/tt> after&#xA;     * first checking that this URI is absolute. &lt;/p>&#xA;     *&#xA;     * @return  A URL constructed from this URI&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If this URL is not absolute&#xA;     *&#xA;     * @throws  MalformedURLException&#xA;     *          If a protocol handler for the URL could not be found,&#xA;     *          or if some other error occurred while constructing the URL&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="URI is not absolute"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.32"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="URL.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.51"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getScheme">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Component access methods --</comments>
        <comments>/**&#xA;     * Returns the scheme component of this URI.&#xA;     *&#xA;     * &lt;p> The scheme component of a URI, if defined, only contains characters&#xA;     * in the &lt;i>alphanum&lt;/i> category and in the string &lt;tt>&quot;-.+&quot;&lt;/tt>.  A&#xA;     * scheme always starts with an &lt;i>alpha&lt;/i> character. &lt;p>&#xA;     *&#xA;     * The scheme component of a URI cannot contain escaped octets, hence this&#xA;     * method does not perform any decoding.&#xA;     *&#xA;     * @return  The scheme component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the scheme is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isAbsolute">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tells whether or not this URI is absolute.&#xA;     *&#xA;     * &lt;p> A URI is absolute if, and only if, it has a scheme component. &lt;/p>&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this URI is absolute&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isOpaque">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tells whether or not this URI is opaque.&#xA;     *&#xA;     * &lt;p> A URI is opaque if, and only if, it is absolute and its&#xA;     * scheme-specific part does not begin with a slash character ('/').&#xA;     * An opaque URI has a scheme, a scheme-specific part, and possibly&#xA;     * a fragment; all other components are undefined. &lt;/p>&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this URI is opaque&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          <children xsi:type="literals:NullLiteral"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getRawSchemeSpecificPart">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the raw scheme-specific part of this URI.  The scheme-specific&#xA;     * part is never undefined, though it may be empty.&#xA;     *&#xA;     * &lt;p> The scheme-specific part of a URI only contains legal URI&#xA;     * characters. &lt;/p>&#xA;     *&#xA;     * @return  The raw scheme-specific part of this URI&#xA;     *          (never &lt;tt>null&lt;/tt>)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.67"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSchemeSpecificPart">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the decoded scheme-specific part of this URI.&#xA;     *&#xA;     * &lt;p> The string returned by this method is equal to that returned by the&#xA;     * {@link #getRawSchemeSpecificPart() getRawSchemeSpecificPart} method&#xA;     * except that all sequences of escaped octets are &lt;a&#xA;     * href=&quot;#decode&quot;>decoded&lt;/a>.  &lt;/p>&#xA;     *&#xA;     * @return  The decoded scheme-specific part of this URI&#xA;     *          (never &lt;tt>null&lt;/tt>)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.135">
              <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.34"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getRawAuthority">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the raw authority component of this URI.&#xA;     *&#xA;     * &lt;p> The authority component of a URI, if defined, only contains the&#xA;     * commercial-at character (&lt;tt>'@'&lt;/tt>) and characters in the&#xA;     * &lt;i>unreserved&lt;/i>, &lt;i>punct&lt;/i>, &lt;i>escaped&lt;/i>, and &lt;i>other&lt;/i>&#xA;     * categories.  If the authority is server-based then it is further&#xA;     * constrained to have valid user-information, host, and port&#xA;     * components. &lt;/p>&#xA;     *&#xA;     * @return  The raw authority component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the authority is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAuthority">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the decoded authority component of this URI.&#xA;     *&#xA;     * &lt;p> The string returned by this method is equal to that returned by the&#xA;     * {@link #getRawAuthority() getRawAuthority} method except that all&#xA;     * sequences of escaped octets are &lt;a href=&quot;#decode&quot;>decoded&lt;/a>.  &lt;/p>&#xA;     *&#xA;     * @return  The decoded authority component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the authority is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.135">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getRawUserInfo">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the raw user-information component of this URI.&#xA;     *&#xA;     * &lt;p> The user-information component of a URI, if defined, only contains&#xA;     * characters in the &lt;i>unreserved&lt;/i>, &lt;i>punct&lt;/i>, &lt;i>escaped&lt;/i>, and&#xA;     * &lt;i>other&lt;/i> categories. &lt;/p>&#xA;     *&#xA;     * @return  The raw user-information component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the user information is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getUserInfo">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the decoded user-information component of this URI.&#xA;     *&#xA;     * &lt;p> The string returned by this method is equal to that returned by the&#xA;     * {@link #getRawUserInfo() getRawUserInfo} method except that all&#xA;     * sequences of escaped octets are &lt;a href=&quot;#decode&quot;>decoded&lt;/a>.  &lt;/p>&#xA;     *&#xA;     * @return  The decoded user-information component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the user information is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.135">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getHost">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the host component of this URI.&#xA;     *&#xA;     * &lt;p> The host component of a URI, if defined, will have one of the&#xA;     * following forms: &lt;/p>&#xA;     *&#xA;     * &lt;ul type=disc>&#xA;     *&#xA;     *   &lt;li>&lt;p> A domain name consisting of one or more &lt;i>labels&lt;/i>&#xA;     *   separated by period characters (&lt;tt>'.'&lt;/tt>), optionally followed by&#xA;     *   a period character.  Each label consists of &lt;i>alphanum&lt;/i> characters&#xA;     *   as well as hyphen characters (&lt;tt>'-'&lt;/tt>), though hyphens never&#xA;     *   occur as the first or last characters in a label. The rightmost&#xA;     *   label of a domain name consisting of two or more labels, begins&#xA;     *   with an &lt;i>alpha&lt;/i> character. &lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> A dotted-quad IPv4 address of the form&#xA;     *   &lt;i>digit&lt;/i>&lt;tt>+.&lt;/tt>&lt;i>digit&lt;/i>&lt;tt>+.&lt;/tt>&lt;i>digit&lt;/i>&lt;tt>+.&lt;/tt>&lt;i>digit&lt;/i>&lt;tt>+&lt;/tt>,&#xA;     *   where no &lt;i>digit&lt;/i> sequence is longer than three characters and no&#xA;     *   sequence has a value larger than 255. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> An IPv6 address enclosed in square brackets (&lt;tt>'['&lt;/tt> and&#xA;     *   &lt;tt>']'&lt;/tt>) and consisting of hexadecimal digits, colon characters&#xA;     *   (&lt;tt>':'&lt;/tt>), and possibly an embedded IPv4 address.  The full&#xA;     *   syntax of IPv6 addresses is specified in &lt;a&#xA;     *   href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;>&lt;i>RFC&amp;nbsp;2373: IPv6&#xA;     *   Addressing Architecture&lt;/i>&lt;/a>.  &lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * The host component of a URI cannot contain escaped octets, hence this&#xA;     * method does not perform any decoding.&#xA;     *&#xA;     * @return  The host component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the host is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPort">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the port number of this URI.&#xA;     *&#xA;     * &lt;p> The port component of a URI, if defined, is a non-negative&#xA;     * integer. &lt;/p>&#xA;     *&#xA;     * @return  The port component of this URI,&#xA;     *          or &lt;tt>-1&lt;/tt> if the port is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getRawPath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the raw path component of this URI.&#xA;     *&#xA;     * &lt;p> The path component of a URI, if defined, only contains the slash&#xA;     * character (&lt;tt>'/'&lt;/tt>), the commercial-at character (&lt;tt>'@'&lt;/tt>),&#xA;     * and characters in the &lt;i>unreserved&lt;/i>, &lt;i>punct&lt;/i>, &lt;i>escaped&lt;/i>,&#xA;     * and &lt;i>other&lt;/i> categories. &lt;/p>&#xA;     *&#xA;     * @return  The path component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the path is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the decoded path component of this URI.&#xA;     *&#xA;     * &lt;p> The string returned by this method is equal to that returned by the&#xA;     * {@link #getRawPath() getRawPath} method except that all sequences of&#xA;     * escaped octets are &lt;a href=&quot;#decode&quot;>decoded&lt;/a>.  &lt;/p>&#xA;     *&#xA;     * @return  The decoded path component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the path is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.135">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getRawQuery">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the raw query component of this URI.&#xA;     *&#xA;     * &lt;p> The query component of a URI, if defined, only contains legal URI&#xA;     * characters. &lt;/p>&#xA;     *&#xA;     * @return  The raw query component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the query is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getQuery">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the decoded query component of this URI.&#xA;     *&#xA;     * &lt;p> The string returned by this method is equal to that returned by the&#xA;     * {@link #getRawQuery() getRawQuery} method except that all sequences of&#xA;     * escaped octets are &lt;a href=&quot;#decode&quot;>decoded&lt;/a>.  &lt;/p>&#xA;     *&#xA;     * @return  The decoded query component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the query is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.135">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getRawFragment">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the raw fragment component of this URI.&#xA;     *&#xA;     * &lt;p> The fragment component of a URI, if defined, only contains legal URI&#xA;     * characters. &lt;/p>&#xA;     *&#xA;     * @return  The raw fragment component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the fragment is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getFragment">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the decoded fragment component of this URI.&#xA;     *&#xA;     * &lt;p> The string returned by this method is equal to that returned by the&#xA;     * {@link #getRawFragment() getRawFragment} method except that all&#xA;     * sequences of escaped octets are &lt;a href=&quot;#decode&quot;>decoded&lt;/a>.  &lt;/p>&#xA;     *&#xA;     * @return  The decoded fragment component of this URI,&#xA;     *          or &lt;tt>null&lt;/tt> if the fragment is undefined&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.135">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ob">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Equality, comparison, hash code, toString, and serialization --</comments>
        <comments>/**&#xA;     * Tests this URI for equality with another object.&#xA;     *&#xA;     * &lt;p> If the given object is not a URI then this method immediately&#xA;     * returns &lt;tt>false&lt;/tt>.&#xA;     *&#xA;     * &lt;p> For two URIs to be considered equal requires that either both are&#xA;     * opaque or both are hierarchical.  Their schemes must either both be&#xA;     * undefined or else be equal without regard to case. Their fragments&#xA;     * must either both be undefined or else be equal.&#xA;     *&#xA;     * &lt;p> For two opaque URIs to be considered equal, their scheme-specific&#xA;     * parts must be equal.&#xA;     *&#xA;     * &lt;p> For two hierarchical URIs to be considered equal, their paths must&#xA;     * be equal and their queries must either both be undefined or else be&#xA;     * equal.  Their authorities must either both be undefined, or both be&#xA;     * registry-based, or both be server-based.  If their authorities are&#xA;     * defined and are registry-based, then they must be equal.  If their&#xA;     * authorities are defined and are server-based, then their hosts must be&#xA;     * equal without regard to case, their port numbers must be equal, and&#xA;     * their user-information components must be equal.&#xA;     *&#xA;     * &lt;p> When testing the user-information, path, query, fragment, authority,&#xA;     * or scheme-specific parts of two URIs for equality, the raw forms rather&#xA;     * than the encoded forms of these components are compared and the&#xA;     * hexadecimal digits of escaped octets are compared without regard to&#xA;     * case.&#xA;     *&#xA;     * &lt;p> This method satisfies the general contract of the {@link&#xA;     * java.lang.Object#equals(Object) Object.equals} method. &lt;/p>&#xA;     *&#xA;     * @param   ob   The object to which this object is to be compared&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, the given object is a URI that&#xA;     *          is identical to this URI&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="that">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.57">
            <arguments xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </arguments>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.56">
            <arguments xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </arguments>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Opaque</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.56">
            <arguments xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
            </arguments>
          </returnValue>
        </statement>
        <condition xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
          <self xsi:type="literals:This"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Hierarchical</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.56">
            <arguments xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            </arguments>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.56">
            <arguments xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            </arguments>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Authorities</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// Server-based</comments>
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="literals:BooleanLiteral"/>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.56">
                <arguments xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                </arguments>
              </child>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="literals:BooleanLiteral"/>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.57">
                <arguments xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </arguments>
              </child>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="literals:BooleanLiteral"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
                <self xsi:type="literals:This"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <comments>// Registry-based</comments>
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral"/>
              </statement>
              <condition xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Negate"/>
                <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.56">
                  <arguments xsi:type="references:SelfReference">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                    <self xsi:type="literals:This"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  </arguments>
                </child>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                <self xsi:type="literals:This"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.2/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </children>
            </condition>
          </elseStatement>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a hash-code value for this URI.  The hash code is based upon all&#xA;     * of the URI's components, and satisfies the general contract of the&#xA;     * {@link java.lang.Object#hashCode() Object.hashCode} method.&#xA;     *&#xA;     * @return  A hash-code value for this URI&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="h">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.59">
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.58">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.58">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.58">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.58">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.58">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.59">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                  <value xsi:type="expressions:MultiplicativeExpression">
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1949"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
                    <multiplicativeOperators xsi:type="operators:Multiplication"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.58">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  </value>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="that">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Compares this URI to another object, which must be a URI.&#xA;     *&#xA;     * &lt;p> When comparing corresponding components of two URIs, if one&#xA;     * component is undefined but the other is defined then the first is&#xA;     * considered to be less than the second.  Unless otherwise noted, string&#xA;     * components are ordered according to their natural, case-sensitive&#xA;     * ordering as defined by the {@link java.lang.String#compareTo(Object)&#xA;     * String.compareTo} method.  String components that are subject to&#xA;     * encoding are compared by comparing their raw forms rather than their&#xA;     * encoded forms.&#xA;     *&#xA;     * &lt;p> The ordering of URIs is defined as follows: &lt;/p>&#xA;     *&#xA;     * &lt;ul type=disc>&#xA;     *&#xA;     *   &lt;li>&lt;p> Two URIs with different schemes are ordered according the&#xA;     *   ordering of their schemes, without regard to case. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> A hierarchical URI is considered to be less than an opaque URI&#xA;     *   with an identical scheme. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> Two opaque URIs with identical schemes are ordered according&#xA;     *   to the ordering of their scheme-specific parts. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> Two opaque URIs with identical schemes and scheme-specific&#xA;     *   parts are ordered according to the ordering of their&#xA;     *   fragments. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> Two hierarchical URIs with identical schemes are ordered&#xA;     *   according to the ordering of their authority components: &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;ul type=disc>&#xA;     *&#xA;     *     &lt;li>&lt;p> If both authority components are server-based then the URIs&#xA;     *     are ordered according to their user-information components; if these&#xA;     *     components are identical then the URIs are ordered according to the&#xA;     *     ordering of their hosts, without regard to case; if the hosts are&#xA;     *     identical then the URIs are ordered according to the ordering of&#xA;     *     their ports. &lt;/p>&lt;/li>&#xA;     *&#xA;     *     &lt;li>&lt;p> If one or both authority components are registry-based then&#xA;     *     the URIs are ordered according to the ordering of their authority&#xA;     *     components. &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;/ul>&#xA;     *&#xA;     *   &lt;li>&lt;p> Finally, two hierarchical URIs with identical schemes and&#xA;     *   authority components are ordered according to the ordering of their&#xA;     *   paths; if their paths are identical then they are ordered according to&#xA;     *   the ordering of their queries; if the queries are identical then they&#xA;     *   are ordered according to the order of their fragments. &lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p> This method satisfies the general contract of the {@link&#xA;     * java.lang.Comparable#compareTo(Object) Comparable.compareTo}&#xA;     * method. &lt;/p>&#xA;     *&#xA;     * @param   ob&#xA;     *          The object to which this URI is to be compared&#xA;     *&#xA;     * @return  A negative integer, zero, or a positive integer as this URI is&#xA;     *          less than, equal to, or greater than the given URI&#xA;     *&#xA;     * @throws  ClassCastException&#xA;     *          If the given object is not a URI&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:Int"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.61">
                <arguments xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                </arguments>
              </value>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <comments>// Opaque > hierarchical</comments>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <comments>// Both opaque</comments>
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.60">
                        <arguments xsi:type="references:SelfReference">
                          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
                          <self xsi:type="literals:This"/>
                        </arguments>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
                        </arguments>
                      </value>
                    </expression>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.60">
                  <arguments xsi:type="references:SelfReference">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                    <self xsi:type="literals:This"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  </arguments>
                </returnValue>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Addition"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="references:SelfReference">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
          <self xsi:type="literals:This"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <comments>// Hierarchical &lt; opaque</comments>
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </returnValue>
            </statements>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Hierarchical</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// Both server-based</comments>
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.60">
                    <arguments xsi:type="references:SelfReference">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                      <self xsi:type="literals:This"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                    </arguments>
                  </value>
                </expression>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.61">
                    <arguments xsi:type="references:SelfReference">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                      <self xsi:type="literals:This"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                    </arguments>
                  </value>
                </expression>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:SelfReference">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
                      <self xsi:type="literals:This"/>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
                    </children>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                  </value>
                </expression>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                <self xsi:type="literals:This"/>
              </children>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </children>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// If one or both authorities are registry-based then we simply</comments>
            <comments>// compare them in the usual, case-sensitive way.  If one is</comments>
            <comments>// registry-based and one is server-based then the strings are</comments>
            <comments>// guaranteed to be unequal, hence the comparison will never return</comments>
            <comments>// zero and the compareTo and equals methods will remain</comments>
            <comments>// consistent.</comments>
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.60">
                    <arguments xsi:type="references:SelfReference">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                      <self xsi:type="literals:This"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                    </arguments>
                  </value>
                </expression>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.60">
                <arguments xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                </arguments>
              </value>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.60">
                <arguments xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                </arguments>
              </value>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.60">
          <arguments xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the content of this URI as a string.&#xA;     *&#xA;     * &lt;p> If this URI was created by invoking one of the constructors in this&#xA;     * class then a string equivalent to the original input string, or to the&#xA;     * string computed from the originally-given components, as appropriate, is&#xA;     * returned.  Otherwise this URI was created by normalization, resolution,&#xA;     * or relativization, and so a string is constructed from this URI's&#xA;     * components according to the rules specified in &lt;a&#xA;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;>RFC&amp;nbsp;2396&lt;/a>,&#xA;     * section&amp;nbsp;5.2, step&amp;nbsp;7. &lt;/p>&#xA;     *&#xA;     * @return  The string form of this URI&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.68"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toASCIIString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the content of this URI as a US-ASCII string.&#xA;     *&#xA;     * &lt;p> If this URI does not contain any characters in the &lt;i>other&lt;/i>&#xA;     * category then an invocation of this method will return the same value as&#xA;     * an invocation of the {@link #toString() toString} method.  Otherwise&#xA;     * this method works as if by invoking that method and then &lt;a&#xA;     * href=&quot;#encode&quot;>encoding&lt;/a> the result.  &lt;/p>&#xA;     *&#xA;     * @return  The string form of this URI, encoded as needed&#xA;     *          so that it only contains characters in the US-ASCII&#xA;     *          charset&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.68"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.132">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeObject">
      <comments>// Writes the string field only</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="os">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// -- Serialization support --</comments>
        <comments>/**&#xA;     * Saves the content of this URI to the given serial stream.&#xA;     *&#xA;     * &lt;p> The only serializable field of a URI instance is its &lt;tt>string&lt;/tt>&#xA;     * field.  That field is given a value, if it does not have one already,&#xA;     * and then the {@link java.io.ObjectOutputStream#defaultWriteObject()}&#xA;     * method of the given object-output stream is invoked. &lt;/p>&#xA;     *&#xA;     * @param  os  The object-output stream to which this object&#xA;     *             is to be written&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.68"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectOutputStream.class.xmi#//@classifiers.0/@members.17"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="is">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../io/ObjectInputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Reconstitutes a URI from the given serial stream.&#xA;     *&#xA;     * &lt;p> The {@link java.io.ObjectInputStream#defaultReadObject()} method is&#xA;     * invoked to read the value of the &lt;tt>string&lt;/tt> field.  The result is&#xA;     * then parsed in the usual way.&#xA;     *&#xA;     * @param  is  The object-input stream from which this object&#xA;     *             is being read&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0">
          <comments>// Argh</comments>
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../io/ObjectInputStream.class.xmi#//@classifiers.0/@members.19"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0/@members.136"/>
            </typeReference>
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.17">
              <arguments xsi:type="literals:BooleanLiteral"/>
            </next>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="y">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../io/InvalidObjectException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Invalid URI"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.2/@catcheBlocks.0/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Throwable.class.xmi#//@classifiers.0/@members.12"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.2/@catcheBlocks.0/@parameter"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.2/@catcheBlocks.0/@statements.0/@variable"/>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toLower">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// -- End of public methods --</comments>
        <comments>// -- Utility methods for string-field comparison and hashing --</comments>
        <comments>// These methods return appropriate values for null string arguments,</comments>
        <comments>// thereby simplifying the equals, hashCode, and compareTo methods.</comments>
        <comments>//</comments>
        <comments>// The case-ignoring methods should only be applied to strings whose</comments>
        <comments>// characters are all known to be US-ASCII.  Because of this restriction,</comments>
        <comments>// these methods are faster than the similar methods in the String class.</comments>
        <comments>// US-ASCII only</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.0"/>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="literals:CharacterLiteral" value="97"/>
                <children xsi:type="literals:CharacterLiteral" value="65"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </expression>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.0"/>
              <children xsi:type="literals:CharacterLiteral" value="65"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.0"/>
              <children xsi:type="literals:CharacterLiteral" value="90"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equal">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="t">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.1"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="literals:BooleanLiteral"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                </next>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.1"/>
                </next>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.45"/>
                  <arguments xsi:type="literals:CharacterLiteral" value="37"/>
                </next>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="n">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="c">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@init"/>
                    </next>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="d">
                  <typeReference xsi:type="types:Char"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.1">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@init"/>
                    </next>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Return">
                      <returnValue xsi:type="literals:BooleanLiteral"/>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@statement/@statements.1/@variable"/>
                    </condition>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@init"/>
                      <operator xsi:type="operators:PlusPlus"/>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:Continue"/>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@statement/@statements.0/@variable"/>
                  <children xsi:type="literals:CharacterLiteral" value="37"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="literals:BooleanLiteral"/>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@init"/>
                      </next>
                    </arguments>
                  </children>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.1">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@init"/>
                      </next>
                    </arguments>
                  </children>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="literals:BooleanLiteral"/>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@init"/>
                      </next>
                    </arguments>
                  </children>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.1">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@init"/>
                      </next>
                    </arguments>
                  </children>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.3/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@statements.1/@statement/@statements.2/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.1"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equalIgnoringCase">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="t">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// US-ASCII only</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.1"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="n">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="literals:BooleanLiteral"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                </next>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@statements.1/@statement/@statements.0/@variable"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="literals:BooleanLiteral"/>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@statements.1/@statement/@statements.2/@init"/>
                      </next>
                    </arguments>
                  </children>
                  <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.1">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@statements.1/@statement/@statements.2/@init"/>
                      </next>
                    </arguments>
                  </children>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@statements.1/@statement/@statements.2/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@statements.1/@statement/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@statements.1/@statement/@statements.2/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.1"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hash">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hash">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="127"/>
            <multiplicativeOperators xsi:type="operators:Multiplication"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.44"/>
            </next>
          </children>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashIgnoringCase">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hash">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// US-ASCII only</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="h">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="31"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.1/@variable"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </children>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.1">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.3/@init"/>
                  </next>
                </arguments>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compare">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="t">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.1"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.37"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.1"/>
                </next>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.1"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
            <elseStatement xsi:type="statements:Return">
              <returnValue xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Addition"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </returnValue>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareIgnoringCase">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="t">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// US-ASCII only</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.1"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="sn">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                    </next>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="tn">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.1">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                    </next>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="n">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="expressions:ConditionalExpression">
                    <child xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.1/@variable"/>
                      <relationOperators xsi:type="operators:LessThan"/>
                    </child>
                    <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.0/@variable"/>
                    <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.1/@variable"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="c">
                      <typeReference xsi:type="types:Int"/>
                      <initialValue xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.0">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.3/@init"/>
                            </next>
                          </arguments>
                        </children>
                        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.55">
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.1">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.3/@init"/>
                            </next>
                          </arguments>
                        </children>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Return">
                      <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.3/@statement/@statements.0/@variable"/>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.3/@statement/@statements.0/@variable"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.3/@init"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.2/@variable"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
                <init xsi:type="variables:LocalVariable" name="i">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </init>
                <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.3/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </updates>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@statement/@statements.0/@statement/@statements.1/@variable"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </returnValue>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.1"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Addition"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkPath">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scheme">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// -- String construction --</comments>
        <comments>// If a scheme is given then the path, if given, must be absolute</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@parameters.0"/>
                <arguments xsi:type="references:StringReference" value="Relative path in absolute URI"/>
              </throwable>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@parameters.2"/>
                  <children xsi:type="literals:NullLiteral"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@parameters.2">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                        </next>
                      </children>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <relationOperators xsi:type="operators:GreaterThan"/>
                    </expression>
                  </children>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@parameters.2">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        </next>
                      </children>
                      <children xsi:type="literals:CharacterLiteral" value="47"/>
                    </expression>
                  </children>
                </expression>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.62/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendAuthority">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sb">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="authority">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="userInfo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="host">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="port">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:StringReference" value="//"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.131">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.2"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                    <arguments xsi:type="literals:CharacterLiteral" value="64"/>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.2"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="needBrackets">
              <typeReference xsi:type="types:Boolean"/>
              <initialValue xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.3">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.45"/>
                          <arguments xsi:type="literals:CharacterLiteral" value="58"/>
                        </next>
                      </children>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                    </expression>
                  </children>
                  <children xsi:type="expressions:UnaryExpression">
                    <operators xsi:type="operators:Negate"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.3">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.42"/>
                        <arguments xsi:type="references:StringReference" value="["/>
                      </next>
                    </child>
                  </children>
                  <children xsi:type="expressions:UnaryExpression">
                    <operators xsi:type="operators:Negate"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.3">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.43"/>
                        <arguments xsi:type="references:StringReference" value="]"/>
                      </next>
                    </child>
                  </children>
                </expression>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                  <arguments xsi:type="literals:CharacterLiteral" value="91"/>
                </next>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@statement/@statements.2/@variable"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.3"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                  <arguments xsi:type="literals:CharacterLiteral" value="93"/>
                </next>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@statement/@statements.2/@variable"/>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                    <arguments xsi:type="literals:CharacterLiteral" value="58"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.27"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.4"/>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.4"/>
              <children xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.3"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:StringReference" value="//"/>
                </next>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="end">
                    <typeReference xsi:type="types:Int"/>
                    <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.1">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.49"/>
                        <arguments xsi:type="references:StringReference" value="]"/>
                      </next>
                    </initialValue>
                  </variable>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:LocalVariableStatement">
                      <variable name="doquote">
                        <typeReference xsi:type="types:NamespaceClassifierReference">
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </typeReference>
                        <additionalLocalVariables name="dontquote"/>
                      </variable>
                    </statements>
                    <statements xsi:type="statements:Condition">
                      <statement xsi:type="statements:Block">
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="expressions:AssignmentExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@elseStatement/@statement/@statements.1/@statement/@statements.1/@statement/@statements.0/@variable/@additionalLocalVariables.0"/>
                            <assignmentOperator xsi:type="operators:Assignment"/>
                            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.1"/>
                          </expression>
                        </statements>
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="expressions:AssignmentExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@elseStatement/@statement/@statements.1/@statement/@statements.1/@statement/@statements.0/@variable"/>
                            <assignmentOperator xsi:type="operators:Assignment"/>
                            <value xsi:type="references:StringReference" value=""/>
                          </expression>
                        </statements>
                      </statement>
                      <condition xsi:type="expressions:EqualityExpression">
                        <equalityOperators xsi:type="operators:Equal"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@elseStatement/@statement/@statements.1/@statement/@statements.0/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.1">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                          </next>
                        </children>
                      </condition>
                      <elseStatement xsi:type="statements:Block">
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="expressions:AssignmentExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@elseStatement/@statement/@statements.1/@statement/@statements.1/@statement/@statements.0/@variable/@additionalLocalVariables.0"/>
                            <assignmentOperator xsi:type="operators:Assignment"/>
                            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.1">
                              <next xsi:type="references:MethodCall">
                                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.56"/>
                                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                                <arguments xsi:type="expressions:AdditiveExpression">
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@elseStatement/@statement/@statements.1/@statement/@statements.0/@variable"/>
                                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                  <additiveOperators xsi:type="operators:Addition"/>
                                </arguments>
                              </next>
                            </value>
                          </expression>
                        </statements>
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="expressions:AssignmentExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@elseStatement/@statement/@statements.1/@statement/@statements.1/@statement/@statements.0/@variable"/>
                            <assignmentOperator xsi:type="operators:Assignment"/>
                            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.1">
                              <next xsi:type="references:MethodCall">
                                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.55"/>
                                <arguments xsi:type="expressions:AdditiveExpression">
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@elseStatement/@statement/@statements.1/@statement/@statements.0/@variable"/>
                                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                  <additiveOperators xsi:type="operators:Addition"/>
                                </arguments>
                              </next>
                            </value>
                          </expression>
                        </statements>
                      </elseStatement>
                    </statements>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@elseStatement/@statement/@statements.1/@statement/@statements.1/@statement/@statements.0/@variable/@additionalLocalVariables.0"/>
                        </next>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.131">
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@elseStatement/@statement/@statements.1/@statement/@statements.1/@statement/@statements.0/@variable"/>
                            <arguments xsi:type="expressions:InclusiveOrExpression">
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.118"/>
                            </arguments>
                            <arguments xsi:type="expressions:InclusiveOrExpression">
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119"/>
                            </arguments>
                          </arguments>
                        </next>
                      </expression>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:ConditionalAndExpression">
                    <children xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@statements.0/@elseStatement/@statement/@statements.1/@statement/@statements.0/@variable"/>
                      <children xsi:type="expressions:UnaryExpression">
                        <operators xsi:type="operators:Subtraction"/>
                        <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      </children>
                    </children>
                    <children xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.1">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.49"/>
                          <arguments xsi:type="references:StringReference" value=":"/>
                        </next>
                      </children>
                      <children xsi:type="expressions:UnaryExpression">
                        <operators xsi:type="operators:Subtraction"/>
                        <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      </children>
                    </children>
                  </condition>
                </statements>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.42"/>
                  <arguments xsi:type="references:StringReference" value="["/>
                </next>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                      <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.131">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.1"/>
                        <arguments xsi:type="expressions:InclusiveOrExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.118"/>
                        </arguments>
                        <arguments xsi:type="expressions:InclusiveOrExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119"/>
                        </arguments>
                      </arguments>
                    </next>
                  </expression>
                </statements>
              </elseStatement>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.63/@parameters.1"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendSchemeSpecificPart">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sb">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="opaquePart">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="authority">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="userInfo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="host">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="port">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="query">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>/* check if SSP begins with an IPv6 address&#xA;&#x9;     * because we must not quote a literal IPv6 address&#xA;&#x9;     */</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="end">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.1">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.49"/>
                      <arguments xsi:type="references:StringReference" value="]"/>
                    </next>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="doquote">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <additionalLocalVariables name="dontquote"/>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.0/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable/@additionalLocalVariables.0"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.1"/>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.0/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:StringReference" value=""/>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.0/@statement/@statements.0/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.1">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                        </next>
                      </children>
                    </condition>
                    <elseStatement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.0/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable/@additionalLocalVariables.0"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.1">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.56"/>
                              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                              <arguments xsi:type="expressions:AdditiveExpression">
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.0/@statement/@statements.0/@statement/@statements.0/@variable"/>
                                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                <additiveOperators xsi:type="operators:Addition"/>
                              </arguments>
                            </next>
                          </value>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.0/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.1">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.55"/>
                              <arguments xsi:type="expressions:AdditiveExpression">
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.0/@statement/@statements.0/@statement/@statements.0/@variable"/>
                                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                <additiveOperators xsi:type="operators:Addition"/>
                              </arguments>
                            </next>
                          </value>
                        </expression>
                      </statements>
                    </elseStatement>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.0/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable/@additionalLocalVariables.0"/>
                      </next>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                        <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.131">
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.0/@statement/@statements.0/@statement/@statements.1/@statement/@statements.0/@variable"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105"/>
                        </arguments>
                      </next>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@statements.0/@statement/@statements.0/@statement/@statements.0/@variable"/>
                    <children xsi:type="expressions:UnaryExpression">
                      <operators xsi:type="operators:Subtraction"/>
                      <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </children>
                  </children>
                  <children xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.1">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.49"/>
                        <arguments xsi:type="references:StringReference" value=":"/>
                      </next>
                    </children>
                    <children xsi:type="expressions:UnaryExpression">
                      <operators xsi:type="operators:Subtraction"/>
                      <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </children>
                  </children>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.1">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.42"/>
                <arguments xsi:type="references:StringReference" value="//["/>
              </next>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.131">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.1"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.63">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.3"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.4"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.5"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.131">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.6"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.109"/>
                  </arguments>
                </next>
              </expression>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.6"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                    <arguments xsi:type="literals:CharacterLiteral" value="63"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.131">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.7"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.64/@parameters.7"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendFragment">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sb">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fragment">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                <arguments xsi:type="literals:CharacterLiteral" value="35"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.131">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.65/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scheme">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="opaquePart">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="authority">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="userInfo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="host">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="port">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="query">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fragment">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>//</comments>
        <comments>// Note for maintainer: sun.net.www.ParseUtil.createURI(...) clones</comments>
        <comments>// this method and all necessary auxiliary code to fix 6274990-2127017.</comments>
        <comments>// Any change made here should be propagated to sun.net.www.ParseUtil.</comments>
        <comments>// The requirement only applies to 5.0 update release.</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.0"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                <arguments xsi:type="literals:CharacterLiteral" value="58"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.64">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.0/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.3"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.4"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.5"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.6"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.7"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.65">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.0/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@parameters.8"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.66/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="defineSchemeSpecificPart">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return"/>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.64">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.1/@variable"/>
          <arguments xsi:type="literals:NullLiteral"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.37"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.39"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.43"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.45"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return"/>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.6"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
            </next>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="defineString">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return"/>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                <arguments xsi:type="literals:CharacterLiteral" value="58"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="references:StringReference" value="//"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                      </next>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                        <arguments xsi:type="literals:CharacterLiteral" value="64"/>
                      </next>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                  <children xsi:type="literals:NullLiteral"/>
                </condition>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="needBrackets">
                  <typeReference xsi:type="types:Boolean"/>
                  <initialValue xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:ConditionalAndExpression">
                      <children xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:RelationExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.45"/>
                              <arguments xsi:type="literals:CharacterLiteral" value="58"/>
                            </next>
                          </children>
                          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                        </expression>
                      </children>
                      <children xsi:type="expressions:UnaryExpression">
                        <operators xsi:type="operators:Negate"/>
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.42"/>
                            <arguments xsi:type="references:StringReference" value="["/>
                          </next>
                        </child>
                      </children>
                      <children xsi:type="expressions:UnaryExpression">
                        <operators xsi:type="operators:Negate"/>
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.43"/>
                            <arguments xsi:type="references:StringReference" value="]"/>
                          </next>
                        </child>
                      </children>
                    </expression>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                      <arguments xsi:type="literals:CharacterLiteral" value="91"/>
                    </next>
                  </expression>
                </statement>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.3/@elseStatement/@statements.0/@statement/@statements.2/@variable"/>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                      <arguments xsi:type="literals:CharacterLiteral" value="93"/>
                    </next>
                  </expression>
                </statement>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.3/@elseStatement/@statements.0/@statement/@statements.2/@variable"/>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                        <arguments xsi:type="literals:CharacterLiteral" value="58"/>
                      </next>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.27"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
                      </next>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
                  <children xsi:type="expressions:UnaryExpression">
                    <operators xsi:type="operators:Subtraction"/>
                    <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  </children>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
            <elseStatement xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                      <arguments xsi:type="references:StringReference" value="//"/>
                    </next>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                    </next>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                <children xsi:type="literals:NullLiteral"/>
              </condition>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                </next>
              </expression>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                    <arguments xsi:type="literals:CharacterLiteral" value="63"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                <arguments xsi:type="literals:CharacterLiteral" value="35"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
            </next>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="resolvePath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="base">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="child">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="absolute">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// -- Normalization, resolution, and relativization --</comments>
        <comments>// RFC2396 5.2 (6)</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.47"/>
              <arguments xsi:type="literals:CharacterLiteral" value="47"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cn">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="path">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:StringReference" value=""/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// 5.2 (6a)</comments>
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.2/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.56"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.0/@variable"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </next>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.1/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="sb">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                    </next>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.1/@variable"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// 5.2 (6a)</comments>
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.3/@elseStatement/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.56"/>
                      <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.0/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </arguments>
                    </next>
                  </arguments>
                </next>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.3/@elseStatement/@statements.0/@variable">
              <comments>// 5.2 (6b)</comments>
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@parameters.1"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.3/@elseStatement/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
                </next>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="np">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// 5.2 (6c-f)</comments>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.2/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// 5.2 (6g): If the result is absolute but the path begins with &quot;../&quot;,</comments>
        <comments>// then we simply leave the path as-is</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.69/@statements.4/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="resolve">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="base">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="child">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// RFC2396 5.2</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <comments>// check if child if opaque first so that NPE is thrown </comments>
        <comments>// if child is null.</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1"/>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// 5.2 (2): Reference to current document (lone fragment)</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  </children>
                  <children xsi:type="literals:NullLiteral"/>
                </expression>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                    </arguments>
                  </next>
                </next>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="ru">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <initialValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@statement/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@statement/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@statement/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@statement/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@statement/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@statement/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@statement/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@statement/@statements.1/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.1/@statement/@statements.1/@variable"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </children>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </children>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:StringReference" value=""/>
              </next>
            </next>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              </children>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
              </children>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// 5.2 (3): Child is absolute</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </children>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ru">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
            <comments>// Resolved URI</comments>
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// 5.2 (4): Authority</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="cp">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:ConditionalExpression">
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                    </children>
                    <children xsi:type="literals:NullLiteral"/>
                  </expression>
                </child>
                <expressionIf xsi:type="references:StringReference" value=""/>
                <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                </expressionElse>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                    <comments>// 5.2 (5): Child path is absolute</comments>
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.7/@statement/@statements.4/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                    </next>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.7/@statement/@statements.4/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    </next>
                  </children>
                  <children xsi:type="literals:CharacterLiteral" value="47"/>
                </expression>
              </children>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                    <comments>// 5.2 (6): Resolve relative path</comments>
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.69">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                      <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.7/@statement/@statements.4/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.0">
                      <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.32"/>
                    </arguments>
                  </value>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          </children>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// 5.2 (7): Recombine (nothing to do here)</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.70/@statements.3/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="normalize">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="u">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// If the given URI's path is normal then return the URI;</comments>
        <comments>// o.w., return a new URI containing the normalized path.</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              </children>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                  </next>
                </next>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="np">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.1/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.1/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.3/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@parameters.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.71/@statements.3/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="relativize">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="base">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="child">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// If both URIs are hierarchical, their scheme and authority components are</comments>
        <comments>// identical, and the base path is a prefix of the child's path, then</comments>
        <comments>// return a relative URI that, when resolved against the base, yields the</comments>
        <comments>// child; otherwise, return the child.</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <comments>// check if child if opaque first so that NPE is thrown </comments>
        <comments>// if child is null.</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.1"/>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.1">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.1"/>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.57">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </arguments>
            </child>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.56">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.0">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              </arguments>
            </child>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bp">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cp">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.78">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.1">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.2/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.2/@variable"/>
                  <children xsi:type="references:StringReference" value="/"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.2/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.43"/>
                  <arguments xsi:type="references:StringReference" value="/"/>
                </next>
              </child>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.1"/>
            </statement>
            <condition xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.3/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.42"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.2/@variable"/>
                </next>
              </child>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.2/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.3/@variable"/>
            </next>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.5/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.3/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.55"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.2/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                </next>
              </arguments>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.5/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.5/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@parameters.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.72/@statements.5/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="needsNormalization">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// -- Path normalization --</comments>
        <comments>// The following algorithm for path normalization avoids the creation of a</comments>
        <comments>// string object for each segment, as well as the use of a string buffer to</comments>
        <comments>// compute the final result, by using a single char array and editing it in</comments>
        <comments>// place.  The array is first split into segments, replacing each slash</comments>
        <comments>// with '\0' and creating a segment-index array, each element of which is</comments>
        <comments>// the index of the first char in the corresponding segment.  We then walk</comments>
        <comments>// through both arrays, removing &quot;.&quot;, &quot;..&quot;, and other segments as necessary</comments>
        <comments>// by setting their entries in the index array to -1.  Finally, the two</comments>
        <comments>// arrays are used to rejoin the segments and compute the final result.</comments>
        <comments>//</comments>
        <comments>// This code is based upon src/solaris/native/java/io/canonicalize_md.c</comments>
        <comments>// Check the given path to see if it might need normalization.  A path</comments>
        <comments>// might need normalization if it contains duplicate slashes, a &quot;.&quot;</comments>
        <comments>// segment, or a &quot;..&quot; segment.  Return -1 if no further normalization is</comments>
        <comments>// possible, otherwise return the number of segments found.</comments>
        <comments>//</comments>
        <comments>// This method takes a string argument rather than a char array so that</comments>
        <comments>// this test can be performed without invoking path.toCharArray().</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="normal">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral" value="true"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ns">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="end">
          <typeReference xsi:type="types:Int">
            <comments>// Number of segments</comments>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
              </next>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int">
            <comments>// Index of last char in path</comments>
          </typeReference>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// Index of next char in path</comments>
        <comments>// Skip initial slashes</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
                </next>
              </children>
              <children xsi:type="literals:CharacterLiteral" value="47"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:BooleanLiteral"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// Scan segments</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <comments>// Looking at &quot;.&quot; or &quot;..&quot; ?</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:BooleanLiteral"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
                    </next>
                  </children>
                  <children xsi:type="literals:CharacterLiteral" value="46"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ConditionalOrExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.2/@variable"/>
                    </expression>
                  </children>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:ConditionalOrExpression">
                      <children xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:EqualityExpression">
                          <equalityOperators xsi:type="operators:Equal"/>
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                              <arguments xsi:type="expressions:AdditiveExpression">
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
                                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                <additiveOperators xsi:type="operators:Addition"/>
                              </arguments>
                            </next>
                          </children>
                          <children xsi:type="literals:CharacterLiteral" value="47"/>
                        </expression>
                      </children>
                      <children xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:ConditionalAndExpression">
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:EqualityExpression">
                              <equalityOperators xsi:type="operators:Equal"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0">
                                <next xsi:type="references:MethodCall">
                                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                                  <arguments xsi:type="expressions:AdditiveExpression">
                                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
                                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                    <additiveOperators xsi:type="operators:Addition"/>
                                  </arguments>
                                </next>
                              </children>
                              <children xsi:type="literals:CharacterLiteral" value="46"/>
                            </expression>
                          </children>
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:ConditionalOrExpression">
                              <children xsi:type="expressions:NestedExpression">
                                <expression xsi:type="expressions:EqualityExpression">
                                  <equalityOperators xsi:type="operators:Equal"/>
                                  <children xsi:type="expressions:AdditiveExpression">
                                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
                                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                    <additiveOperators xsi:type="operators:Addition"/>
                                  </children>
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.2/@variable"/>
                                </expression>
                              </children>
                              <children xsi:type="expressions:NestedExpression">
                                <expression xsi:type="expressions:EqualityExpression">
                                  <equalityOperators xsi:type="operators:Equal"/>
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0">
                                    <next xsi:type="references:MethodCall">
                                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                                      <arguments xsi:type="expressions:AdditiveExpression">
                                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
                                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                                        <additiveOperators xsi:type="operators:Addition"/>
                                      </arguments>
                                    </next>
                                  </children>
                                  <children xsi:type="literals:CharacterLiteral" value="47"/>
                                </expression>
                              </children>
                            </expression>
                          </children>
                        </expression>
                      </children>
                    </expression>
                  </children>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.1/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
          <statements xsi:type="statements:WhileLoop">
            <comments>// Find beginning of next segment</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Continue"/>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
                        <operator xsi:type="operators:PlusPlus"/>
                      </arguments>
                    </next>
                  </children>
                  <children xsi:type="literals:CharacterLiteral" value="47"/>
                </condition>
              </statements>
              <statements xsi:type="statements:WhileLoop">
                <comments>// Skip redundant slashes</comments>
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Break"/>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@parameters.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
                        </next>
                      </children>
                      <children xsi:type="literals:CharacterLiteral" value="47"/>
                    </condition>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.0/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:BooleanLiteral"/>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
                      <operator xsi:type="operators:PlusPlus"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.2/@variable"/>
                  <relationOperators xsi:type="operators:LessThanOrEqual"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Break"/>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.2/@variable"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.3/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.0/@variable"/>
          <expressionIf xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.73/@statements.1/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="split">
      <comments>// ASSERT</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="segs">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// Split the given path into segments, replacing slashes with nulls and</comments>
        <comments>// filling in the given segment-index array.</comments>
        <comments>//</comments>
        <comments>// Preconditions:</comments>
        <comments>//   segs.length == Number of segments in path</comments>
        <comments>//</comments>
        <comments>// Postconditions:</comments>
        <comments>//   All slashes in path replaced by '\0'</comments>
        <comments>//   segs[i] == Index of first char in segment i (0 &lt;= i &lt; segs.length)</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="end">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int">
            <comments>// Index of last char in path</comments>
          </typeReference>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="i">
          <typeReference xsi:type="types:Int">
            <comments>// Index of next char in path</comments>
          </typeReference>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// Index of current segment</comments>
        <comments>// Skip initial slashes</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
                </arraySelectors>
              </children>
              <children xsi:type="literals:CharacterLiteral" value="47"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:CharacterLiteral"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.1">
                <comments>// Note start of segment</comments>
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.2/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
                <operator xsi:type="operators:PlusPlus"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:WhileLoop">
            <comments>// Find beginning of next segment</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Continue"/>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.0">
                    <arraySelectors>
                      <position xsi:type="expressions:SuffixUnaryModificationExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
                        <operator xsi:type="operators:PlusPlus"/>
                      </position>
                    </arraySelectors>
                  </children>
                  <children xsi:type="literals:CharacterLiteral" value="47"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.0">
                    <arraySelectors>
                      <position xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </position>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:CharacterLiteral"/>
                </expression>
              </statements>
              <statements xsi:type="statements:WhileLoop">
                <comments>// Skip redundant slashes</comments>
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Break"/>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.0">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
                        </arraySelectors>
                      </children>
                      <children xsi:type="literals:CharacterLiteral" value="47"/>
                    </condition>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.0">
                        <arraySelectors>
                          <position xsi:type="expressions:SuffixUnaryModificationExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
                            <operator xsi:type="operators:PlusPlus"/>
                          </position>
                        </arraySelectors>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:CharacterLiteral"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.0/@variable"/>
                  <relationOperators xsi:type="operators:LessThanOrEqual"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Break"/>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.1/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/InternalError.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.74/@parameters.1">
            <next xsi:type="references:IdentifierReference"/>
          </children>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="join">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="segs">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>// Join the segments in the given path according to the given segment-index</comments>
        <comments>// array, ignoring those segments whose index entries have been set to -1,</comments>
        <comments>// and inserting slashes as needed.  Return the length of the resulting</comments>
        <comments>// path.</comments>
        <comments>//</comments>
        <comments>// Preconditions:</comments>
        <comments>//   segs[i] == -1 implies segment i is to be ignored</comments>
        <comments>//   path computed by split, as above, with '\0' having replaced '/'</comments>
        <comments>//</comments>
        <comments>// Postconditions:</comments>
        <comments>//   path[0] .. path[return value] == Resulting path</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ns">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.1">
            <next xsi:type="references:IdentifierReference"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="end">
          <typeReference xsi:type="types:Int">
            <comments>// Number of segments</comments>
          </typeReference>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int">
            <comments>// Index of last char in path</comments>
          </typeReference>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Index of next path char to write</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0">
                <comments>// Restore initial slash for absolute paths</comments>
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:CharacterLiteral" value="47"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
            </arraySelectors>
          </children>
          <children xsi:type="literals:CharacterLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <comments>// ASSERT false</comments>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="q">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.1">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.4/@init"/>
                </arraySelectors>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// Current segment</comments>
            <statement xsi:type="statements:Continue">
              <comments>// Ignore this segment</comments>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.4/@statement/@statements.0/@variable"/>
              <children xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:WhileLoop">
                <comments>// We're already at this segment, so just skip to its end</comments>
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </expression>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:RelationExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.1/@variable"/>
                      <relationOperators xsi:type="operators:LessThanOrEqual"/>
                    </expression>
                  </children>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
                        </arraySelectors>
                      </children>
                      <children xsi:type="literals:CharacterLiteral"/>
                    </expression>
                  </children>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0">
                        <comments>// Preserve trailing slash</comments>
                        <arraySelectors>
                          <position xsi:type="expressions:SuffixUnaryModificationExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
                            <operator xsi:type="operators:PlusPlus"/>
                          </position>
                        </arraySelectors>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="literals:CharacterLiteral" value="47"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.1/@variable"/>
                  <relationOperators xsi:type="operators:LessThanOrEqual"/>
                </condition>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.4/@statement/@statements.0/@variable"/>
            </condition>
            <elseStatement xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:WhileLoop">
                  <comments>// Copy q down to p</comments>
                  <statement xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0">
                        <arraySelectors>
                          <position xsi:type="expressions:SuffixUnaryModificationExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
                            <operator xsi:type="operators:PlusPlus"/>
                          </position>
                        </arraySelectors>
                      </child>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0">
                        <arraySelectors>
                          <position xsi:type="expressions:SuffixUnaryModificationExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.4/@statement/@statements.0/@variable"/>
                            <operator xsi:type="operators:PlusPlus"/>
                          </position>
                        </arraySelectors>
                      </value>
                    </expression>
                  </statement>
                  <condition xsi:type="expressions:ConditionalAndExpression">
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.4/@statement/@statements.0/@variable"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.1/@variable"/>
                        <relationOperators xsi:type="operators:LessThanOrEqual"/>
                      </expression>
                    </children>
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:EqualityExpression">
                        <equalityOperators xsi:type="operators:NotEqual"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0">
                          <arraySelectors>
                            <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.4/@statement/@statements.0/@variable"/>
                          </arraySelectors>
                        </children>
                        <children xsi:type="literals:CharacterLiteral"/>
                      </expression>
                    </children>
                  </condition>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@parameters.0">
                          <comments>// Preserve trailing slash</comments>
                          <arraySelectors>
                            <position xsi:type="expressions:SuffixUnaryModificationExpression">
                              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
                              <operator xsi:type="operators:PlusPlus"/>
                            </position>
                          </arraySelectors>
                        </child>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="literals:CharacterLiteral" value="47"/>
                      </expression>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.4/@statement/@statements.0/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.1/@variable"/>
                    <relationOperators xsi:type="operators:LessThanOrEqual"/>
                  </condition>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.4/@statement/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
              <elseStatement xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/InternalError.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </throwable>
              </elseStatement>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.4/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.4/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.75/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="removeDots">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="segs">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Remove &quot;.&quot; segments from the given path, and remove segment pairs</comments>
        <comments>// consisting of a non-&quot;..&quot; segment followed by a &quot;..&quot; segment.</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ns">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.1">
            <next xsi:type="references:IdentifierReference"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="end">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="dots">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </variable>
          </statements>
          <statements xsi:type="statements:DoWhileLoop">
            <comments>// Number of dots found (0, 1, or 2)</comments>
            <comments>// Find next occurrence of &quot;.&quot; or &quot;..&quot;</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="p">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.1">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@init"/>
                    </arraySelectors>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.0/@variable"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:Break"/>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.1/@variable"/>
                    </condition>
                    <elseStatement xsi:type="statements:Condition">
                      <statement xsi:type="statements:Block">
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="expressions:AssignmentExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.0/@variable"/>
                            <assignmentOperator xsi:type="operators:Assignment"/>
                            <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                          </expression>
                        </statements>
                        <statements xsi:type="statements:Break"/>
                      </statement>
                      <condition xsi:type="expressions:EqualityExpression">
                        <equalityOperators xsi:type="operators:Equal"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0">
                          <arraySelectors>
                            <position xsi:type="expressions:AdditiveExpression">
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable"/>
                              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                              <additiveOperators xsi:type="operators:Addition"/>
                            </position>
                          </arraySelectors>
                        </children>
                        <children xsi:type="literals:CharacterLiteral"/>
                      </condition>
                      <elseStatement xsi:type="statements:Condition">
                        <statement xsi:type="statements:Block">
                          <statements xsi:type="statements:ExpressionStatement">
                            <expression xsi:type="expressions:AssignmentExpression">
                              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.0/@variable"/>
                              <assignmentOperator xsi:type="operators:Assignment"/>
                              <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                            </expression>
                          </statements>
                          <statements xsi:type="statements:Break"/>
                        </statement>
                        <condition xsi:type="expressions:ConditionalAndExpression">
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:EqualityExpression">
                              <equalityOperators xsi:type="operators:Equal"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0">
                                <arraySelectors>
                                  <position xsi:type="expressions:AdditiveExpression">
                                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable"/>
                                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                    <additiveOperators xsi:type="operators:Addition"/>
                                  </position>
                                </arraySelectors>
                              </children>
                              <children xsi:type="literals:CharacterLiteral" value="46"/>
                            </expression>
                          </children>
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:ConditionalOrExpression">
                              <children xsi:type="expressions:NestedExpression">
                                <expression xsi:type="expressions:EqualityExpression">
                                  <equalityOperators xsi:type="operators:Equal"/>
                                  <children xsi:type="expressions:AdditiveExpression">
                                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable"/>
                                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                    <additiveOperators xsi:type="operators:Addition"/>
                                  </children>
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.1/@variable"/>
                                </expression>
                              </children>
                              <children xsi:type="expressions:NestedExpression">
                                <expression xsi:type="expressions:EqualityExpression">
                                  <equalityOperators xsi:type="operators:Equal"/>
                                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0">
                                    <arraySelectors>
                                      <position xsi:type="expressions:AdditiveExpression">
                                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable"/>
                                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                                        <additiveOperators xsi:type="operators:Addition"/>
                                      </position>
                                    </arraySelectors>
                                  </children>
                                  <children xsi:type="literals:CharacterLiteral"/>
                                </expression>
                              </children>
                            </expression>
                          </children>
                        </condition>
                      </elseStatement>
                    </elseStatement>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.1/@statement/@statements.0/@variable"/>
                    </arraySelectors>
                  </children>
                  <children xsi:type="literals:CharacterLiteral" value="46"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@init"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.0/@variable"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.1">
                    <comments>// Remove this occurrence of &quot;.&quot;</comments>
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@init"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:UnaryExpression">
                    <operators xsi:type="operators:Subtraction"/>
                    <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="j">
                  <typeReference xsi:type="types:Int">
                    <comments>// If there is a preceding non-&quot;..&quot; segment, remove both that</comments>
                    <comments>// segment and this occurrence of &quot;..&quot;; otherwise, leave this</comments>
                    <comments>// &quot;..&quot; segment as-is.</comments>
                  </typeReference>
                </variable>
              </statements>
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Break"/>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.1">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.3/@elseStatement/@statements.0/@variable"/>
                        </arraySelectors>
                      </children>
                      <children xsi:type="expressions:UnaryExpression">
                        <operators xsi:type="operators:Subtraction"/>
                        <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      </children>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.3/@elseStatement/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                </condition>
                <init xsi:type="expressions:ExpressionList">
                  <expressions xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.3/@elseStatement/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@init"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </value>
                  </expressions>
                </init>
                <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.3/@elseStatement/@statements.0/@variable"/>
                  <operator xsi:type="operators:MinusMinus"/>
                </updates>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:LocalVariableStatement">
                    <variable name="q">
                      <typeReference xsi:type="types:Int"/>
                      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.1">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.3/@elseStatement/@statements.0/@variable"/>
                        </arraySelectors>
                      </initialValue>
                    </variable>
                  </statements>
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.1">
                            <arraySelectors>
                              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@init"/>
                            </arraySelectors>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="expressions:UnaryExpression">
                            <operators xsi:type="operators:Subtraction"/>
                            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                          </value>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.1">
                            <arraySelectors>
                              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.3/@elseStatement/@statements.0/@variable"/>
                            </arraySelectors>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="expressions:UnaryExpression">
                            <operators xsi:type="operators:Subtraction"/>
                            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                          </value>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:UnaryExpression">
                      <operators xsi:type="operators:Negate"/>
                      <child xsi:type="expressions:NestedExpression">
                        <expression xsi:type="expressions:ConditionalAndExpression">
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:EqualityExpression">
                              <equalityOperators xsi:type="operators:Equal"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0">
                                <arraySelectors>
                                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.3/@elseStatement/@statements.2/@statement/@statements.0/@variable"/>
                                </arraySelectors>
                              </children>
                              <children xsi:type="literals:CharacterLiteral" value="46"/>
                            </expression>
                          </children>
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:EqualityExpression">
                              <equalityOperators xsi:type="operators:Equal"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0">
                                <arraySelectors>
                                  <position xsi:type="expressions:AdditiveExpression">
                                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.3/@elseStatement/@statements.2/@statement/@statements.0/@variable"/>
                                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                                    <additiveOperators xsi:type="operators:Addition"/>
                                  </position>
                                </arraySelectors>
                              </children>
                              <children xsi:type="literals:CharacterLiteral" value="46"/>
                            </expression>
                          </children>
                          <children xsi:type="expressions:NestedExpression">
                            <expression xsi:type="expressions:EqualityExpression">
                              <equalityOperators xsi:type="operators:Equal"/>
                              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@parameters.0">
                                <arraySelectors>
                                  <position xsi:type="expressions:AdditiveExpression">
                                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.3/@elseStatement/@statements.2/@statement/@statements.0/@variable"/>
                                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                                    <additiveOperators xsi:type="operators:Addition"/>
                                  </position>
                                </arraySelectors>
                              </children>
                              <children xsi:type="literals:CharacterLiteral"/>
                            </expression>
                          </children>
                        </expression>
                      </child>
                    </condition>
                  </statements>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@statement/@statements.3/@elseStatement/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                </condition>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.76/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="maybeAddLeadingDot">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="segs">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// DEVIATION: If the normalized path is relative, and if the first</comments>
        <comments>// segment could be parsed as a scheme name, then prepend a &quot;.&quot; segment</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// The path is absolute</comments>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.0">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </children>
          <children xsi:type="literals:CharacterLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ns">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.1">
            <next xsi:type="references:IdentifierReference"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="f">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <comments>// Index of first segment</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.1">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.2/@variable"/>
                </arraySelectors>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.2/@variable"/>
              <operator xsi:type="operators:PlusPlus"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// The path is empty, or else the original first segment survived,</comments>
          <comments>// in which case we already know that no leading &quot;.&quot; is needed</comments>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.1/@variable"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.2/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.1">
            <arraySelectors>
              <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.2/@variable"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:SuffixUnaryModificationExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.5/@variable"/>
            <operator xsi:type="operators:PlusPlus"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.5/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.0">
                <next xsi:type="references:IdentifierReference"/>
              </children>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.5/@variable"/>
                </arraySelectors>
              </children>
              <children xsi:type="literals:CharacterLiteral" value="58"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.5/@variable"/>
                </arraySelectors>
              </children>
              <children xsi:type="literals:CharacterLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <comments>// No colon in first segment, so no &quot;.&quot; needed</comments>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.5/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.0">
              <next xsi:type="references:IdentifierReference"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.0">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@statements.5/@variable"/>
              </arraySelectors>
            </children>
            <children xsi:type="literals:CharacterLiteral"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.0">
            <comments>// At this point we know that the first segment is unused,</comments>
            <comments>// hence we can insert a &quot;.&quot; segment at that position</comments>
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:CharacterLiteral" value="46"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.0">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:CharacterLiteral"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.77/@parameters.1">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="normalize">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ps">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Normalize the given path string.  A normal path string has no empty</comments>
        <comments>// segments (i.e., occurrences of &quot;//&quot;), no segments equal to &quot;.&quot;, and no</comments>
        <comments>// segments equal to &quot;..&quot; that are preceded by a segment not equal to &quot;..&quot;.</comments>
        <comments>// In contrast to Unix-style pathname normalization, for URI paths we</comments>
        <comments>// always retain trailing slashes.</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ns">
          <typeReference xsi:type="types:Int">
            <comments>// Does this path need normalization?</comments>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.73">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Number of segments</comments>
        <statement xsi:type="statements:Return">
          <comments>// Nope -- just return it</comments>
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="path">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.73"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="segs">
          <typeReference xsi:type="types:Int">
            <comments>// Path in char-array form</comments>
            <comments>// Split path into segments</comments>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Int"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.74">
          <comments>// Segment-index array</comments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.2/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.3/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.76">
          <comments>// Remove dots</comments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.2/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.3/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.77">
          <comments>// Prevent scheme-name confusion</comments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.2/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.3/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Join the remaining segments and return the result</comments>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.2/@variable"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.75">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.2/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.3/@variable"/>
            </arguments>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <comments>// string was already normalized</comments>
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@parameters.0"/>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.7/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@parameters.0"/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.78/@statements.7/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lowMask">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="chars">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// -- Character classes for parsing --</comments>
        <comments>// RFC2396 precisely specifies which characters in the US-ASCII charset are</comments>
        <comments>// permissible in the various components of a URI reference.  We here</comments>
        <comments>// define a set of mask pairs to aid in enforcing these restrictions.  Each</comments>
        <comments>// mask pair consists of two longs, a low mask and a high mask.  Taken</comments>
        <comments>// together they represent a 128-bit mask, where bit i is set iff the</comments>
        <comments>// character with value i is permitted.</comments>
        <comments>//</comments>
        <comments>// This approach is more efficient than sequentially searching arrays of</comments>
        <comments>// permitted characters.  It could be made still more efficient by</comments>
        <comments>// precompiling the mask information so that a character's presence in a</comments>
        <comments>// given mask could be determined by a single table lookup.</comments>
        <comments>// Compute the low-order mask for the characters in the given string</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="m">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="c">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@statements.2/@init"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:AssignmentOr"/>
                <value xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@statements.2/@statement/@statements.0/@variable"/>
                    <shiftOperators xsi:type="operators:LeftShift"/>
                  </expression>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@statements.2/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.79/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="highMask">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="chars">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Compute the high-order mask for the characters in the given string</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="m">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="c">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@statements.2/@init"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:AssignmentOr"/>
                <value xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@statements.2/@statement/@statements.0/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </expression>
                    </children>
                    <shiftOperators xsi:type="operators:LeftShift"/>
                  </expression>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@statements.2/@statement/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
                  <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@statements.2/@statement/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="128"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </expression>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@statements.2/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.80/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lowMask">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="first">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="last">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Compute a low-order mask for the characters</comments>
        <comments>// between first and last, inclusive</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="m">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="f">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.0"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="63"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
              </arguments>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="l">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@parameters.1"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="63"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
              </arguments>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:AssignmentOr"/>
            <value xsi:type="expressions:ShiftExpression">
              <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.3/@init"/>
              <shiftOperators xsi:type="operators:LeftShift"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.1/@variable"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.81/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="highMask">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="first">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="last">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Compute a high-order mask for the characters</comments>
        <comments>// between first and last, inclusive</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="m">
          <typeReference xsi:type="types:Long"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="f">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@parameters.0"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="127"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="l">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@parameters.1"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="127"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:AssignmentOr"/>
            <value xsi:type="expressions:ShiftExpression">
              <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.3/@init"/>
              <shiftOperators xsi:type="operators:LeftShift"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.1/@variable"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.82/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="match">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lowMask">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="highMask">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Tell whether the given character is permitted by the given mask pair</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.0"/>
                    <shiftOperators xsi:type="operators:LeftShift"/>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.1"/>
              </expression>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
                    <children xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.0"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="64"/>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </expression>
                    </children>
                    <shiftOperators xsi:type="operators:LeftShift"/>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.2"/>
              </expression>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.83/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="128"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:Field" name="L_DIGIT">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.81">
        <arguments xsi:type="literals:CharacterLiteral" value="48"/>
        <arguments xsi:type="literals:CharacterLiteral" value="57"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Character-class masks, in reverse order from RFC2396 because</comments>
        <comments>// initializers for static fields cannot make forward references.</comments>
        <comments>// digit    = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |</comments>
        <comments>//            &quot;8&quot; | &quot;9&quot;</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_DIGIT">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_UPALPHA">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// upalpha  = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot; | &quot;H&quot; | &quot;I&quot; |</comments>
        <comments>//            &quot;J&quot; | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot; | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; |</comments>
        <comments>//            &quot;S&quot; | &quot;T&quot; | &quot;U&quot; | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot;</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_UPALPHA">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
        <arguments xsi:type="literals:CharacterLiteral" value="65"/>
        <arguments xsi:type="literals:CharacterLiteral" value="90"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_LOWALPHA">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// lowalpha = &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; |</comments>
        <comments>//            &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; |</comments>
        <comments>//            &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_LOWALPHA">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
        <arguments xsi:type="literals:CharacterLiteral" value="97"/>
        <arguments xsi:type="literals:CharacterLiteral" value="122"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_ALPHA">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.88"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.86"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// alpha         = lowalpha | upalpha</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_ALPHA">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.89"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.87"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_ALPHANUM">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// alphanum      = alpha | digit</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_ALPHANUM">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_HEX">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// hex           = digit | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; |</comments>
        <comments>//                         &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_HEX">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
          <arguments xsi:type="literals:CharacterLiteral" value="65"/>
          <arguments xsi:type="literals:CharacterLiteral" value="70"/>
        </children>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.82">
          <arguments xsi:type="literals:CharacterLiteral" value="97"/>
          <arguments xsi:type="literals:CharacterLiteral" value="102"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_MARK">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
        <arguments xsi:type="references:StringReference" value="-_.!~*'()"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// mark          = &quot;-&quot; | &quot;_&quot; | &quot;.&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot; | &quot;'&quot; |</comments>
        <comments>//                 &quot;(&quot; | &quot;)&quot;</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_MARK">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
        <arguments xsi:type="references:StringReference" value="-_.!~*'()"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_UNRESERVED">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.96"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// unreserved    = alphanum | mark</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_UNRESERVED">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.97"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_RESERVED">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
        <arguments xsi:type="references:StringReference" value=";/?:@&amp;=+$,[]"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// reserved      = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; |</comments>
        <comments>//                 &quot;$&quot; | &quot;,&quot; | &quot;[&quot; | &quot;]&quot;</comments>
        <comments>// Added per RFC2732: &quot;[&quot;, &quot;]&quot;</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_RESERVED">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
        <arguments xsi:type="references:StringReference" value=";/?:@&amp;=+$,[]"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_ESCAPED">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// The zero'th bit is used to indicate that escape pairs and non-US-ASCII</comments>
        <comments>// characters are allowed; this is handled by the scanEscape method below.</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_ESCAPED">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_URIC">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.100"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// uric          = reserved | unreserved | escaped</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_URIC">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.101"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_PCHAR">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
          <arguments xsi:type="references:StringReference" value=":@&amp;=+$,"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// pchar         = unreserved | escaped |</comments>
        <comments>//                 &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_PCHAR">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
          <arguments xsi:type="references:StringReference" value=":@&amp;=+$,"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_PATH">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.106"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
          <arguments xsi:type="references:StringReference" value=";/"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// All valid path characters</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_PATH">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.107"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
          <arguments xsi:type="references:StringReference" value=";/"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_DASH">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
        <arguments xsi:type="references:StringReference" value="-"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Dash, for use in domainlabel and toplabel</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_DASH">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
        <arguments xsi:type="references:StringReference" value="-"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_DOT">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
        <arguments xsi:type="references:StringReference" value="."/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Dot, for use in hostnames</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_DOT">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
        <arguments xsi:type="references:StringReference" value="."/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_USERINFO">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
          <arguments xsi:type="references:StringReference" value=";:&amp;=+$,"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// userinfo      = *( unreserved | escaped |</comments>
        <comments>//                    &quot;;&quot; | &quot;:&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot; )</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_USERINFO">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
          <arguments xsi:type="references:StringReference" value=";:&amp;=+$,"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_REG_NAME">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
          <arguments xsi:type="references:StringReference" value="$,;:@&amp;=+"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// reg_name      = 1*( unreserved | escaped | &quot;$&quot; | &quot;,&quot; |</comments>
        <comments>//                     &quot;;&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; )</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_REG_NAME">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
          <arguments xsi:type="references:StringReference" value="$,;:@&amp;=+"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_SERVER">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
          <arguments xsi:type="references:StringReference" value=".:@[]"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// All valid characters for server-based authorities</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_SERVER">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.111"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
          <arguments xsi:type="references:StringReference" value=".:@[]"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_SERVER_PERCENT">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.118"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
          <arguments xsi:type="references:StringReference" value="%"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Special case of server authority that represents an IPv6 address</comments>
        <comments>// In this case, a % does not signify an escape sequence</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_SERVER_PERCENT">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
          <arguments xsi:type="references:StringReference" value="%"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_LEFT_BRACKET">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
        <arguments xsi:type="references:StringReference" value="["/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_LEFT_BRACKET">
      <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
        <arguments xsi:type="references:StringReference" value="["/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_SCHEME">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
          <arguments xsi:type="references:StringReference" value="+-."/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// scheme        = alpha *( alpha | digit | &quot;+&quot; | &quot;-&quot; | &quot;.&quot; )</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_SCHEME">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
          <arguments xsi:type="references:StringReference" value="+-."/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="L_URIC_NO_SLASH">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.98"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.79">
          <arguments xsi:type="references:StringReference" value=";?:@&amp;=+$,"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// uric_no_slash = unreserved | escaped | &quot;;&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; |</comments>
        <comments>//                 &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="H_URIC_NO_SLASH">
      <initialValue xsi:type="expressions:InclusiveOrExpression">
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.99"/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.103"/>
        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.80">
          <arguments xsi:type="references:StringReference" value=";?:@&amp;=+$,"/>
        </children>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="hexDigits">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <initialValues xsi:type="literals:CharacterLiteral" value="48"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="49"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="50"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="51"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="52"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="53"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="54"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="55"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="56"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="57"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="65"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="66"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="67"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="68"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="69"/>
          <initialValues xsi:type="literals:CharacterLiteral" value="70"/>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:Char"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// -- Escaping and encoding --</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="appendEscape">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sb">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.129/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
            <arguments xsi:type="literals:CharacterLiteral" value="37"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.129/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128">
              <arraySelectors>
                <position xsi:type="expressions:AndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:ShiftExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.129/@parameters.1"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
                      <shiftOperators xsi:type="operators:RightShift"/>
                    </expression>
                  </children>
                  <children xsi:type="literals:HexIntegerLiteral" hexValue="15"/>
                </position>
              </arraySelectors>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.129/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.128">
              <arraySelectors>
                <position xsi:type="expressions:AndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:ShiftExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.129/@parameters.1"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                      <shiftOperators xsi:type="operators:RightShift"/>
                    </expression>
                  </children>
                  <children xsi:type="literals:HexIntegerLiteral" hexValue="15"/>
                </position>
              </arraySelectors>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="appendEncoded">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sb">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../nio/ByteBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../nio/charset/CharsetEncoder.class.xmi#//@classifiers.0/@members.35"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../nio/CharBuffer.class.xmi#//@classifiers.0/@members.10"/>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:StringReference" value=""/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.1"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </arguments>
                    </next>
                    <target xsi:type="classifiers:Class" href="../nio/CharBuffer.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
                <target xsi:type="members:ClassMethod" href="../../sun/nio/cs/ThreadLocalCoders.class.xmi#//@classifiers.0/@members.5"/>
                <arguments xsi:type="references:StringReference" value="UTF-8"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/nio/cs/ThreadLocalCoders.class.xmi#//@classifiers.0"/>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Assert">
            <condition xsi:type="literals:BooleanLiteral"/>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../nio/charset/CharacterCodingException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="b">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../nio/ByteBuffer.class.xmi#//@classifiers.0/@members.14"/>
                  </next>
                </children>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.129">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0"/>
                <arguments xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Byte"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.2/@statement/@statements.0/@variable"/>
                </arguments>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.2/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:HexIntegerLiteral" hexValue="128"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
            <elseStatement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                  <arguments xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Char"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.2/@statement/@statements.0/@variable"/>
                  </arguments>
                </next>
              </expression>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.130/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../nio/Buffer.class.xmi#//@classifiers.0/@members.17"/>
          </next>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="quote">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lowMask">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="highMask">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Quote any characters in s that are not permitted</comments>
        <comments>// by the given mask pair</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="allowNonASCII">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AndExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.1"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102"/>
                </expression>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="c">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@init"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:Block">
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable"/>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="instantiations:NewConstructorCall">
                            <typeReference xsi:type="types:NamespaceClassifierReference">
                              <classifierReferences>
                                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
                              </classifierReferences>
                            </typeReference>
                          </value>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.0">
                              <next xsi:type="references:MethodCall">
                                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.56"/>
                                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@init"/>
                              </next>
                            </arguments>
                          </next>
                        </expression>
                      </statements>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:Equal"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable"/>
                      <children xsi:type="literals:NullLiteral"/>
                    </condition>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.129">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable"/>
                      <arguments xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Byte"/>
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@statement/@statements.0/@variable"/>
                      </arguments>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Negate"/>
                  <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.83">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@statement/@statements.0/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.1"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.2"/>
                  </child>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <statements xsi:type="statements:Condition">
                    <statement xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@statement/@statements.0/@variable"/>
                        </next>
                      </expression>
                    </statement>
                    <condition xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable"/>
                      <children xsi:type="literals:NullLiteral"/>
                    </condition>
                  </statements>
                </elseStatement>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:CharacterLiteral" value="92"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <elseStatement xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="instantiations:NewConstructorCall">
                          <typeReference xsi:type="types:NamespaceClassifierReference">
                            <classifierReferences>
                              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
                            </classifierReferences>
                          </typeReference>
                        </value>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.0">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.56"/>
                              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@init"/>
                            </next>
                          </arguments>
                        </next>
                      </expression>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable"/>
                    <children xsi:type="literals:NullLiteral"/>
                  </condition>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.130">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@statement/@statements.0/@variable"/>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.2/@variable"/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ConditionalOrExpression">
                    <children xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.139"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@statement/@statements.0/@variable"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
                    </children>
                    <children xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.143"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@statement/@statements.0/@variable"/>
                      </next>
                      <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
                    </children>
                  </expression>
                </children>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@statement/@statements.0/@variable"/>
                      </next>
                    </expression>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable"/>
                    <children xsi:type="literals:NullLiteral"/>
                  </condition>
                </statements>
              </elseStatement>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </child>
          <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@parameters.0"/>
          <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.131/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
            </next>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="encode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Encodes all characters >= \u0080 into escaped, normalized UTF-8 octets,</comments>
        <comments>// assuming that s is otherwise legal</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <comments>// First check whether we actually need to encode</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.2/@init"/>
                </next>
              </children>
              <children xsi:type="literals:CharacterLiteral" value="92"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="expressions:PrefixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.2/@init"/>
                <operator xsi:type="operators:PlusPlus"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.0/@variable"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
          </statements>
        </statement>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ns">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0/@members.31"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0/@members.14"/>
                </next>
                <target xsi:type="classifiers:Class" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0"/>
              </arguments>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../sun/text/Normalizer.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../nio/ByteBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.4/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../nio/charset/CharsetEncoder.class.xmi#//@classifiers.0/@members.35"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../nio/CharBuffer.class.xmi#//@classifiers.0/@members.10"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.3/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../nio/CharBuffer.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
                <target xsi:type="members:ClassMethod" href="../../sun/nio/cs/ThreadLocalCoders.class.xmi#//@classifiers.0/@members.5"/>
                <arguments xsi:type="references:StringReference" value="UTF-8"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../sun/nio/cs/ThreadLocalCoders.class.xmi#//@classifiers.0"/>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Assert">
            <condition xsi:type="literals:BooleanLiteral"/>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../nio/charset/CharacterCodingException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="b">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.4/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../nio/ByteBuffer.class.xmi#//@classifiers.0/@members.14"/>
                  </next>
                </children>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.129">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.6/@variable"/>
                <arguments xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:Byte"/>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.7/@statement/@statements.0/@variable"/>
                </arguments>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.7/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:HexIntegerLiteral" hexValue="128"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </condition>
            <elseStatement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.6/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                  <arguments xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:Char"/>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.7/@statement/@statements.0/@variable"/>
                  </arguments>
                </next>
              </expression>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.4/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../nio/Buffer.class.xmi#//@classifiers.0/@members.17"/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.132/@statements.6/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="decode">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.133/@parameters.0"/>
            <children xsi:type="literals:CharacterLiteral" value="48"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.133/@parameters.0"/>
              <children xsi:type="literals:CharacterLiteral" value="48"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.133/@parameters.0"/>
              <children xsi:type="literals:CharacterLiteral" value="57"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.133/@parameters.0"/>
            <children xsi:type="literals:CharacterLiteral" value="97"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.133/@parameters.0"/>
              <children xsi:type="literals:CharacterLiteral" value="97"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.133/@parameters.0"/>
              <children xsi:type="literals:CharacterLiteral" value="102"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.133/@parameters.0"/>
            <children xsi:type="literals:CharacterLiteral" value="65"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.133/@parameters.0"/>
              <children xsi:type="literals:CharacterLiteral" value="65"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.133/@parameters.0"/>
              <children xsi:type="literals:CharacterLiteral" value="70"/>
              <relationOperators xsi:type="operators:LessThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Assert">
        <condition xsi:type="literals:BooleanLiteral"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="decode">
      <typeReference xsi:type="types:Byte"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c1">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c2">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Byte"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InclusiveOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AndExpression">
                      <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.133">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.0"/>
                      </children>
                      <children xsi:type="literals:HexIntegerLiteral" hexValue="15"/>
                    </expression>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AndExpression">
                      <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.133">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.134/@parameters.1"/>
                      </children>
                      <children xsi:type="literals:HexIntegerLiteral" hexValue="15"/>
                    </expression>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </expression>
              </children>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="decode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Evaluates all escapes in s, applying UTF-8 decoding if needed.  Assumes</comments>
        <comments>// that escapes are well-formed syntactically, i.e., of the form %XX.  If a</comments>
        <comments>// sequence of escaped octets is not valid UTF-8 then the erroneous octets</comments>
        <comments>// are replaced with '\uFFFD'.</comments>
        <comments>// Exception: any &quot;%&quot; found between &quot;[]&quot; is left alone. It is an IPv6 literal</comments>
        <comments>//            with a scope_id</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.1/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0"/>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.45"/>
              <arguments xsi:type="literals:CharacterLiteral" value="37"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ba">
          <typeReference xsi:type="types:Byte"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Byte"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.1/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.1/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../nio/ByteBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../nio/ByteBuffer.class.xmi#//@classifiers.0/@members.8"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.1/@variable"/>
            </next>
            <target xsi:type="classifiers:Class" href="../nio/ByteBuffer.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../nio/CharBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../nio/CharBuffer.class.xmi#//@classifiers.0/@members.5"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.1/@variable"/>
            </next>
            <target xsi:type="classifiers:Class" href="../nio/CharBuffer.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dec">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../nio/charset/CharsetDecoder.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../nio/charset/CharsetDecoder.class.xmi#//@classifiers.0/@members.23"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="../nio/charset/CodingErrorAction.class.xmi#//@classifiers.0/@members.2"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../nio/charset/CodingErrorAction.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
                <target xsi:type="members:ClassMethod" href="../nio/charset/CharsetDecoder.class.xmi#//@classifiers.0/@members.20"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="../nio/charset/CodingErrorAction.class.xmi#//@classifiers.0/@members.2"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../nio/charset/CodingErrorAction.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
              <target xsi:type="members:ClassMethod" href="../../sun/nio/cs/ThreadLocalCoders.class.xmi#//@classifiers.0/@members.4"/>
              <arguments xsi:type="references:StringReference" value="UTF-8"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../sun/nio/cs/ThreadLocalCoders.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:Char">
            <comments>// This is not horribly efficient, but it will do for now</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="betweenBrackets">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Assert">
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.9/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@init"/>
                </next>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>// Loop invariant</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.10/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:BooleanLiteral" value="true"/>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.9/@variable"/>
              <children xsi:type="literals:CharacterLiteral" value="91"/>
            </condition>
            <elseStatement xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.10/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="literals:BooleanLiteral"/>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.10/@variable"/>
                <children xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.9/@variable"/>
                  <children xsi:type="literals:CharacterLiteral" value="93"/>
                </children>
              </condition>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.5/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.9/@variable"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Break"/>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="expressions:PrefixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@init"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.1/@variable"/>
                  <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.9/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@init"/>
                    </next>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Continue"/>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.9/@variable"/>
                <children xsi:type="literals:CharacterLiteral" value="37"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.10/@variable"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.6/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../nio/Buffer.class.xmi#//@classifiers.0/@members.13"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="ui">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@init"/>
            </variable>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Assert">
                <condition xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:RelationExpression">
                    <children xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.1/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@init"/>
                      <additiveOperators xsi:type="operators:Subtraction"/>
                    </children>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                    <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                  </expression>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.6/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../nio/ByteBuffer.class.xmi#//@classifiers.0/@members.15"/>
                    <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.134">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                          <arguments xsi:type="expressions:PrefixUnaryModificationExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@init"/>
                            <operator xsi:type="operators:PlusPlus"/>
                          </arguments>
                        </next>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                          <arguments xsi:type="expressions:PrefixUnaryModificationExpression">
                            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@init"/>
                            <operator xsi:type="operators:PlusPlus"/>
                          </arguments>
                        </next>
                      </arguments>
                    </arguments>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Break"/>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="expressions:PrefixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@init"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.1/@variable"/>
                  <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.9/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@init"/>
                    </next>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Break"/>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.9/@variable"/>
                  <children xsi:type="literals:CharacterLiteral" value="37"/>
                </condition>
              </statements>
            </statement>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.6/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../nio/Buffer.class.xmi#//@classifiers.0/@members.14"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.7/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../nio/Buffer.class.xmi#//@classifiers.0/@members.13"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.8/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../nio/charset/CharsetDecoder.class.xmi#//@classifiers.0/@members.30"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="cr">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../nio/charset/CoderResult.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.8/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../nio/charset/CharsetDecoder.class.xmi#//@classifiers.0/@members.27"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.6/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.7/@variable"/>
                  <arguments xsi:type="literals:BooleanLiteral" value="true"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Assert">
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@statement/@statements.9/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../nio/charset/CoderResult.class.xmi#//@classifiers.0/@members.15"/>
              </next>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@statement/@statements.9/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.8/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../nio/charset/CharsetDecoder.class.xmi#//@classifiers.0/@members.28"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.7/@variable"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Assert">
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@statement/@statements.9/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../nio/charset/CoderResult.class.xmi#//@classifiers.0/@members.15"/>
              </next>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.5/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.7/@variable">
                  <next xsi:type="references:MethodCall">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.6"/>
                    </next>
                    <target xsi:type="members:ClassMethod" href="../nio/Buffer.class.xmi#//@classifiers.0/@members.14"/>
                  </next>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.11/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.135/@statements.5/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="classifiers:Class" name="Parser">
      <members xsi:type="members:Field" name="input">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:Field" name="requireServerAuthority">
        <initialValue xsi:type="literals:BooleanLiteral"/>
        <typeReference xsi:type="types:Boolean"/>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// URI input string</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:Constructor" name="Parser">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.2/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.2/@parameters.0"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
      </members>
      <members xsi:type="members:ClassMethod" name="fail">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="reason">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// -- Methods for throwing URISyntaxException in various ways --</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.3/@parameters.0"/>
          </throwable>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="fail">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="reason">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="p">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <statements xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.4/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.4/@parameters.1"/>
          </throwable>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="failExpecting">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="expected">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="p">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Expected "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.5/@parameters.0"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.5/@parameters.1"/>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="failExpecting">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="expected">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="prior">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="p">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Expected "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.6/@parameters.0"/>
              <children xsi:type="references:StringReference" value=" following "/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.6/@parameters.1"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.6/@parameters.2"/>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="substring">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="end">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// -- Simple access to the input string --</comments>
          <comments>// Return a substring of the input string</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.56"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.7/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.7/@parameters.1"/>
            </next>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="charAt">
        <typeReference xsi:type="types:Char"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="p">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Return the char at position p,</comments>
          <comments>// assuming that p &lt; input.length()</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.8/@parameters.0"/>
            </next>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="at">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="end">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="c">
          <typeReference xsi:type="types:Char"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Tells whether start &lt; end and, if so, whether charAt(start) == c</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.9/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.9/@parameters.1"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.8">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.9/@parameters.0"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.9/@parameters.2"/>
              </expression>
            </children>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="at">
        <typeReference xsi:type="types:Boolean"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="end">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Tells whether start + s.length() &lt; end and, if so,</comments>
          <comments>// whether the chars at the start position match s exactly</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="sn">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@parameters.2">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
              </next>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@statements.1/@variable"/>
            <children xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@statements.0/@variable"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="i">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Break"/>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.8">
                  <arguments xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@statements.0/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </arguments>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@parameters.2">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@statements.3/@variable"/>
                  </next>
                </children>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@statements.3/@variable"/>
                <operator xsi:type="operators:PlusPlus"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@statements.3/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@statements.1/@variable"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@statements.3/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.10/@statements.1/@variable"/>
            </expression>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="scan">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="end">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="c">
          <typeReference xsi:type="types:Char"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// -- Scanning --</comments>
          <comments>// The various scan and parse methods that follow use a uniform</comments>
          <comments>// convention of taking the current start position and end index as</comments>
          <comments>// their first two arguments.  The start is inclusive while the end is</comments>
          <comments>// exclusive, just as in the String class, i.e., a start/end pair</comments>
          <comments>// denotes the left-open interval [start, end) of the input string.</comments>
          <comments>//</comments>
          <comments>// These methods never proceed past the end position.  They may return</comments>
          <comments>// -1 to indicate outright failure, but more often they simply return</comments>
          <comments>// the position of the first char after the last char scanned.  Thus</comments>
          <comments>// a typical idiom is</comments>
          <comments>//</comments>
          <comments>//     int p = start;</comments>
          <comments>//     int q = scan(p, end, ...);</comments>
          <comments>//     if (q > p)</comments>
          <comments>//         // We scanned something</comments>
          <comments>//         ...;</comments>
          <comments>//     else if (q == p)</comments>
          <comments>//         // We scanned nothing</comments>
          <comments>//         ...;</comments>
          <comments>//     else if (q == -1)</comments>
          <comments>//         // Something went wrong</comments>
          <comments>//         ...;</comments>
          <comments>// Scan a specific char: If the char at the given start position is</comments>
          <comments>// equal to c, return the index of the next char; otherwise, return the</comments>
          <comments>// start position.</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.11/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </returnValue>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.11/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.11/@parameters.1"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.8">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.11/@parameters.0"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.11/@parameters.2"/>
              </expression>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.11/@parameters.0"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="scan">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="end">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="err">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="stop">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Scan forward from the given start position.  Stop at the first char</comments>
          <comments>// in the err string (in which case -1 is returned), or the first char</comments>
          <comments>// in the stop string (in which case the index of the preceding char is</comments>
          <comments>// returned), or the end of the input string (in which case the length</comments>
          <comments>// of the input string is returned).  May return the start position if</comments>
          <comments>// nothing matches.</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.12/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="c">
                <typeReference xsi:type="types:Char"/>
                <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.8">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.12/@statements.0/@variable"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Return">
                <returnValue xsi:type="expressions:UnaryExpression">
                  <operators xsi:type="operators:Subtraction"/>
                  <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                </returnValue>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.12/@parameters.2">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.45"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.12/@statements.1/@statement/@statements.0/@variable"/>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.12/@parameters.3">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.45"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.12/@statements.1/@statement/@statements.0/@variable"/>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.12/@statements.0/@variable"/>
                <operator xsi:type="operators:PlusPlus"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.12/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.12/@parameters.1"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.12/@statements.0/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="scanEscape">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="first">
          <typeReference xsi:type="types:Char"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Scan a potential escape sequence, starting at the given position,</comments>
          <comments>// with the given first char (i.e., charAt(start) == c).</comments>
          <comments>//</comments>
          <comments>// This method assumes that if escapes are allowed then visible</comments>
          <comments>// non-US-ASCII chars are also allowed.</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="c">
            <typeReference xsi:type="types:Char"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@parameters.2"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <comments>// Process escape pair</comments>
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@statements.0/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </returnValue>
                </statements>
              </statement>
              <condition xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:RelationExpression">
                    <children xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@statements.0/@variable"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@parameters.1"/>
                    <relationOperators xsi:type="operators:LessThanOrEqual"/>
                  </expression>
                </children>
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.83">
                  <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.8">
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@statements.0/@variable"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95"/>
                </children>
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.83">
                  <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.8">
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@statements.0/@variable"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95"/>
                </children>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
                <arguments xsi:type="references:StringReference" value="Malformed escape pair"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@statements.0/@variable"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@statements.1/@variable"/>
            <children xsi:type="literals:CharacterLiteral" value="37"/>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <comments>// Allow unescaped but visible non-US-ASCII chars</comments>
                <returnValue xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </returnValue>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@statements.1/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="128"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </expression>
              </children>
              <children xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Negate"/>
                <child xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.139"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@statements.1/@variable"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
                </child>
              </children>
              <children xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Negate"/>
                <child xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/Character.class.xmi#//@classifiers.0/@members.143"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@statements.1/@variable"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../lang/Character.class.xmi#//@classifiers.0"/>
                </child>
              </children>
            </condition>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.13/@statements.0/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="scan">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="lowMask">
          <typeReference xsi:type="types:Long"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="highMask">
          <typeReference xsi:type="types:Long"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Scan chars that match the given mask pair</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="c">
                <typeReference xsi:type="types:Char"/>
                <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.8">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@statements.0/@variable"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@statements.0/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:Continue"/>
              </statement>
              <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.83">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@statements.1/@statement/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@parameters.2"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@parameters.3"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="q">
                    <typeReference xsi:type="types:Int"/>
                    <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.13">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@parameters.1"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@statements.1/@statement/@statements.0/@variable"/>
                    </initialValue>
                  </variable>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@statements.0/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@statements.1/@statement/@statements.2/@statement/@statements.0/@variable"/>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:Continue"/>
                  </statement>
                  <condition xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@statements.1/@statement/@statements.2/@statement/@statements.0/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@statements.0/@variable"/>
                    <relationOperators xsi:type="operators:GreaterThan"/>
                  </condition>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AndExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@parameters.2"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.102"/>
                  </expression>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Break"/>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@parameters.1"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.14/@statements.0/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="checkChars">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="end">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="lowMask">
          <typeReference xsi:type="types:Long"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="highMask">
          <typeReference xsi:type="types:Long"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="what">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Check that each of the chars in [start, end) matches the given mask</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.14">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.15/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.15/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.15/@parameters.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.15/@parameters.3"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Illegal character in "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.15/@parameters.4"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.15/@statements.0/@variable"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.15/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.15/@parameters.1"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="checkChar">
        <typeReference xsi:type="types:Void"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="p">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="lowMask">
          <typeReference xsi:type="types:Long"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="highMask">
          <typeReference xsi:type="types:Long"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="what">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Check that the char at position p matches the given mask</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.15">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.16/@parameters.0"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.16/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.16/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.16/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.16/@parameters.3"/>
          </expression>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="parse">
        <typeReference xsi:type="types:Void">
          <comments>// -- Parsing --</comments>
          <comments>// [&lt;scheme>:]&lt;scheme-specific-part>[#&lt;fragment>]</comments>
          <comments>//</comments>
        </typeReference>
        <parameters xsi:type="parameters:OrdinaryParameter" name="rsa">
          <typeReference xsi:type="types:Boolean"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="ssp">
            <typeReference xsi:type="types:Int"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="n">
            <typeReference xsi:type="types:Int">
              <comments>// Start of scheme-specific part</comments>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
              </next>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.12">
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.2/@variable"/>
              <arguments xsi:type="references:StringReference" value="/?#"/>
              <arguments xsi:type="references:StringReference" value=":"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.5">
                  <arguments xsi:type="references:StringReference" value="scheme name"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </expression>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.16">
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91"/>
                <arguments xsi:type="references:StringReference" value="scheme name"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.15">
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.124"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.125"/>
                <arguments xsi:type="references:StringReference" value="scheme name"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                <operator xsi:type="operators:PlusPlus"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.1/@variable">
                  <comments>// Skip ':'</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.18">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.2/@variable"/>
                    </value>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.2/@variable"/>
                <arguments xsi:type="literals:CharacterLiteral" value="47"/>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="q">
                    <typeReference xsi:type="types:Int"/>
                    <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.12">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.2/@variable"/>
                      <arguments xsi:type="references:StringReference" value=""/>
                      <arguments xsi:type="references:StringReference" value="#"/>
                    </initialValue>
                  </variable>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.5">
                      <arguments xsi:type="references:StringReference" value="scheme-specific part"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                    </expression>
                  </statement>
                  <condition xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.4/@statement/@statements.6/@elseStatement/@statements.0/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                    <relationOperators xsi:type="operators:LessThanOrEqual"/>
                  </condition>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.15">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.4/@statement/@statements.6/@elseStatement/@statements.0/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105"/>
                    <arguments xsi:type="references:StringReference" value="opaque part"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.4/@statement/@statements.6/@elseStatement/@statements.0/@variable"/>
                  </expression>
                </statements>
              </elseStatement>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </expression>
            </children>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.2/@variable"/>
              <arguments xsi:type="literals:CharacterLiteral" value="58"/>
            </children>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.18">
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.2/@variable"/>
                </value>
              </expression>
            </statements>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.1/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.15">
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.2/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105"/>
                <arguments xsi:type="references:StringReference" value="fragment"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.2/@variable"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.2/@variable"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.2/@variable"/>
            <arguments xsi:type="literals:CharacterLiteral" value="35"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
              <arguments xsi:type="references:StringReference" value="end of URI"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.3/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.17/@statements.2/@variable"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="parseHierarchical">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// [//authority]&lt;path>[?&lt;query>]</comments>
          <comments>//</comments>
          <comments>// DEVIATION from RFC2396: We allow an empty authority component as</comments>
          <comments>// long as it's followed by a non-empty path, query component, or</comments>
          <comments>// fragment component.  This is so that URIs such as &quot;file:///foo/bar&quot;</comments>
          <comments>// will parse.  This seems to be the intent of RFC2396, though the</comments>
          <comments>// grammar does not permit it.  If the authority is empty then the</comments>
          <comments>// userInfo, host, and port components are undefined.</comments>
          <comments>//</comments>
          <comments>// DEVIATION from RFC2396: We allow empty relative paths.  This seems</comments>
          <comments>// to be the intent of RFC2396, but the grammar does not permit it.</comments>
          <comments>// The primary consequence of this deviation is that &quot;#f&quot; parses as a</comments>
          <comments>// relative URI with an empty path.</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </expression>
            </statements>
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="q">
                <typeReference xsi:type="types:Int"/>
                <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.12">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@parameters.1"/>
                  <arguments xsi:type="references:StringReference" value=""/>
                  <arguments xsi:type="references:StringReference" value="/?#"/>
                </initialValue>
              </variable>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.19">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.1/@statement/@statements.1/@variable"/>
                    </value>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.1/@statement/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </condition>
              <elseStatement xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <comments>// DEVIATION: Allow empty authority prior to non-empty </comments>
                  <comments>// path, query component or fragment identifier</comments>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.1/@statement/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@parameters.1"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
                <elseStatement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.5">
                    <arguments xsi:type="references:StringReference" value="authority"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                  </expression>
                </elseStatement>
              </elseStatement>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@parameters.1"/>
              <arguments xsi:type="literals:CharacterLiteral" value="47"/>
            </children>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@parameters.1"/>
              <arguments xsi:type="literals:CharacterLiteral" value="47"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="q">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@parameters.1"/>
              <arguments xsi:type="references:StringReference" value=""/>
              <arguments xsi:type="references:StringReference" value="?#"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.15">
            <comments>// DEVIATION: May be empty</comments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.108"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.109"/>
            <arguments xsi:type="references:StringReference" value="path"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.2/@variable"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.2/@variable"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                <operator xsi:type="operators:PlusPlus"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.2/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.12">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@parameters.1"/>
                  <arguments xsi:type="references:StringReference" value=""/>
                  <arguments xsi:type="references:StringReference" value="#"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.15">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.2/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.104"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.105"/>
                <arguments xsi:type="references:StringReference" value="query"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.2/@variable"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.2/@variable"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@parameters.1"/>
            <arguments xsi:type="literals:CharacterLiteral" value="63"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.18/@statements.0/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="parseAuthority">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// authority     = server | reg_name</comments>
          <comments>//</comments>
          <comments>// Ambiguity: An authority that is a registry name rather than a server</comments>
          <comments>// might have a prefix that parses as a server.  We use the fact that</comments>
          <comments>// the authority component is always followed by '/' or the end of the</comments>
          <comments>// input string to resolve this: If the complete authority did not</comments>
          <comments>// parse as a server then we try to parse it as a registry name.</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="q">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.0/@variable"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="ex">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="literals:NullLiteral"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="serverChars">
            <typeReference xsi:type="types:Boolean"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="regChars">
            <typeReference xsi:type="types:Boolean"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.3/@variable">
                  <comments>// contains a literal IPv6 address, therefore % is allowed</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.14">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.120"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.121"/>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
                  </expression>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
              <arguments xsi:type="references:StringReference" value=""/>
              <arguments xsi:type="references:StringReference" value="]"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.0/@variable"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.3/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.14">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.118"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.119"/>
                    </children>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
                  </expression>
                </value>
              </expression>
            </statements>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.4/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.14">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.116"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.117"/>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
              </expression>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
                  <comments>// Must be a registry-based authority</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.4/@variable"/>
            <children xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.3/@variable"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:TryBlock">
              <comments>// Might be (probably is) a server-based authority, so attempt</comments>
              <comments>// to parse it as such.  If the attempt fails, try to treat it</comments>
              <comments>// as a registry-based authority.</comments>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.20">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.0/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.5">
                    <arguments xsi:type="references:StringReference" value="end of authority"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.1/@variable"/>
                  </expression>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.0/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
                  </value>
                </expression>
              </statements>
              <catcheBlocks>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
                      <comments>// Undo results of failed parse</comments>
                    </child>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="literals:NullLiteral"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="literals:NullLiteral"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="expressions:UnaryExpression">
                      <operators xsi:type="operators:Subtraction"/>
                      <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:Throw">
                      <comments>// If we're insisting upon a server-based authority,</comments>
                      <comments>// then just re-throw the exception</comments>
                      <throwable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.8/@statement/@statements.0/@catcheBlocks.0/@parameter"/>
                    </statements>
                  </statement>
                  <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.1"/>
                  <elseStatement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.2/@variable">
                          <comments>// Save the exception in case it doesn't parse as a</comments>
                          <comments>// registry either</comments>
                        </child>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.8/@statement/@statements.0/@catcheBlocks.0/@parameter"/>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.1/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.0/@variable"/>
                      </expression>
                    </statements>
                  </elseStatement>
                </statements>
                <parameter name="x">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </parameter>
              </catcheBlocks>
            </statements>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.3/@variable"/>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
                      <comments>// Registry-based authority</comments>
                    </child>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
                    </value>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.4/@variable"/>
              <elseStatement xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:Throw">
                    <comments>// Re-throw exception; it was probably due to</comments>
                    <comments>// a malformed IPv6 address</comments>
                    <throwable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.2/@variable"/>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.2/@variable"/>
                  <children xsi:type="literals:NullLiteral"/>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
                      <arguments xsi:type="references:StringReference" value="Illegal character in authority"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.1/@variable"/>
                    </expression>
                  </statements>
                </elseStatement>
              </elseStatement>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@statements.1/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.19/@parameters.1"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="parseServer">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// [&lt;userinfo>@]&lt;host>[:&lt;port>]</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="q">
            <typeReference xsi:type="types:Int"/>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable">
              <comments>// userinfo</comments>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@parameters.1"/>
              <arguments xsi:type="references:StringReference" value="/?#"/>
              <arguments xsi:type="references:StringReference" value="@"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <comments>// Skip '@'</comments>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.15">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.114"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.115"/>
                <arguments xsi:type="references:StringReference" value="user info"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
              </expression>
            </children>
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@parameters.1"/>
              <arguments xsi:type="literals:CharacterLiteral" value="64"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <comments>// hostname, IPv4 address, or IPv6 address</comments>
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable">
                  <comments>// DEVIATION from RFC2396: Support IPv6 addresses, per RFC2732</comments>
                </child>
                <operator xsi:type="operators:PlusPlus"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.12">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@parameters.1"/>
                  <arguments xsi:type="references:StringReference" value="/?#"/>
                  <arguments xsi:type="references:StringReference" value="]"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:LocalVariableStatement">
                  <variable name="r">
                    <typeReference xsi:type="types:Int">
                      <comments>// look for a &quot;%&quot; scope id</comments>
                    </typeReference>
                    <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.12">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                      <arguments xsi:type="references:StringReference" value=""/>
                      <arguments xsi:type="references:StringReference" value="%"/>
                    </initialValue>
                  </variable>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.27">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.4/@statement/@statements.2/@statement/@statements.0/@variable"/>
                      </expression>
                    </statements>
                    <statements xsi:type="statements:Condition">
                      <statement xsi:type="statements:Block">
                        <statements xsi:type="statements:ExpressionStatement">
                          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.3">
                            <arguments xsi:type="references:StringReference" value="scope id expected"/>
                          </expression>
                        </statements>
                      </statement>
                      <condition xsi:type="expressions:EqualityExpression">
                        <equalityOperators xsi:type="operators:Equal"/>
                        <children xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.4/@statement/@statements.2/@statement/@statements.0/@variable"/>
                          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </children>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                      </condition>
                    </statements>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.15">
                        <arguments xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.4/@statement/@statements.2/@statement/@statements.0/@variable"/>
                          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </arguments>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93"/>
                        <arguments xsi:type="references:StringReference" value="scope id"/>
                      </expression>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.4/@statement/@statements.2/@statement/@statements.0/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                    <relationOperators xsi:type="operators:GreaterThan"/>
                  </condition>
                  <elseStatement xsi:type="statements:Block">
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.27">
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                      </expression>
                    </statements>
                  </elseStatement>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Subtraction"/>
                      </arguments>
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </arguments>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </value>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                    <relationOperators xsi:type="operators:GreaterThan"/>
                  </expression>
                </children>
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@parameters.1"/>
                  <arguments xsi:type="literals:CharacterLiteral" value="93"/>
                </children>
              </condition>
              <elseStatement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.5">
                    <arguments xsi:type="references:StringReference" value="closing bracket for IPv6 address"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                  </expression>
                </statements>
              </elseStatement>
            </statements>
          </statement>
          <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@parameters.1"/>
            <arguments xsi:type="literals:CharacterLiteral" value="91"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.24">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@parameters.1"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.25">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@parameters.1"/>
                  </value>
                </expression>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
              </expression>
            </statements>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:Condition">
          <comments>// port</comments>
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                <operator xsi:type="operators:PlusPlus"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.12">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@parameters.1"/>
                  <arguments xsi:type="references:StringReference" value=""/>
                  <arguments xsi:type="references:StringReference" value="/"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.15">
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85"/>
                    <arguments xsi:type="references:StringReference" value="port number"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:TryBlock">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.19"/>
                          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                          </arguments>
                        </next>
                        <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                      </value>
                    </expression>
                  </statements>
                  <catcheBlocks>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
                        <arguments xsi:type="references:StringReference" value="Malformed port number"/>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                      </expression>
                    </statements>
                    <parameter name="x">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                    </parameter>
                  </catcheBlocks>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@parameters.1"/>
            <arguments xsi:type="literals:CharacterLiteral" value="58"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.5">
              <arguments xsi:type="references:StringReference" value="port number"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@parameters.1"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.20/@statements.0/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="scanByte">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Scan a string of decimal digits whose value fits in a byte</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.21/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="q">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.14">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.21/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.21/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.21/@statements.1/@variable"/>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.21/@statements.1/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.21/@statements.0/@variable"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.21/@statements.0/@variable"/>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.19"/>
                <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.21/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.21/@statements.1/@variable"/>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="255"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.21/@statements.1/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="scanIPv4Address">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="strict">
          <typeReference xsi:type="types:Boolean"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Scan an IPv4 address.</comments>
          <comments>//</comments>
          <comments>// If the strict argument is true then we require that the given</comments>
          <comments>// interval contain nothing besides an IPv4 address; if it is false</comments>
          <comments>// then we only require that it start with an IPv4 address.</comments>
          <comments>//</comments>
          <comments>// If the interval does not contain or start with (depending upon the</comments>
          <comments>// strict argument) a legal IPv4 address characters then we return -1</comments>
          <comments>// immediately; otherwise we insist that these characters parse as a</comments>
          <comments>// legal IPv4 address and throw an exception on failure.</comments>
          <comments>//</comments>
          <comments>// We assume that any string of decimal digits and dots must be an IPv4</comments>
          <comments>// address.  It won't parse as a hostname anyway, so making that</comments>
          <comments>// assumption here allows more meaningful exceptions to be thrown.</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="q">
            <typeReference xsi:type="types:Int"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="m">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.14">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@parameters.1"/>
              <arguments xsi:type="expressions:InclusiveOrExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.84"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.112"/>
              </arguments>
              <arguments xsi:type="expressions:InclusiveOrExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.85"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.113"/>
              </arguments>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statement>
          <condition xsi:type="expressions:ConditionalOrExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@parameters.2"/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:NotEqual"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.2/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@parameters.1"/>
                  </expression>
                </children>
              </expression>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:ForLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <comments>// Per RFC2732: At most three digits per byte</comments>
              <comments>// Further constraint: Each element fits in a byte</comments>
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.21">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.2/@variable"/>
                    </value>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.11">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.2/@variable"/>
                      <arguments xsi:type="literals:CharacterLiteral" value="46"/>
                    </value>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.21">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.2/@variable"/>
                    </value>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.11">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.2/@variable"/>
                      <arguments xsi:type="literals:CharacterLiteral" value="46"/>
                    </value>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.21">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.2/@variable"/>
                    </value>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.11">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.2/@variable"/>
                      <arguments xsi:type="literals:CharacterLiteral" value="46"/>
                    </value>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.21">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.2/@variable"/>
                    </value>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.2/@variable"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
            </statements>
          </statement>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
            <arguments xsi:type="references:StringReference" value="Malformed IPv4 address"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.22/@statements.1/@variable"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </returnValue>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="takeIPv4Address">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="expected">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Take an IPv4 address: Throw an exception if the given interval</comments>
          <comments>// contains anything except an IPv4 address</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.22">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.23/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.23/@parameters.1"/>
              <arguments xsi:type="literals:BooleanLiteral" value="true"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.5">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.23/@parameters.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.23/@parameters.0"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.23/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.23/@parameters.0"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.23/@statements.0/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="parseIPv4Address">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Attempt to parse an IPv4 address, returning -1 on failure but</comments>
          <comments>// allowing the given interval to contain [:&lt;characters>] after</comments>
          <comments>// the IPv4 address.</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
          </variable>
        </statements>
        <statements xsi:type="statements:TryBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.22">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@parameters.1"/>
                <arguments xsi:type="literals:BooleanLiteral"/>
              </value>
            </expression>
          </statements>
          <catcheBlocks>
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </returnValue>
            </statements>
            <parameter name="x">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </parameter>
          </catcheBlocks>
          <catcheBlocks>
            <statements xsi:type="statements:Return">
              <returnValue xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </returnValue>
            </statements>
            <parameter name="nfe">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/NumberFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </parameter>
          </catcheBlocks>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <comments>// IPv4 address is followed by something - check that</comments>
              <comments>// it's a &quot;:&quot; as this is the only valid character to</comments>
              <comments>// follow an address.</comments>
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="expressions:UnaryExpression">
                      <operators xsi:type="operators:Subtraction"/>
                      <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    </value>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.8">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@statements.0/@variable"/>
                </children>
                <children xsi:type="literals:CharacterLiteral" value="58"/>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@parameters.0"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </children>
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@parameters.1"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@statements.0/@variable"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@parameters.0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.24/@statements.0/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="parseHostname">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// hostname      = domainlabel [ &quot;.&quot; ] | 1*( domainlabel &quot;.&quot; ) toplabel [ &quot;.&quot; ] </comments>
          <comments>// domainlabel   = alphanum | alphanum *( alphanum | &quot;-&quot; ) alphanum</comments>
          <comments>// toplabel      = alpha | alpha *( alphanum | &quot;-&quot; ) alphanum</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="q">
            <typeReference xsi:type="types:Int"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="l">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:DoWhileLoop">
          <comments>// Start of last parsed label</comments>
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable">
                  <comments>// domainlabel = alphanum [ *( alphanum | &quot;-&quot; ) alphanum ]</comments>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.14">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.2/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.14">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@parameters.1"/>
                      <arguments xsi:type="expressions:InclusiveOrExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.92"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.110"/>
                      </arguments>
                      <arguments xsi:type="expressions:InclusiveOrExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.93"/>
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.111"/>
                      </arguments>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:Block">
                    <statements xsi:type="statements:Condition">
                      <statement xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
                          <arguments xsi:type="references:StringReference" value="Illegal character in hostname"/>
                          <arguments xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable"/>
                            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                            <additiveOperators xsi:type="operators:Subtraction"/>
                          </arguments>
                        </expression>
                      </statement>
                      <condition xsi:type="expressions:EqualityExpression">
                        <equalityOperators xsi:type="operators:Equal"/>
                        <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.8">
                          <arguments xsi:type="expressions:AdditiveExpression">
                            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable"/>
                            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                            <additiveOperators xsi:type="operators:Subtraction"/>
                          </arguments>
                        </children>
                        <children xsi:type="literals:CharacterLiteral" value="45"/>
                      </condition>
                    </statements>
                    <statements xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable"/>
                      </expression>
                    </statements>
                  </statement>
                  <condition xsi:type="expressions:RelationExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                    <relationOperators xsi:type="operators:GreaterThan"/>
                  </condition>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.11">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@parameters.1"/>
                  <arguments xsi:type="literals:CharacterLiteral" value="46"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.1/@variable"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@parameters.1"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
              <arguments xsi:type="references:StringReference" value="Illegal character in hostname"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@parameters.1"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </expression>
            </children>
            <children xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@parameters.1"/>
                <arguments xsi:type="literals:CharacterLiteral" value="58"/>
              </child>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.5">
              <arguments xsi:type="references:StringReference" value="hostname"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@parameters.0"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.2/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <comments>// for a fully qualified hostname check that the rightmost</comments>
          <comments>// label starts with an alpha character.</comments>
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
                <arguments xsi:type="references:StringReference" value="Illegal character in hostname"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.2/@variable"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@parameters.0"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </children>
            <children xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.83">
                <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.8">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.2/@variable"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.90"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.91"/>
              </child>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.7">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.25/@statements.0/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:Field" name="ipv6byteCount">
        <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        <typeReference xsi:type="types:Int"/>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// IPv6 address parsing, from RFC2373: IPv6 Addressing Architecture</comments>
          <comments>//</comments>
          <comments>// Bug: The grammar in RFC2373 Appendix B does not allow addresses of</comments>
          <comments>// the form ::12.34.56.78, which are clearly shown in the examples</comments>
          <comments>// earlier in the document.  Here is the original grammar:</comments>
          <comments>//</comments>
          <comments>//   IPv6address = hexpart [ &quot;:&quot; IPv4address ]</comments>
          <comments>//   hexpart     = hexseq | hexseq &quot;::&quot; [ hexseq ] | &quot;::&quot; [ hexseq ]</comments>
          <comments>//   hexseq      = hex4 *( &quot;:&quot; hex4)</comments>
          <comments>//   hex4        = 1*4HEXDIG</comments>
          <comments>//</comments>
          <comments>// We therefore use the following revised grammar:</comments>
          <comments>//</comments>
          <comments>//   IPv6address = hexseq [ &quot;:&quot; IPv4address ]</comments>
          <comments>//                 | hexseq [ &quot;::&quot; [ hexpost ] ]</comments>
          <comments>//                 | &quot;::&quot; [ hexpost ]</comments>
          <comments>//   hexpost     = hexseq | hexseq &quot;:&quot; IPv4address | IPv4address</comments>
          <comments>//   hexseq      = hex4 *( &quot;:&quot; hex4)</comments>
          <comments>//   hex4        = 1*4HEXDIG</comments>
          <comments>//</comments>
          <comments>// This covers all and only the following cases:</comments>
          <comments>//</comments>
          <comments>//   hexseq</comments>
          <comments>//   hexseq : IPv4address</comments>
          <comments>//   hexseq ::</comments>
          <comments>//   hexseq :: hexseq</comments>
          <comments>//   hexseq :: hexseq : IPv4address</comments>
          <comments>//   hexseq :: IPv4address</comments>
          <comments>//   :: hexseq</comments>
          <comments>//   :: hexseq : IPv4address</comments>
          <comments>//   :: IPv4address</comments>
          <comments>//   ::</comments>
          <comments>//</comments>
          <comments>// Additionally we constrain the IPv6 address as follows :-</comments>
          <comments>//</comments>
          <comments>//  i.  IPv6 addresses without compressed zeros should contain</comments>
          <comments>//      exactly 16 bytes.</comments>
          <comments>//</comments>
          <comments>//  ii. IPv6 addresses with compressed zeros should contain</comments>
          <comments>//      less than 16 bytes.</comments>
        </annotationsAndModifiers>
      </members>
      <members xsi:type="members:ClassMethod" name="parseIPv6Reference">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="q">
            <typeReference xsi:type="types:Int"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="compressedZeros">
            <typeReference xsi:type="types:Boolean"/>
            <initialValue xsi:type="literals:BooleanLiteral"/>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.29">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.1"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.1/@variable"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.2/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="literals:BooleanLiteral" value="true"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.28">
                      <arguments xsi:type="expressions:AdditiveExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                        <additiveOperators xsi:type="operators:Addition"/>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.1"/>
                    </value>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.10">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.1"/>
                <arguments xsi:type="references:StringReference" value="::"/>
              </condition>
              <elseStatement xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.23">
                        <arguments xsi:type="expressions:AdditiveExpression">
                          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
                          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                          <additiveOperators xsi:type="operators:Addition"/>
                        </arguments>
                        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.1"/>
                        <arguments xsi:type="references:StringReference" value="IPv4 address"/>
                      </value>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.26"/>
                      <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                      <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.1"/>
                  <arguments xsi:type="literals:CharacterLiteral" value="58"/>
                </condition>
              </elseStatement>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.1/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.2/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:BooleanLiteral" value="true"/>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.28">
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
                      <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.1"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.10">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.1"/>
              <arguments xsi:type="references:StringReference" value="::"/>
            </condition>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
              <arguments xsi:type="references:StringReference" value="Malformed IPv6 address"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.0"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.1"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
              <arguments xsi:type="references:StringReference" value="IPv6 address too long"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.0"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.26"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
              <arguments xsi:type="references:StringReference" value="IPv6 address too short"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.0"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.2/@variable"/>
            </children>
            <children xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.26"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
              <arguments xsi:type="references:StringReference" value="Malformed IPv6 address"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@parameters.0"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:ConditionalAndExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.2/@variable"/>
            <children xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.26"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
            </children>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.27/@statements.0/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="scanHexPost">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="q">
            <typeReference xsi:type="types:Int"/>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@parameters.1"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.29">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@parameters.1"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.1/@variable"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.23">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@parameters.1"/>
                      <arguments xsi:type="references:StringReference" value="hex digits or IPv4 address"/>
                    </value>
                  </expression>
                </statements>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.26"/>
                    <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                    <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
                  </expression>
                </statements>
              </statement>
              <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@parameters.1"/>
                <arguments xsi:type="literals:CharacterLiteral" value="58"/>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.1/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
          <elseStatement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.23">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@parameters.1"/>
                  <arguments xsi:type="references:StringReference" value="hex digits or IPv4 address"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.26"/>
                <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </expression>
            </statements>
          </elseStatement>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.28/@statements.0/@variable"/>
        </statements>
      </members>
      <members xsi:type="members:ClassMethod" name="scanHexSeq">
        <typeReference xsi:type="types:Int"/>
        <parameters xsi:type="parameters:OrdinaryParameter" name="start">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <parameters xsi:type="parameters:OrdinaryParameter" name="n">
          <typeReference xsi:type="types:Int"/>
        </parameters>
        <exceptions>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="URISyntaxException.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </exceptions>
        <annotationsAndModifiers xsi:type="modifiers:Private">
          <comments>// Scan a hex sequence; return -1 if one could not be scanned</comments>
          <comments>//</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="p">
            <typeReference xsi:type="types:Int"/>
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@parameters.0"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="q">
            <typeReference xsi:type="types:Int"/>
          </variable>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.14">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95"/>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.1/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <comments>// Beginning of IPv4 address</comments>
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statement>
          <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.1/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@parameters.1"/>
            <arguments xsi:type="literals:CharacterLiteral" value="46"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
              <arguments xsi:type="references:StringReference" value="IPv6 hexadecimal digit sequence too long"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.1/@variable"/>
            <children xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </children>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.26"/>
            <assignmentOperator xsi:type="operators:AssignmentPlus"/>
            <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.1/@variable"/>
          </expression>
        </statements>
        <statements xsi:type="statements:WhileLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Negate"/>
                <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@parameters.1"/>
                  <arguments xsi:type="literals:CharacterLiteral" value="58"/>
                </child>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Break"/>
              <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@parameters.1"/>
                <arguments xsi:type="literals:CharacterLiteral" value="58"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable">
                  <comments>// &quot;::&quot;</comments>
                </child>
                <operator xsi:type="operators:PlusPlus"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.14">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.94"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.95"/>
                </value>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.5">
                  <arguments xsi:type="references:StringReference" value="digits for an IPv6 address"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
                </expression>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.1/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
                <relationOperators xsi:type="operators:LessThanOrEqual"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable">
                      <comments>// Beginning of IPv4 address</comments>
                    </child>
                    <operator xsi:type="operators:MinusMinus"/>
                  </expression>
                </statements>
                <statements xsi:type="statements:Break"/>
              </statement>
              <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.9">
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.1/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@parameters.1"/>
                <arguments xsi:type="literals:CharacterLiteral" value="46"/>
              </condition>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.136/@members.4">
                  <arguments xsi:type="references:StringReference" value="IPv6 hexadecimal digit sequence too long"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
                </expression>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.1/@variable"/>
                <children xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </condition>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.26"/>
                <assignmentOperator xsi:type="operators:AssignmentPlus"/>
                <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.1/@variable"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@parameters.1"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.136/@members.29/@statements.0/@variable"/>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// -- Parsing --</comments>
        <comments>// For convenience we wrap the input URI string in a new instance of the</comments>
        <comments>// following internal class.  This saves always having to pass the input</comments>
        <comments>// string as an argument to each internal scan/parse method.</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>// for javadoc</comments>
      <comments>/**&#xA; * Represents a Uniform Resource Identifier (URI) reference.&#xA; *&#xA; * &lt;p> Aside from some minor deviations noted below, an instance of this &#xA; * class represents a URI reference as defined by&#xA; * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&quot;>&lt;i>RFC&amp;nbsp;2396: Uniform&#xA; * Resource Identifiers (URI): Generic Syntax&lt;/i>&lt;/a>, amended by &lt;a&#xA; * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;>&lt;i>RFC&amp;nbsp;2732: Format for&#xA; * Literal IPv6 Addresses in URLs&lt;/i>&lt;/a>. The Literal IPv6 address format&#xA; * also supports scope_ids. The syntax and usage of scope_ids is described&#xA; * &lt;a href=&quot;Inet6Address.html#scoped&quot;>here&lt;/a>.&#xA; * This class provides constructors for creating URI instances from&#xA; * their components or by parsing their string forms, methods for accessing the&#xA; * various components of an instance, and methods for normalizing, resolving,&#xA; * and relativizing URI instances.  Instances of this class are immutable.&#xA; *&#xA; *&#xA; * &lt;h4> URI syntax and components &lt;/h4>&#xA; *&#xA; * At the highest level a URI reference (hereinafter simply &quot;URI&quot;) in string&#xA; * form has the syntax&#xA; *&#xA; * &lt;blockquote>&#xA; * [&lt;i>scheme&lt;/i>&lt;tt>&lt;b>:&lt;/b>&lt;/tt>&lt;i>&lt;/i>]&lt;i>scheme-specific-part&lt;/i>[&lt;tt>&lt;b>#&lt;/b>&lt;/tt>&lt;i>fragment&lt;/i>]&#xA; * &lt;/blockquote>&#xA; *&#xA; * where square brackets [...] delineate optional components and the characters&#xA; * &lt;tt>&lt;b>:&lt;/b>&lt;/tt> and &lt;tt>&lt;b>#&lt;/b>&lt;/tt> stand for themselves.&#xA; *&#xA; * &lt;p> An &lt;i>absolute&lt;/i> URI specifies a scheme; a URI that is not absolute is&#xA; * said to be &lt;i>relative&lt;/i>.  URIs are also classified according to whether&#xA; * they are &lt;i>opaque&lt;/i> or &lt;i>hierarchical&lt;/i>.&#xA; *&#xA; * &lt;p> An &lt;i>opaque&lt;/i> URI is an absolute URI whose scheme-specific part does&#xA; * not begin with a slash character (&lt;tt>'/'&lt;/tt>).  Opaque URIs are not&#xA; * subject to further parsing.  Some examples of opaque URIs are:&#xA; *&#xA; * &lt;blockquote>&lt;table cellpadding=0 cellspacing=0 summary=&quot;layout&quot;>&#xA; * &lt;tr>&lt;td>&lt;tt>mailto:java-net@java.sun.com&lt;/tt>&lt;td>&lt;/tr>&#xA; * &lt;tr>&lt;td>&lt;tt>news:comp.lang.java&lt;/tt>&lt;td>&lt;/tr>&#xA; * &lt;tr>&lt;td>&lt;tt>urn:isbn:096139210x&lt;/tt>&lt;/td>&lt;/tr>&#xA; * &lt;/table>&lt;/blockquote>&#xA; *&#xA; * &lt;p> A &lt;i>hierarchical&lt;/i> URI is either an absolute URI whose&#xA; * scheme-specific part begins with a slash character, or a relative URI, that&#xA; * is, a URI that does not specify a scheme.  Some examples of hierarchical&#xA; * URIs are:&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>http://java.sun.com/j2se/1.3/&lt;/tt>&lt;br>&#xA; * &lt;tt>docs/guide/collections/designfaq.html#28&lt;/tt>&lt;br>&#xA; * &lt;tt>../../../demo/jfc/SwingSet2/src/SwingSet2.java&lt;/tt>&lt;br>&#xA; * &lt;tt>file:///~/calendar&lt;/tt>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p> A hierarchical URI is subject to further parsing according to the syntax&#xA; *&#xA; * &lt;blockquote>&#xA; * [&lt;i>scheme&lt;/i>&lt;tt>&lt;b>:&lt;/b>&lt;/tt>][&lt;tt>&lt;b>//&lt;/b>&lt;/tt>&lt;i>authority&lt;/i>][&lt;i>path&lt;/i>][&lt;tt>&lt;b>?&lt;/b>&lt;/tt>&lt;i>query&lt;/i>][&lt;tt>&lt;b>#&lt;/b>&lt;/tt>&lt;i>fragment&lt;/i>]&#xA; * &lt;/blockquote>&#xA; *&#xA; * where the characters &lt;tt>&lt;b>:&lt;/b>&lt;/tt>, &lt;tt>&lt;b>/&lt;/b>&lt;/tt>,&#xA; * &lt;tt>&lt;b>?&lt;/b>&lt;/tt>, and &lt;tt>&lt;b>#&lt;/b>&lt;/tt> stand for themselves.  The&#xA; * scheme-specific part of a hierarchical URI consists of the characters&#xA; * between the scheme and fragment components.&#xA; *&#xA; * &lt;p> The authority component of a hierarchical URI is, if specified, either&#xA; * &lt;i>server-based&lt;/i> or &lt;i>registry-based&lt;/i>.  A server-based authority&#xA; * parses according to the familiar syntax&#xA; *&#xA; * &lt;blockquote>&#xA; * [&lt;i>user-info&lt;/i>&lt;tt>&lt;b>@&lt;/b>&lt;/tt>]&lt;i>host&lt;/i>[&lt;tt>&lt;b>:&lt;/b>&lt;/tt>&lt;i>port&lt;/i>]&#xA; * &lt;/blockquote>&#xA; *&#xA; * where the characters &lt;tt>&lt;b>@&lt;/b>&lt;/tt> and &lt;tt>&lt;b>:&lt;/b>&lt;/tt> stand for&#xA; * themselves.  Nearly all URI schemes currently in use are server-based.  An&#xA; * authority component that does not parse in this way is considered to be&#xA; * registry-based.&#xA; *&#xA; * &lt;p> The path component of a hierarchical URI is itself said to be absolute&#xA; * if it begins with a slash character (&lt;tt>'/'&lt;/tt>); otherwise it is&#xA; * relative.  The path of a hierarchical URI that is either absolute or&#xA; * specifies an authority is always absolute.&#xA; *&#xA; * &lt;p> All told, then, a URI instance has the following nine components:&#xA; *&#xA; * &lt;blockquote>&lt;table summary=&quot;Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment&quot;>&#xA; * &lt;tr>&lt;th>&lt;i>Component&lt;/i>&lt;/th>&lt;th>&lt;i>Type&lt;/i>&lt;/th>&lt;/tr>&#xA; * &lt;tr>&lt;td>scheme&lt;/td>&lt;td>&lt;tt>String&lt;/tt>&lt;/td>&lt;/tr>&#xA; * &lt;tr>&lt;td>scheme-specific-part&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td>&lt;td>&lt;tt>String&lt;/tt>&lt;/td>&lt;/tr>&#xA; * &lt;tr>&lt;td>authority&lt;/td>&lt;td>&lt;tt>String&lt;/tt>&lt;/td>&lt;/tr>&#xA; * &lt;tr>&lt;td>user-info&lt;/td>&lt;td>&lt;tt>String&lt;/tt>&lt;/td>&lt;/tr>&#xA; * &lt;tr>&lt;td>host&lt;/td>&lt;td>&lt;tt>String&lt;/tt>&lt;/td>&lt;/tr>&#xA; * &lt;tr>&lt;td>port&lt;/td>&lt;td>&lt;tt>int&lt;/tt>&lt;/td>&lt;/tr>&#xA; * &lt;tr>&lt;td>path&lt;/td>&lt;td>&lt;tt>String&lt;/tt>&lt;/td>&lt;/tr>&#xA; * &lt;tr>&lt;td>query&lt;/td>&lt;td>&lt;tt>String&lt;/tt>&lt;/td>&lt;/tr>&#xA; * &lt;tr>&lt;td>fragment&lt;/td>&lt;td>&lt;tt>String&lt;/tt>&lt;/td>&lt;/tr>&#xA; * &lt;/table>&lt;/blockquote>&#xA; *&#xA; * In a given instance any particular component is either &lt;i>undefined&lt;/i> or&#xA; * &lt;i>defined&lt;/i> with a distinct value.  Undefined string components are&#xA; * represented by &lt;tt>null&lt;/tt>, while undefined integer components are&#xA; * represented by &lt;tt>-1&lt;/tt>.  A string component may be defined to have the&#xA; * empty string as its value; this is not equivalent to that component being&#xA; * undefined.&#xA; *&#xA; * &lt;p> Whether a particular component is or is not defined in an instance&#xA; * depends upon the type of the URI being represented.  An absolute URI has a&#xA; * scheme component.  An opaque URI has a scheme, a scheme-specific part, and&#xA; * possibly a fragment, but has no other components.  A hierarchical URI always&#xA; * has a path (though it may be empty) and a scheme-specific-part (which at&#xA; * least contains the path), and may have any of the other components.  If the&#xA; * authority component is present and is server-based then the host component&#xA; * will be defined and the user-information and port components may be defined.&#xA; *&#xA; *&#xA; * &lt;h4> Operations on URI instances &lt;/h4>&#xA; *&#xA; * The key operations supported by this class are those of&#xA; * &lt;i>normalization&lt;/i>, &lt;i>resolution&lt;/i>, and &lt;i>relativization&lt;/i>.&#xA; *&#xA; * &lt;p> &lt;i>Normalization&lt;/i> is the process of removing unnecessary &lt;tt>&quot;.&quot;&lt;/tt>&#xA; * and &lt;tt>&quot;..&quot;&lt;/tt> segments from the path component of a hierarchical URI.&#xA; * Each &lt;tt>&quot;.&quot;&lt;/tt> segment is simply removed.  A &lt;tt>&quot;..&quot;&lt;/tt> segment is&#xA; * removed only if it is preceded by a non-&lt;tt>&quot;..&quot;&lt;/tt> segment.&#xA; * Normalization has no effect upon opaque URIs.&#xA; *&#xA; * &lt;p> &lt;i>Resolution&lt;/i> is the process of resolving one URI against another,&#xA; * &lt;i>base&lt;/i> URI.  The resulting URI is constructed from components of both&#xA; * URIs in the manner specified by RFC&amp;nbsp;2396, taking components from the&#xA; * base URI for those not specified in the original.  For hierarchical URIs,&#xA; * the path of the original is resolved against the path of the base and then&#xA; * normalized.  The result, for example, of resolving&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>docs/guide/collections/designfaq.html#28&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt>(1)&#xA; * &lt;/blockquote>&#xA; *&#xA; * against the base URI &lt;tt>http://java.sun.com/j2se/1.3/&lt;/tt> is the result&#xA; * URI&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>http://java.sun.com/j2se/1.3/docs/guide/collections/designfaq.html#28&lt;/tt>&#xA; * &lt;/blockquote>&#xA; *&#xA; * Resolving the relative URI&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>../../../demo/jfc/SwingSet2/src/SwingSet2.java&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt>(2)&#xA; * &lt;/blockquote>&#xA; *&#xA; * against this result yields, in turn,&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>http://java.sun.com/j2se/1.3/demo/jfc/SwingSet2/src/SwingSet2.java&lt;/tt>&#xA; * &lt;/blockquote>&#xA; *&#xA; * Resolution of both absolute and relative URIs, and of both absolute and&#xA; * relative paths in the case of hierarchical URIs, is supported.  Resolving&#xA; * the URI &lt;tt>file:///~calendar&lt;/tt> against any other URI simply yields the&#xA; * original URI, since it is absolute.  Resolving the relative URI (2) above&#xA; * against the relative base URI (1) yields the normalized, but still relative,&#xA; * URI&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>demo/jfc/SwingSet2/src/SwingSet2.java&lt;/tt>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p> &lt;i>Relativization&lt;/i>, finally, is the inverse of resolution: For any&#xA; * two normalized URIs &lt;i>u&lt;/i> and&amp;nbsp;&lt;i>v&lt;/i>,&#xA; *&#xA; * &lt;blockquote>&#xA; *   &lt;i>u&lt;/i>&lt;tt>.relativize(&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.resolve(&lt;/tt>&lt;i>v&lt;/i>&lt;tt>)).equals(&lt;/tt>&lt;i>v&lt;/i>&lt;tt>)&lt;/tt>&amp;nbsp;&amp;nbsp;and&lt;br>&#xA; *   &lt;i>u&lt;/i>&lt;tt>.resolve(&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.relativize(&lt;/tt>&lt;i>v&lt;/i>&lt;tt>)).equals(&lt;/tt>&lt;i>v&lt;/i>&lt;tt>)&lt;/tt>&amp;nbsp;&amp;nbsp;.&lt;br>&#xA; * &lt;/blockquote>&#xA; *&#xA; * This operation is often useful when constructing a document containing URIs&#xA; * that must be made relative to the base URI of the document wherever&#xA; * possible.  For example, relativizing the URI&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>http://java.sun.com/j2se/1.3/docs/guide/index.html&lt;/tt>&#xA; * &lt;/blockquote>&#xA; *&#xA; * against the base URI&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>http://java.sun.com/j2se/1.3&lt;/tt>&#xA; * &lt;/blockquote>&#xA; *&#xA; * yields the relative URI &lt;tt>docs/guide/index.html&lt;/tt>.&#xA; *&#xA; *&#xA; * &lt;h4> Character categories &lt;/h4>&#xA; *&#xA; * RFC&amp;nbsp;2396 specifies precisely which characters are permitted in the&#xA; * various components of a URI reference.  The following categories, most of&#xA; * which are taken from that specification, are used below to describe these&#xA; * constraints:&#xA; *&#xA; * &lt;blockquote>&lt;table cellspacing=2 summary=&quot;Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other&quot;>&#xA; *   &lt;tr>&lt;th valign=top>&lt;i>alpha&lt;/i>&lt;/th>&#xA; *       &lt;td>The US-ASCII alphabetic characters,&#xA; * &#x9;  &lt;tt>'A'&lt;/tt>&amp;nbsp;through&amp;nbsp;&lt;tt>'Z'&lt;/tt>&#xA; * &#x9;  and &lt;tt>'a'&lt;/tt>&amp;nbsp;through&amp;nbsp;&lt;tt>'z'&lt;/tt>&lt;/td>&lt;/tr>&#xA; *   &lt;tr>&lt;th valign=top>&lt;i>digit&lt;/i>&lt;/th>&#xA; *       &lt;td>The US-ASCII decimal digit characters,&#xA; *       &lt;tt>'0'&lt;/tt>&amp;nbsp;through&amp;nbsp;&lt;tt>'9'&lt;/tt>&lt;/td>&lt;/tr>&#xA; *   &lt;tr>&lt;th valign=top>&lt;i>alphanum&lt;/i>&lt;/th>&#xA; *       &lt;td>All &lt;i>alpha&lt;/i> and &lt;i>digit&lt;/i> characters&lt;/td>&lt;/tr>&#xA; *   &lt;tr>&lt;th valign=top>&lt;i>unreserved&lt;/i>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th>&#xA; *       &lt;td>All &lt;i>alphanum&lt;/i> characters together with those in the string&#xA; * &#x9;  &lt;tt>&quot;_-!.~'()*&quot;&lt;/tt>&lt;/td>&lt;/tr>&#xA; *   &lt;tr>&lt;th valign=top>&lt;i>punct&lt;/i>&lt;/th>&#xA; *       &lt;td>The characters in the string &lt;tt>&quot;,;:$&amp;+=&quot;&lt;/tt>&lt;/td>&lt;/tr>&#xA; *   &lt;tr>&lt;th valign=top>&lt;i>reserved&lt;/i>&lt;/th>&#xA; *       &lt;td>All &lt;i>punct&lt;/i> characters together with those in the string&#xA; * &#x9;  &lt;tt>&quot;?/[]@&quot;&lt;/tt>&lt;/td>&lt;/tr>&#xA; *   &lt;tr>&lt;th valign=top>&lt;i>escaped&lt;/i>&lt;/th>&#xA; *       &lt;td>Escaped octets, that is, triplets consisting of the percent&#xA; *           character (&lt;tt>'%'&lt;/tt>) followed by two hexadecimal digits&#xA; *           (&lt;tt>'0'&lt;/tt>-&lt;tt>'9'&lt;/tt>, &lt;tt>'A'&lt;/tt>-&lt;tt>'F'&lt;/tt>, and&#xA; *           &lt;tt>'a'&lt;/tt>-&lt;tt>'f'&lt;/tt>)&lt;/td>&lt;/tr>&#xA; *   &lt;tr>&lt;th valign=top>&lt;i>other&lt;/i>&lt;/th>&#xA; *       &lt;td>The Unicode characters that are not in the US-ASCII character set,&#xA; *           are not control characters (according to the {@link&#xA; *           java.lang.Character#isISOControl(char) Character.isISOControl}&#xA; * &#x9;     method), and are not space characters (according to the {@link&#xA; * &#x9;     java.lang.Character#isSpaceChar(char) Character.isSpaceChar}&#xA; * &#x9;     method)&amp;nbsp;&amp;nbsp;&lt;i>(&lt;b>Deviation from RFC 2396&lt;/b>, which is&#xA; * &#x9;     limited to US-ASCII)&lt;/i>&lt;/td>&lt;/tr>&#xA; * &lt;/table>&lt;/blockquote>&#xA; *&#xA; * &lt;p>&lt;a name=&quot;legal-chars&quot;>&lt;/a> The set of all legal URI characters consists of&#xA; * the &lt;i>unreserved&lt;/i>, &lt;i>reserved&lt;/i>, &lt;i>escaped&lt;/i>, and &lt;i>other&lt;/i>&#xA; * characters.&#xA; *&#xA; *&#xA; * &lt;h4> Escaped octets, quotation, encoding, and decoding &lt;/h4>&#xA; *&#xA; * RFC 2396 allows escaped octets to appear in the user-info, path, query, and&#xA; * fragment components.  Escaping serves two purposes in URIs:&#xA; *&#xA; * &lt;ul>&#xA; *&#xA; *   &lt;li>&lt;p> To &lt;i>encode&lt;/i> non-US-ASCII characters when a URI is required to&#xA; *   conform strictly to RFC&amp;nbsp;2396 by not containing any &lt;i>other&lt;/i>&#xA; *   characters.  &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> To &lt;i>quote&lt;/i> characters that are otherwise illegal in a&#xA; *   component.  The user-info, path, query, and fragment components differ&#xA; *   slightly in terms of which characters are considered legal and illegal.&#xA; *   &lt;/p>&lt;/li>&#xA; *&#xA; * &lt;/ul>&#xA; *&#xA; * These purposes are served in this class by three related operations:&#xA; *&#xA; * &lt;ul>&#xA; *&#xA; *   &lt;li>&lt;p>&lt;a name=&quot;encode&quot;>&lt;/a> A character is &lt;i>encoded&lt;/i> by replacing it&#xA; *   with the sequence of escaped octets that represent that character in the&#xA; *   UTF-8 character set.  The Euro currency symbol (&lt;tt>'&amp;#92;u20AC'&lt;/tt>),&#xA; *   for example, is encoded as &lt;tt>&quot;%E2%82%AC&quot;&lt;/tt>.  &lt;i>(&lt;b>Deviation from&#xA; *   RFC&amp;nbsp;2396&lt;/b>, which does not specify any particular character&#xA; *   set.)&lt;/i> &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p>&lt;a name=&quot;quote&quot;>&lt;/a> An illegal character is &lt;i>quoted&lt;/i> simply by&#xA; *   encoding it.  The space character, for example, is quoted by replacing it&#xA; *   with &lt;tt>&quot;%20&quot;&lt;/tt>.  UTF-8 contains US-ASCII, hence for US-ASCII&#xA; *   characters this transformation has exactly the effect required by&#xA; *   RFC&amp;nbsp;2396. &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p>&lt;a name=&quot;decode&quot;>&lt;/a>&#xA; *   A sequence of escaped octets is &lt;i>decoded&lt;/i> by&#xA; *   replacing it with the sequence of characters that it represents in the&#xA; *   UTF-8 character set.  UTF-8 contains US-ASCII, hence decoding has the&#xA; *   effect of de-quoting any quoted US-ASCII characters as well as that of&#xA; *   decoding any encoded non-US-ASCII characters.  If a &lt;a&#xA; *   href=&quot;../nio/charset/CharsetDecoder.html#ce&quot;>decoding error&lt;/a> occurs&#xA; *   when decoding the escaped octets then the erroneous octets are replaced by&#xA; *   &lt;tt>'&amp;#92;uFFFD'&lt;/tt>, the Unicode replacement character.  &lt;/p>&lt;/li>&#xA; *&#xA; * &lt;/ul>&#xA; *&#xA; * These operations are exposed in the constructors and methods of this class&#xA; * as follows:&#xA; *&#xA; * &lt;ul>&#xA; *&#xA; *   &lt;li>&lt;p> The {@link #URI(java.lang.String) &lt;code>single-argument&#xA; *   constructor&lt;/code>} requires any illegal characters in its argument to be&#xA; *   quoted and preserves any escaped octets and &lt;i>other&lt;/i> characters that&#xA; *   are present.  &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> The {@link&#xA; *   #URI(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)&#xA; *   &lt;code>multi-argument constructors&lt;/code>} quote illegal characters as&#xA; *   required by the components in which they appear.  The percent character&#xA; *   (&lt;tt>'%'&lt;/tt>) is always quoted by these constructors.  Any &lt;i>other&lt;/i>&#xA; *   characters are preserved.  &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> The {@link #getRawUserInfo() getRawUserInfo}, {@link #getRawPath()&#xA; *   getRawPath}, {@link #getRawQuery() getRawQuery}, {@link #getRawFragment()&#xA; *   getRawFragment}, {@link #getRawAuthority() getRawAuthority}, and {@link&#xA; *   #getRawSchemeSpecificPart() getRawSchemeSpecificPart} methods return the&#xA; *   values of their corresponding components in raw form, without interpreting&#xA; *   any escaped octets.  The strings returned by these methods may contain&#xA; *   both escaped octets and &lt;i>other&lt;/i> characters, and will not contain any&#xA; *   illegal characters.  &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> The {@link #getUserInfo() getUserInfo}, {@link #getPath()&#xA; *   getPath}, {@link #getQuery() getQuery}, {@link #getFragment()&#xA; *   getFragment}, {@link #getAuthority() getAuthority}, and {@link&#xA; *   #getSchemeSpecificPart() getSchemeSpecificPart} methods decode any escaped&#xA; *   octets in their corresponding components.  The strings returned by these&#xA; *   methods may contain both &lt;i>other&lt;/i> characters and illegal characters,&#xA; *   and will not contain any escaped octets.  &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> The {@link #toString() toString} method returns a URI string with&#xA; *   all necessary quotation but which may contain &lt;i>other&lt;/i> characters.&#xA; *   &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> The {@link #toASCIIString() toASCIIString} method returns a fully&#xA; *   quoted and encoded URI string that does not contain any &lt;i>other&lt;/i>&#xA; *   characters.  &lt;/p>&lt;/li>&#xA; *&#xA; * &lt;/ul>&#xA; *&#xA; *&#xA; * &lt;h4> Identities &lt;/h4>&#xA; *&#xA; * For any URI &lt;i>u&lt;/i>, it is always the case that&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>new URI(&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.toString()).equals(&lt;/tt>&lt;i>u&lt;/i>&lt;tt>)&lt;/tt>&amp;nbsp;.&#xA; * &lt;/blockquote>&#xA; *&#xA; * For any URI &lt;i>u&lt;/i> that does not contain redundant syntax such as two&#xA; * slashes before an empty authority (as in &lt;tt>file:///tmp/&lt;/tt>&amp;nbsp;) or a&#xA; * colon following a host name but no port (as in&#xA; * &lt;tt>http://java.sun.com:&lt;/tt>&amp;nbsp;), and that does not encode characters&#xA; * except those that must be quoted, the following identities also hold:&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>new URI(&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getScheme(),&lt;br>&#xA; * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getSchemeSpecificPart(),&lt;br>&#xA; * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getFragment())&lt;br>&#xA; * .equals(&lt;/tt>&lt;i>u&lt;/i>&lt;tt>)&lt;/tt>&#xA; * &lt;/blockquote>&#xA; *&#xA; * in all cases,&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>new URI(&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getScheme(),&lt;br>&#xA; * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getUserInfo(),&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getAuthority(),&lt;br>&#xA; * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getPath(),&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getQuery(),&lt;br>&#xA; * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getFragment())&lt;br>&#xA; * .equals(&lt;/tt>&lt;i>u&lt;/i>&lt;tt>)&lt;/tt>&#xA; * &lt;/blockquote>&#xA; *&#xA; * if &lt;i>u&lt;/i> is hierarchical, and&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;tt>new URI(&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getScheme(),&lt;br>&#xA; * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getUserInfo(),&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getHost(),&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getPort(),&lt;br>&#xA; * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getPath(),&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getQuery(),&lt;br>&#xA; * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt>&lt;i>u&lt;/i>&lt;tt>.getFragment())&lt;br>&#xA; * .equals(&lt;/tt>&lt;i>u&lt;/i>&lt;tt>)&lt;/tt>&#xA; * &lt;/blockquote>&#xA; *&#xA; * if &lt;i>u&lt;/i> is hierarchical and has either no authority or a server-based&#xA; * authority.&#xA; *&#xA; *&#xA; * &lt;h4> URIs, URLs, and URNs &lt;/h4>&#xA; *&#xA; * A URI is a uniform resource &lt;i>identifier&lt;/i> while a URL is a uniform&#xA; * resource &lt;i>locator&lt;/i>.  Hence every URL is a URI, abstractly speaking, but&#xA; * not every URI is a URL.  This is because there is another subcategory of&#xA; * URIs, uniform resource &lt;i>names&lt;/i> (URNs), which name resources but do not&#xA; * specify how to locate them.  The &lt;tt>mailto&lt;/tt>, &lt;tt>news&lt;/tt>, and&#xA; * &lt;tt>isbn&lt;/tt> URIs shown above are examples of URNs.&#xA; *&#xA; * &lt;p> The conceptual distinction between URIs and URLs is reflected in the&#xA; * differences between this class and the {@link URL} class.&#xA; *&#xA; * &lt;p> An instance of this class represents a URI reference in the syntactic&#xA; * sense defined by RFC&amp;nbsp;2396.  A URI may be either absolute or relative.&#xA; * A URI string is parsed according to the generic syntax without regard to the&#xA; * scheme, if any, that it specifies.  No lookup of the host, if any, is&#xA; * performed, and no scheme-dependent stream handler is constructed.  Equality,&#xA; * hashing, and comparison are defined strictly in terms of the character&#xA; * content of the instance.  In other words, a URI instance is little more than&#xA; * a structured string that supports the syntactic, scheme-independent&#xA; * operations of comparison, normalization, resolution, and relativization.&#xA; *&#xA; * &lt;p> An instance of the {@link URL} class, by contrast, represents the&#xA; * syntactic components of a URL together with some of the information required&#xA; * to access the resource that it describes.  A URL must be absolute, that is,&#xA; * it must always specify a scheme.  A URL string is parsed according to its&#xA; * scheme.  A stream handler is always established for a URL, and in fact it is&#xA; * impossible to create a URL instance for a scheme for which no handler is&#xA; * available.  Equality and hashing depend upon both the scheme and the&#xA; * Internet address of the host, if any; comparison is not defined.  In other&#xA; * words, a URL is a structured string that supports the syntactic operation of&#xA; * resolution as well as the network I/O operations of looking up the host and&#xA; * opening a connection to the specified resource.&#xA; *&#xA; *&#xA; * @version 1.40, 05/11/28&#xA; * @author Mark Reinhold&#xA; * @since 1.4&#xA; *&#xA; * @see &lt;a href=&quot;http://ietf.org/rfc/rfc2279.txt&quot;>&lt;i>RFC&amp;nbsp;2279: UTF-8, a&#xA; * transformation format of ISO 10646&lt;/i>&lt;/a>, &lt;br>&lt;a&#xA; * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;>&lt;i>RFC&amp;nbsp;2373: IPv6 Addressing&#xA; * Architecture&lt;/i>&lt;/a>, &lt;br>&lt;a&#xA; * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&quot;>&lt;i>RFC&amp;nbsp;2396: Uniform&#xA; * Resource Identifiers (URI): Generic Syntax&lt;/i>&lt;/a>, &lt;br>&lt;a&#xA; * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;>&lt;i>RFC&amp;nbsp;2732: Format for&#xA; * Literal IPv6 Addresses in URLs&lt;/i>&lt;/a>, &lt;br>&lt;a&#xA; * href=&quot;URISyntaxException.html&quot;>URISyntaxException&lt;/a>&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../lang/Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../io/Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
