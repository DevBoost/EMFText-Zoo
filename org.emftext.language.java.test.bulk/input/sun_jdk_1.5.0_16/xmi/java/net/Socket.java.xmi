<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:annotations="http://www.emftext.org/java/annotations" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/annotations ../../java.ecore#/0 http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="Socket.java">
  <comments>/*&#xA; * @(#)Socket.java&#x9;1.112 07/09/11&#xA; *&#xA; * Copyright 2007 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>net</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/OutputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/InterruptedIOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>channels</namespaces>
    <classifier xsi:type="classifiers:Class" href="../nio/channels/SocketChannel.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../security/PrivilegedExceptionAction.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../security/PrivilegedAction.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Socket">
    <members xsi:type="members:Field" name="created">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Various states of this socket.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="bound">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="connected">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="closed">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="closeLock">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="shutIn">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="shutOut">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="impl">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * The implementation of this Socket.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="SocketImpl.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="oldImpl">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Are we using an older SocketImpl?&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Socket">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.21"/>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an unconnected socket, with the&#xA;     * system-default type of SocketImpl.&#xA;     *&#xA;     * @since   JDK1.1&#xA;     * @revised 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Socket">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="security">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="epoint">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Proxy.class.xmi#//@classifiers.0/@members.6"/>
                  </next>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@variable"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="instantiations:NewConstructorCall">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.12"/>
                        </next>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.10"/>
                        </next>
                      </arguments>
                    </value>
                  </expression>
                </statement>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.14"/>
                  </next>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.0/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.37"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.12"/>
                        </next>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.10"/>
                        </next>
                      </arguments>
                    </next>
                  </expression>
                </statement>
                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.14"/>
                  </next>
                </condition>
                <elseStatement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.0/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.37"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@variable">
                        <next xsi:type="references:MethodCall">
                          <next xsi:type="references:MethodCall">
                            <target xsi:type="members:ClassMethod" href="InetAddress.class.xmi#//@classifiers.0/@members.35"/>
                          </next>
                          <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.11"/>
                        </next>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.1/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.10"/>
                        </next>
                      </arguments>
                    </next>
                  </expression>
                </elseStatement>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="SocksSocketImpl.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.26"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Proxy.class.xmi#//@classifiers.0/@members.5"/>
              </next>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:EnumConstant" href="Proxy$Type.class.xmi#//@classifiers.0/@constants.2"/>
                </next>
                <target xsi:type="classifiers:Enumeration" href="Proxy$Type.class.xmi#//@classifiers.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="Proxy.class.xmi#//@classifiers.0"/>
            </children>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="instantiations:NewConstructorCall">
                        <typeReference xsi:type="types:NamespaceClassifierReference">
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="PlainSocketImpl.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </typeReference>
                      </value>
                    </expression>
                  </statements>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.26"/>
                        <arguments xsi:type="references:SelfReference">
                          <self xsi:type="literals:This"/>
                        </arguments>
                      </next>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
                  <children xsi:type="literals:NullLiteral"/>
                </condition>
                <elseStatement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.21"/>
                </elseStatement>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Proxy.class.xmi#//@classifiers.0/@members.2"/>
                </next>
                <target xsi:type="classifiers:Class" href="Proxy.class.xmi#//@classifiers.0"/>
              </children>
            </condition>
            <elseStatement xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="Invalid Proxy"/>
              </throwable>
            </elseStatement>
          </statements>
        </elseStatement>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="proxy">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Proxy.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an unconnected socket, specifying the type of proxy, if any,&#xA;     * that should be used regardless of any other settings.&#xA;     * &lt;P>&#xA;     * If there is a security manager, its &lt;code>checkConnect&lt;/code> method&#xA;     * is called with the proxy host address and port number&#xA;     * as its arguments. This could result in a SecurityException.&#xA;     * &lt;P>&#xA;     * Examples: &#xA;     * &lt;UL> &lt;LI>&lt;code>Socket s = new Socket(Proxy.NO_PROXY);&lt;/code> will create&#xA;     * a plain socket ignoring any other proxy configuration.&lt;/LI>&#xA;     * &lt;LI>&lt;code>Socket s = new Socket(new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(&quot;socks.mydom.com&quot;, 1080)));&lt;/code>&#xA;     * will create a socket connecting through the specified SOCKS proxy&#xA;     * server.&lt;/LI>&#xA;     * &lt;/UL>&#xA;     *&#xA;     * @param proxy a {@link java.net.Proxy Proxy} object specifying what kind&#xA;     *&#x9;&#x9;    of proxying should be used.&#xA;     * @throws IllegalArgumentException if the proxy is of an invalid type &#xA;     *&#x9;&#x9;or &lt;code>null&lt;/code>.&#xA;     * @throws SecurityException if a security manager is present and&#xA;     *&#x9;&#x9;&#x9;&#x9; permission to connect to the proxy is&#xA;     *&#x9;&#x9;&#x9;&#x9; denied.&#xA;     * @see java.net.ProxySelector&#xA;     * @see java.net.Proxy&#xA;     *&#xA;     * @since   1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Socket">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.20"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.26"/>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                </next>
              </next>
              <self xsi:type="literals:This"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="impl">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SocketImpl.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Creates an unconnected Socket with a user-specified&#xA;     * SocketImpl.&#xA;     * &lt;P>&#xA;     * @param impl an instance of a &lt;B>SocketImpl&lt;/B>&#xA;     * the subclass wishes to use on the Socket.&#xA;     *&#xA;     * @exception SocketException if there is an error in the underlying protocol,     &#xA;     * such as a TCP error. &#xA;     * @since   JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Socket">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </child>
            <expressionIf xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
            </expressionIf>
            <expressionElse xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="InetAddress.class.xmi#//@classifiers.0/@members.43"/>
                  <arguments xsi:type="literals:NullLiteral"/>
                </next>
                <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
            </expressionElse>
          </arguments>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </arguments>
          <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="host">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="port">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="UnknownHostException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a stream socket and connects it to the specified port&#xA;     * number on the named host.&#xA;     * &lt;p>&#xA;     * If the specified host is &lt;tt>null&lt;/tt> it is the equivalent of&#xA;     * specifying the address as &lt;tt>{@link java.net.InetAddress#getByName InetAddress.getByName}(null)&lt;/tt>.&#xA;     * In other words, it is equivalent to specifying an address of the &#xA;     * loopback interface. &lt;/p>&#xA;     * &lt;p>&#xA;     * If the application has specified a server socket factory, that&#xA;     * factory's &lt;code>createSocketImpl&lt;/code> method is called to create&#xA;     * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.&#xA;     * &lt;p>&#xA;     * If there is a security manager, its&#xA;     * &lt;code>checkConnect&lt;/code> method is called&#xA;     * with the host address and &lt;code>port&lt;/code> &#xA;     * as its arguments. This could result in a SecurityException.&#xA;     *&#xA;     * @param      host   the host name, or &lt;code>null&lt;/code> for the loopback address.&#xA;     * @param      port   the port number.&#xA;     *&#xA;     * @exception  UnknownHostException if the IP address of &#xA;     * the host could not be determined.&#xA;     *&#xA;     * @exception  IOException  if an I/O error occurs when creating the socket.&#xA;     * @exception  SecurityException  if a security manager exists and its  &#xA;     *             &lt;code>checkConnect&lt;/code> method doesn't allow the operation.&#xA;     * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)&#xA;     * @see        java.net.SocketImpl&#xA;     * @see        java.net.SocketImplFactory#createSocketImpl()&#xA;     * @see        SecurityManager#checkConnect&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Socket">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </child>
            <expressionIf xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
            </expressionIf>
            <expressionElse xsi:type="literals:NullLiteral"/>
          </arguments>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </arguments>
          <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="address">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="port">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a stream socket and connects it to the specified port&#xA;     * number at the specified IP address.&#xA;     * &lt;p>&#xA;     * If the application has specified a socket factory, that factory's&#xA;     * &lt;code>createSocketImpl&lt;/code> method is called to create the&#xA;     * actual socket implementation. Otherwise a &quot;plain&quot; socket is created.&#xA;     * &lt;p>&#xA;     * If there is a security manager, its&#xA;     * &lt;code>checkConnect&lt;/code> method is called&#xA;     * with the host address and &lt;code>port&lt;/code> &#xA;     * as its arguments. This could result in a SecurityException.&#xA;     * &#xA;     * @param      address   the IP address.&#xA;     * @param      port      the port number.&#xA;     * @exception  IOException  if an I/O error occurs when creating the socket.&#xA;     * @exception  SecurityException  if a security manager exists and its  &#xA;     *             &lt;code>checkConnect&lt;/code> method doesn't allow the operation.&#xA;     * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)&#xA;     * @see        java.net.SocketImpl&#xA;     * @see        java.net.SocketImplFactory#createSocketImpl()&#xA;     * @see        SecurityManager#checkConnect&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Socket">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </child>
            <expressionIf xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
            </expressionIf>
            <expressionElse xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="InetAddress.class.xmi#//@classifiers.0/@members.43"/>
                  <arguments xsi:type="literals:NullLiteral"/>
                </next>
                <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
            </expressionElse>
          </arguments>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.3"/>
          </arguments>
          <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="host">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="port">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localAddr">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localPort">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a socket and connects it to the specified remote host on&#xA;     * the specified remote port. The Socket will also bind() to the local&#xA;     * address and port supplied.&#xA;     * &lt;p>&#xA;     * If the specified host is &lt;tt>null&lt;/tt> it is the equivalent of&#xA;     * specifying the address as &lt;tt>{@link java.net.InetAddress#getByName InetAddress.getByName}(null)&lt;/tt>.&#xA;     * In other words, it is equivalent to specifying an address of the &#xA;     * loopback interface. &lt;/p>&#xA;     * &lt;p>&#xA;     * If there is a security manager, its&#xA;     * &lt;code>checkConnect&lt;/code> method is called&#xA;     * with the host address and &lt;code>port&lt;/code> &#xA;     * as its arguments. This could result in a SecurityException.&#xA;     * &#xA;     * @param host the name of the remote host, or &lt;code>null&lt;/code> for the loopback address.&#xA;     * @param port the remote port&#xA;     * @param localAddr the local address the socket is bound to&#xA;     * @param localPort the local port the socket is bound to&#xA;     * @exception  IOException  if an I/O error occurs when creating the socket.&#xA;     * @exception  SecurityException  if a security manager exists and its  &#xA;     *             &lt;code>checkConnect&lt;/code> method doesn't allow the operation.&#xA;     * @see        SecurityManager#checkConnect&#xA;     * @since   JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Socket">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </child>
            <expressionIf xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
            </expressionIf>
            <expressionElse xsi:type="literals:NullLiteral"/>
          </arguments>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.3"/>
          </arguments>
          <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="address">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="port">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localAddr">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localPort">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a socket and connects it to the specified remote address on&#xA;     * the specified remote port. The Socket will also bind() to the local&#xA;     * address and port supplied.&#xA;     * &lt;p>&#xA;     * If there is a security manager, its&#xA;     * &lt;code>checkConnect&lt;/code> method is called&#xA;     * with the host address and &lt;code>port&lt;/code> &#xA;     * as its arguments. This could result in a SecurityException.&#xA;     * &#xA;     * @param address the remote address&#xA;     * @param port the remote port&#xA;     * @param localAddr the local address the socket is bound to&#xA;     * @param localPort the local port the socket is bound to&#xA;     * @exception  IOException  if an I/O error occurs when creating the socket.&#xA;     * @exception  SecurityException  if a security manager exists and its  &#xA;     *             &lt;code>checkConnect&lt;/code> method doesn't allow the operation.&#xA;     * @see        SecurityManager#checkConnect&#xA;     * @since   JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Socket">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </child>
            <expressionIf xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
            </expressionIf>
            <expressionElse xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="InetAddress.class.xmi#//@classifiers.0/@members.43"/>
                  <arguments xsi:type="literals:NullLiteral"/>
                </next>
                <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
            </expressionElse>
          </arguments>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="host">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="port">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="stream">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Creates a stream socket and connects it to the specified port&#xA;     * number on the named host.&#xA;     * &lt;p>&#xA;     * If the specified host is &lt;tt>null&lt;/tt> it is the equivalent of&#xA;     * specifying the address as &lt;tt>{@link java.net.InetAddress#getByName InetAddress.getByName}(null)&lt;/tt>.&#xA;     * In other words, it is equivalent to specifying an address of the &#xA;     * loopback interface. &lt;/p>&#xA;     * &lt;p>&#xA;     * If the stream argument is &lt;code>true&lt;/code>, this creates a&#xA;     * stream socket. If the stream argument is &lt;code>false&lt;/code>, it&#xA;     * creates a datagram socket.&#xA;     * &lt;p>&#xA;     * If the application has specified a server socket factory, that&#xA;     * factory's &lt;code>createSocketImpl&lt;/code> method is called to create&#xA;     * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.&#xA;     * &lt;p>&#xA;     * If there is a security manager, its&#xA;     * &lt;code>checkConnect&lt;/code> method is called&#xA;     * with the host address and &lt;code>port&lt;/code> &#xA;     * as its arguments. This could result in a SecurityException.&#xA;     * &lt;p>&#xA;     * If a UDP socket is used, TCP/IP related socket options will not apply.&#xA;     *&#xA;     * @param      host     the host name, or &lt;code>null&lt;/code> for the loopback address.&#xA;     * @param      port     the port number.&#xA;     * @param      stream   a &lt;code>boolean&lt;/code> indicating whether this is&#xA;     *                      a stream socket or a datagram socket.&#xA;     * @exception  IOException  if an I/O error occurs when creating the socket.&#xA;     * @exception  SecurityException  if a security manager exists and its  &#xA;     *             &lt;code>checkConnect&lt;/code> method doesn't allow the operation.&#xA;     * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)&#xA;     * @see        java.net.SocketImpl&#xA;     * @see        java.net.SocketImplFactory#createSocketImpl()&#xA;     * @see        SecurityManager#checkConnect&#xA;     * @deprecated Use DatagramSocket instead for UDP transport.&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="../lang/Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:Constructor" name="Socket">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </child>
            <expressionIf xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.1"/>
            </expressionIf>
            <expressionElse xsi:type="literals:NullLiteral"/>
          </arguments>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.2"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="host">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="port">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="stream">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Creates a socket and connects it to the specified port number at&#xA;     * the specified IP address.&#xA;     * &lt;p>&#xA;     * If the stream argument is &lt;code>true&lt;/code>, this creates a&#xA;     * stream socket. If the stream argument is &lt;code>false&lt;/code>, it&#xA;     * creates a datagram socket.&#xA;     * &lt;p>&#xA;     * If the application has specified a server socket factory, that&#xA;     * factory's &lt;code>createSocketImpl&lt;/code> method is called to create&#xA;     * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.&#xA;     * &#xA;     * &lt;p>If there is a security manager, its&#xA;     * &lt;code>checkConnect&lt;/code> method is called&#xA;     * with &lt;code>host.getHostAddress()&lt;/code> and &lt;code>port&lt;/code> &#xA;     * as its arguments. This could result in a SecurityException.&#xA;     * &lt;p>&#xA;     * If UDP socket is used, TCP/IP related socket options will not apply.&#xA;     *&#xA;     * @param      host     the IP address.&#xA;     * @param      port      the port number.&#xA;     * @param      stream    if &lt;code>true&lt;/code>, create a stream socket;&#xA;     *                       otherwise, create a datagram socket.&#xA;     * @exception  IOException  if an I/O error occurs when creating the socket.&#xA;     * @exception  SecurityException  if a security manager exists and its  &#xA;     *             &lt;code>checkConnect&lt;/code> method doesn't allow the operation.&#xA;     * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)&#xA;     * @see        java.net.SocketImpl&#xA;     * @see        java.net.SocketImplFactory#createSocketImpl()&#xA;     * @see        SecurityManager#checkConnect&#xA;     * @deprecated Use DatagramSocket instead for UDP transport.&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="../lang/Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
    </members>
    <members xsi:type="members:Constructor" name="Socket">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.21"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// backward compatibility</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.58"/>
          </statements>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.2/@catcheBlocks.0/@parameter"/>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="address">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SocketAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="localAddr">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SocketAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="stream">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:ClassMethod" name="createImpl">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Creates the socket implementation.&#xA;     *&#xA;     * @param stream a &lt;code>boolean&lt;/code> value : &lt;code>true&lt;/code> for a TCP socket,&#xA;     *&#x9;&#x9;     &lt;code>false&lt;/code> for UDP.&#xA;     * @throws IOException if creation fails&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="stream">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.21"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.7"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
            </next>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:BooleanLiteral" value="true"/>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@catcheBlocks.0/@parameter">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Throwable.class.xmi#//@classifiers.0/@members.9"/>
                </next>
              </arguments>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkOldImpl">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return"/>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="tmpBool">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// SocketImpl.connect() is a protected method, therefore we need to use</comments>
              <comments>// getDeclaredMethod, therefore we need permission to access the member</comments>
              <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../security/AccessController.class.xmi#//@classifiers.0/@members.1"/>
                <arguments xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Interface" href="../security/PrivilegedAction.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <anonymousClass>
                    <members xsi:type="members:ClassMethod" name="run">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <annotationsAndModifiers xsi:type="modifiers:Public"/>
                      <statements xsi:type="statements:LocalVariableStatement">
                        <variable name="cl">
                          <typeReference xsi:type="types:NamespaceClassifierReference">
                            <classifierReferences>
                              <target xsi:type="classifiers:Class" href="../lang/Class.class.xmi#//@classifiers.0"/>
                            </classifierReferences>
                          </typeReference>
                          <arrayDimensionsBefore/>
                          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
                            <typeReference xsi:type="types:NamespaceClassifierReference">
                              <classifierReferences>
                                <target xsi:type="classifiers:Class" href="../lang/Class.class.xmi#//@classifiers.0"/>
                              </classifierReferences>
                            </typeReference>
                            <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                          </initialValue>
                        </variable>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable/@initialValue/@child/@next/@arguments.0/@anonymousClass/@members.0/@statements.0/@variable">
                            <arraySelectors>
                              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                            </arraySelectors>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:IdentifierReference">
                            <next xsi:type="references:ReflectiveClassReference"/>
                            <target xsi:type="classifiers:Class" href="SocketAddress.class.xmi#//@classifiers.0"/>
                          </value>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:ExpressionStatement">
                        <expression xsi:type="expressions:AssignmentExpression">
                          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable/@initialValue/@child/@next/@arguments.0/@anonymousClass/@members.0/@statements.0/@variable">
                            <arraySelectors>
                              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                            </arraySelectors>
                          </child>
                          <assignmentOperator xsi:type="operators:Assignment"/>
                          <value xsi:type="references:IdentifierReference">
                            <next xsi:type="references:IdentifierReference">
                              <target xsi:type="members:Field" href="../lang/Integer.class.xmi#//@classifiers.0/@members.2"/>
                            </next>
                            <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                          </value>
                        </expression>
                      </statements>
                      <statements xsi:type="statements:LocalVariableStatement">
                        <variable name="clazz">
                          <typeReference xsi:type="types:NamespaceClassifierReference">
                            <classifierReferences>
                              <target xsi:type="classifiers:Class" href="../lang/Class.class.xmi#//@classifiers.0"/>
                            </classifierReferences>
                          </typeReference>
                          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
                            </next>
                          </initialValue>
                        </variable>
                      </statements>
                      <statements xsi:type="statements:WhileLoop">
                        <statement xsi:type="statements:Block">
                          <statements xsi:type="statements:TryBlock">
                            <statements xsi:type="statements:ExpressionStatement">
                              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable/@initialValue/@child/@next/@arguments.0/@anonymousClass/@members.0/@statements.3/@variable">
                                <next xsi:type="references:MethodCall">
                                  <target xsi:type="members:ClassMethod" href="../lang/Class.class.xmi#//@classifiers.0/@members.85"/>
                                  <arguments xsi:type="references:StringReference" value="connect"/>
                                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable/@initialValue/@child/@next/@arguments.0/@anonymousClass/@members.0/@statements.0/@variable"/>
                                </next>
                              </expression>
                            </statements>
                            <statements xsi:type="statements:Return">
                              <returnValue xsi:type="references:IdentifierReference">
                                <next xsi:type="references:IdentifierReference">
                                  <target xsi:type="members:Field" href="../lang/Boolean.class.xmi#//@classifiers.0/@members.1"/>
                                </next>
                                <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
                              </returnValue>
                            </statements>
                            <catcheBlocks>
                              <statements xsi:type="statements:ExpressionStatement">
                                <expression xsi:type="expressions:AssignmentExpression">
                                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable/@initialValue/@child/@next/@arguments.0/@anonymousClass/@members.0/@statements.3/@variable"/>
                                  <assignmentOperator xsi:type="operators:Assignment"/>
                                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable/@initialValue/@child/@next/@arguments.0/@anonymousClass/@members.0/@statements.3/@variable">
                                    <next xsi:type="references:MethodCall">
                                      <target xsi:type="members:ClassMethod" href="../lang/Class.class.xmi#//@classifiers.0/@members.49"/>
                                    </next>
                                  </value>
                                </expression>
                              </statements>
                              <statements xsi:type="statements:Condition">
                                <comments>// java.net.SocketImpl class will always have this abstract method. </comments>
                                <comments>// If we have not found it by now in the hierarchy then it does not </comments>
                                <comments>// exist, we are an old style impl. </comments>
                                <statement xsi:type="statements:Block">
                                  <statements xsi:type="statements:Return">
                                    <returnValue xsi:type="references:IdentifierReference">
                                      <next xsi:type="references:IdentifierReference">
                                        <target xsi:type="members:Field" href="../lang/Boolean.class.xmi#//@classifiers.0/@members.0"/>
                                      </next>
                                      <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
                                    </returnValue>
                                  </statements>
                                </statement>
                                <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable/@initialValue/@child/@next/@arguments.0/@anonymousClass/@members.0/@statements.3/@variable">
                                  <next xsi:type="references:MethodCall">
                                    <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.4"/>
                                    <arguments xsi:type="references:IdentifierReference">
                                      <next xsi:type="references:IdentifierReference">
                                        <next xsi:type="references:IdentifierReference">
                                          <next xsi:type="references:ReflectiveClassReference"/>
                                          <target xsi:type="classifiers:Class" href="SocketImpl.class.xmi#//@classifiers.0"/>
                                        </next>
                                      </next>
                                    </arguments>
                                  </next>
                                </condition>
                              </statements>
                              <parameter name="e">
                                <typeReference xsi:type="types:NamespaceClassifierReference">
                                  <classifierReferences>
                                    <target xsi:type="classifiers:Class" href="../lang/NoSuchMethodException.class.xmi#//@classifiers.0"/>
                                  </classifierReferences>
                                </typeReference>
                              </parameter>
                            </catcheBlocks>
                          </statements>
                        </statement>
                        <condition xsi:type="literals:BooleanLiteral" value="true"/>
                      </statements>
                    </members>
                  </anonymousClass>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Boolean.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setImpl">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Sets impl to the system-default type of SocketImpl.&#xA;     * @since 1.4&#xA;     */</comments>
      </typeReference>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="SocketImplFactory.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.20"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                <comments>// No need to do a checkOldImpl() here, we know it's an up to date</comments>
                <comments>// SocketImpl!</comments>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="SocksSocketImpl.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.26"/>
              <arguments xsi:type="references:SelfReference">
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getImpl">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Get the &lt;code>SocketImpl&lt;/code> attached to this socket, creating&#xA;     * it if necessary.&#xA;     *&#xA;     * @return&#x9;the &lt;code>SocketImpl&lt;/code> attached to that ServerSocket.&#xA;     * @throws SocketException if creation fails&#xA;     * @since 1.4&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="SocketImpl.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
            <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="connect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="endpoint">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SocketAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Connects this socket to the server.&#xA;     *&#xA;     * @param&#x9;endpoint the &lt;code>SocketAddress&lt;/code>&#xA;     * @throws&#x9;IOException if an error occurs during the connection&#xA;     * @throws  java.nio.channels.IllegalBlockingModeException&#xA;     *          if this socket has an associated channel,&#xA;     *          and the channel is in non-blocking mode&#xA;     * @throws  IllegalArgumentException if endpoint is null or is a&#xA;     *          SocketAddress subclass not supported by this socket&#xA;     * @since 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="connect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="endpoint">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SocketAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Connects this socket to the server with a specified timeout value.&#xA;     * A timeout of zero is interpreted as an infinite timeout. The connection&#xA;     * will then block until established or an error occurs.&#xA;     *&#xA;     * @param&#x9;endpoint the &lt;code>SocketAddress&lt;/code>&#xA;     * @param&#x9;timeout  the timeout value to be used in milliseconds.&#xA;     * @throws&#x9;IOException if an error occurs during the connection&#xA;     * @throws&#x9;SocketTimeoutException if timeout expires before connecting&#xA;     * @throws  java.nio.channels.IllegalBlockingModeException&#xA;     *          if this socket has an associated channel,&#xA;     *          and the channel is in non-blocking mode&#xA;     * @throws  IllegalArgumentException if endpoint is null or is a&#xA;     *          SocketAddress subclass not supported by this socket&#xA;     * @since 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="connect: The address can't be null"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="connect: timeout can't be negative"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="already connected"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          </children>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Unsupported address type"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="epoint">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.6/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.37"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.5/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.12"/>
                    </next>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.5/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.10"/>
                    </next>
                  </arguments>
                </next>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.5/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.14"/>
              </next>
            </condition>
            <elseStatement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.6/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.37"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.5/@variable">
                    <next xsi:type="references:MethodCall">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="InetAddress.class.xmi#//@classifiers.0/@members.35"/>
                      </next>
                      <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.11"/>
                    </next>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.5/@variable">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.10"/>
                    </next>
                  </arguments>
                </next>
              </expression>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.6/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
            <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.8"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.5/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
            </next>
          </expression>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.8"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.5/@variable">
                      <next xsi:type="references:MethodCall">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="InetAddress.class.xmi#//@classifiers.0/@members.30"/>
                        </next>
                        <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.11"/>
                      </next>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.5/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.10"/>
                      </next>
                    </arguments>
                  </next>
                </expression>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.5/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.14"/>
                </next>
              </condition>
              <elseStatement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.9"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.5/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.11"/>
                      </next>
                    </arguments>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.5/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.10"/>
                      </next>
                    </arguments>
                  </next>
                </expression>
              </elseStatement>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </condition>
          <elseStatement xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="SocketImpl.connect(addr, timeout)"/>
            </throwable>
          </elseStatement>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <comments>/*&#xA;&#x9; * If the socket was not bound before the connect, it is now because&#xA;&#x9; * the kernel will have picked an ephemeral port &amp; a local address&#xA;&#x9; */</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="bind">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bindpoint">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SocketAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Binds the socket to a local address.&#xA;     * &lt;P>&#xA;     * If the address is &lt;code>null&lt;/code>, then the system will pick up&#xA;     * an ephemeral port and a valid local address to bind the socket.&#xA;     *&#xA;     * @param&#x9;bindpoint the &lt;code>SocketAddress&lt;/code> to bind to&#xA;     * @throws&#x9;IOException if the bind operation fails, or if the socket&#xA;     *&#x9;&#x9;&#x9;   is already bound.&#xA;     * @throws  IllegalArgumentException if bindpoint is a&#xA;     *          SocketAddress subclass not supported by this socket&#xA;     *&#xA;     * @since&#x9;1.4&#xA;     * @see #isBound&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Already bound"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          </children>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Unsupported address type"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Negate"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:InstanceOfExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
                </expression>
              </child>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="epoint">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Unresolved address"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.3/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.3/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.14"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="InetAddress.class.xmi#//@classifiers.0/@members.57"/>
                </next>
                <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
              </arguments>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </next>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.3/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.11"/>
                </next>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.3/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="InetSocketAddress.class.xmi#//@classifiers.0/@members.10"/>
                </next>
              </arguments>
            </next>
          </expression>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="postAccept">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * set the flags after an accept() call.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setCreated">
      <typeReference xsi:type="types:Void"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setBound">
      <typeReference xsi:type="types:Void"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setConnected">
      <typeReference xsi:type="types:Void"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInetAddress">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the address to which the socket is connected.&#xA;     *&#xA;     * @return  the remote IP address to which this socket is connected,&#xA;     *&#x9;&#x9;or &lt;code>null&lt;/code> if the socket is not connected.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:NullLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
        </condition>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.21"/>
            </next>
          </returnValue>
        </statements>
        <catcheBlocks>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLocalAddress">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the local address to which the socket is bound.&#xA;     *&#xA;     * @return the local address to which the socket is bound or &#xA;     *&#x9;       &lt;code>InetAddress.anyLocalAddress()&lt;/code>&#xA;     *&#x9;       if the socket is not bound yet.&#xA;     * @since   JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// This is for backward compatibility</comments>
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="InetAddress.class.xmi#//@classifiers.0/@members.57"/>
            </next>
            <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="in">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.15"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                    <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
              </child>
            </value>
          </expression>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="InetAddress.class.xmi#//@classifiers.0/@members.57"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="InetAddress.class.xmi#//@classifiers.0/@members.19"/>
            </next>
          </condition>
        </statements>
        <catcheBlocks>
          <comments>// &quot;0.0.0.0&quot;</comments>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="InetAddress.class.xmi#//@classifiers.0/@members.57"/>
                </next>
                <target xsi:type="classifiers:Class" href="InetAddress.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Exception.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPort">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the remote port to which this socket is connected.&#xA;     *&#xA;     * @return  the remote port number to which this socket is connected, or&#xA;     *&#x9;        0 if the socket is not connected yet.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
        </condition>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </returnValue>
        </statements>
        <catcheBlocks>
          <comments>// Shouldn't happen as we're connected</comments>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLocalPort">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the local port to which this socket is bound.&#xA;     *&#xA;     * @return  the local port number to which this socket is bound or -1&#xA;     *&#x9;        if the socket is not bound yet.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
        </condition>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.25"/>
            </next>
          </returnValue>
        </statements>
        <catcheBlocks>
          <comments>// shouldn't happen as we're bound</comments>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getRemoteSocketAddress">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketAddress.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the address of the endpoint this socket is connected to, or&#xA;     * &lt;code>null&lt;/code> if it is unconnected.&#xA;     * @return a &lt;code>SocketAddress&lt;/code> reprensenting the remote endpoint of this&#xA;     *&#x9;       socket, or &lt;code>null&lt;/code> if it is not connected yet.&#xA;     * @see #getInetAddress()&#xA;     * @see #getPort()&#xA;     * @see #connect(SocketAddress, int)&#xA;     * @see #connect(SocketAddress)&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:NullLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.30"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.32"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLocalSocketAddress">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketAddress.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the address of the endpoint this socket is bound to, or&#xA;     * &lt;code>null&lt;/code> if it is not bound yet.&#xA;     *&#xA;     * @return a &lt;code>SocketAddress&lt;/code> representing the local endpoint of this&#xA;     *&#x9;       socket, or &lt;code>null&lt;/code> if it is not bound yet.&#xA;     * @see #getLocalAddress()&#xA;     * @see #getLocalPort()&#xA;     * @see #bind(SocketAddress)&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:NullLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.63"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="InetSocketAddress.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.31"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getChannel">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../nio/channels/SocketChannel.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the unique {@link java.nio.channels.SocketChannel SocketChannel}&#xA;     * object associated with this socket, if any.&#xA;     *&#xA;     * &lt;p> A socket will have a channel if, and only if, the channel itself was&#xA;     * created via the {@link java.nio.channels.SocketChannel#open&#xA;     * SocketChannel.open} or {@link&#xA;     * java.nio.channels.ServerSocketChannel#accept ServerSocketChannel.accept}&#xA;     * methods.&#xA;     *&#xA;     * @return  the socket channel associated with this socket,&#xA;     *          or &lt;tt>null&lt;/tt> if this socket was not created&#xA;     *          for a channel&#xA;     *&#xA;     * @since 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInputStream">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an input stream for this socket.&#xA;     *&#xA;     * &lt;p> If this socket has an associated channel then the resulting input&#xA;     * stream delegates all of its operations to the channel.  If the channel&#xA;     * is in non-blocking mode then the input stream's &lt;tt>read&lt;/tt> operations&#xA;     * will throw an {@link java.nio.channels.IllegalBlockingModeException}.&#xA;     *&#xA;     * &lt;p>Under abnormal conditions the underlying connection may be&#xA;     * broken by the remote host or the network software (for example&#xA;     * a connection reset in the case of TCP connections). When a&#xA;     * broken connection is detected by the network software the&#xA;     * following applies to the returned input stream :-&#xA;     *&#xA;     * &lt;ul>&#xA;     *&#xA;     *   &lt;li>&lt;p>The network software may discard bytes that are buffered&#xA;     *   by the socket. Bytes that aren't discarded by the network &#xA;     *   software can be read using {@link java.io.InputStream#read read}.&#xA;     *&#xA;     *   &lt;li>&lt;p>If there are no bytes buffered on the socket, or all&#xA;     *   buffered bytes have been consumed by  &#xA;     *   {@link java.io.InputStream#read read}, then all subsequent&#xA;     *   calls to {@link java.io.InputStream#read read} will throw an &#xA;     *   {@link java.io.IOException IOException}. &#xA;     *&#xA;     *   &lt;li>&lt;p>If there are no bytes buffered on the socket, and the&#xA;     *   socket has not been closed using {@link #close close}, then&#xA;     *   {@link java.io.InputStream#available available} will&#xA;     *   return &lt;code>0&lt;/code>.&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @return     an input stream for reading bytes from this socket.&#xA;     * @exception  IOException  if an I/O error occurs when creating the&#xA;     *             input stream, the socket is closed, the socket is&#xA;     *             not connected, or the socket input has been shutdown&#xA;     *             using {@link #shutdownInput()}&#xA;     *&#xA;     * @revised 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is not connected"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket input is shutdown"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.65"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </initialValue>
          <annotationsAndModifiers xsi:type="modifiers:Final"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="is">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.4/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../io/InputStream.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../security/AccessController.class.xmi#//@classifiers.0/@members.3"/>
                  <arguments xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Interface" href="../security/PrivilegedExceptionAction.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <anonymousClass>
                      <members xsi:type="members:ClassMethod" name="run">
                        <typeReference xsi:type="types:NamespaceClassifierReference">
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </typeReference>
                        <exceptions>
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </exceptions>
                        <annotationsAndModifiers xsi:type="modifiers:Public"/>
                        <statements xsi:type="statements:Return">
                          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.14"/>
                            </next>
                          </returnValue>
                        </statements>
                      </members>
                    </anonymousClass>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
              </child>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.5/@catcheBlocks.0/@parameter">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../security/PrivilegedActionException.class.xmi#//@classifiers.0/@members.3"/>
                </next>
              </child>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <namespaces>java</namespaces>
              <namespaces>security</namespaces>
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../security/PrivilegedActionException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.4/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getOutputStream">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/OutputStream.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an output stream for this socket.&#xA;     *&#xA;     * &lt;p> If this socket has an associated channel then the resulting output&#xA;     * stream delegates all of its operations to the channel.  If the channel&#xA;     * is in non-blocking mode then the output stream's &lt;tt>write&lt;/tt>&#xA;     * operations will throw an {@link&#xA;     * java.nio.channels.IllegalBlockingModeException}.&#xA;     *&#xA;     * @return     an output stream for writing bytes to this socket.&#xA;     * @exception  IOException  if an I/O error occurs when creating the&#xA;     *               output stream or if the socket is not connected.&#xA;     * @revised 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is not connected"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket output is shutdown"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.66"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </initialValue>
          <annotationsAndModifiers xsi:type="modifiers:Final"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="os">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../io/OutputStream.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.4/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../io/OutputStream.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../security/AccessController.class.xmi#//@classifiers.0/@members.3"/>
                  <arguments xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Interface" href="../security/PrivilegedExceptionAction.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <anonymousClass>
                      <members xsi:type="members:ClassMethod" name="run">
                        <typeReference xsi:type="types:NamespaceClassifierReference">
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </typeReference>
                        <exceptions>
                          <classifierReferences>
                            <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
                          </classifierReferences>
                        </exceptions>
                        <annotationsAndModifiers xsi:type="modifiers:Public"/>
                        <statements xsi:type="statements:Return">
                          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.15"/>
                            </next>
                          </returnValue>
                        </statements>
                      </members>
                    </anonymousClass>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
              </child>
            </value>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.5/@catcheBlocks.0/@parameter">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../security/PrivilegedActionException.class.xmi#//@classifiers.0/@members.3"/>
                </next>
              </child>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <namespaces>java</namespaces>
              <namespaces>security</namespaces>
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../security/PrivilegedActionException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.4/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setTcpNoDelay">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="on">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enable/disable TCP_NODELAY (disable/enable Nagle's algorithm).&#xA;     *&#xA;     * @param on &lt;code>true&lt;/code> to enable TCP_NODELAY, &#xA;     * &lt;code>false&lt;/code> to disable.&#xA;     *&#xA;     * @exception SocketException if there is an error &#xA;     * in the underlying protocol, such as a TCP error.&#xA;     * &#xA;     * @since   JDK1.1&#xA;     *&#xA;     * @see #getTcpNoDelay()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Boolean.class.xmi#//@classifiers.0/@members.9"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTcpNoDelay">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if TCP_NODELAY is enabled.&#xA;     *&#xA;     * @return a &lt;code>boolean&lt;/code> indicating whether or not TCP_NODELAY is enabled.&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     * @since   JDK1.1&#xA;     * @see #setTcpNoDelay(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Boolean.class.xmi#//@classifiers.0/@members.8"/>
          </next>
          <expression xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.15"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
            </child>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setSoLinger">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="on">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="linger">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enable/disable SO_LINGER with the specified linger time in seconds. &#xA;     * The maximum timeout value is platform specific.&#xA;     *&#xA;     * The setting only affects socket close.&#xA;     * &#xA;     * @param on     whether or not to linger on.&#xA;     * @param linger how long to linger for, if on is true.&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     * @exception IllegalArgumentException if the linger value is negative.&#xA;     * @since JDK1.1&#xA;     * @see #getSoLinger()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.14"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.8"/>
                  </next>
                  <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="invalid value for SO_LINGER"/>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="65535"/>
              </expression>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="65535"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.14"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.8"/>
                  </next>
                  <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.1"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSoLinger">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns setting for SO_LINGER. -1 returns implies that the&#xA;     * option is disabled.&#xA;     *&#xA;     * The setting only affects socket close.&#xA;     *&#xA;     * @return the setting for SO_LINGER.&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     * @since   JDK1.1&#xA;     * @see #setSoLinger(boolean, int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="o">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.15"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.8"/>
                </next>
                <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
              </arguments>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:NestedExpression">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.27"/>
              </next>
              <expression xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@variable"/>
              </expression>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.1/@variable"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="sendUrgentData">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Send one byte of urgent data on the socket. The byte to be sent is the lowest eight&#xA;     * bits of the data parameter. The urgent byte is&#xA;     * sent after any preceding writes to the socket OutputStream&#xA;     * and before any future writes to the OutputStream.&#xA;     * @param data The byte of data to send&#xA;     * @exception IOException if there is an error&#xA;     *  sending the data.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Urgent data not supported"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.23"/>
            </next>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.24"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setOOBInline">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="on">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enable/disable OOBINLINE (receipt of TCP urgent data)&#xA;     *&#xA;     * By default, this option is disabled and TCP urgent data received on a &#xA;     * socket is silently discarded. If the user wishes to receive urgent data, then&#xA;     * this option must be enabled. When enabled, urgent data is received&#xA;     * inline with normal data. &#xA;     * &lt;p>&#xA;     * Note, only limited support is provided for handling incoming urgent &#xA;     * data. In particular, no notification of incoming urgent data is provided &#xA;     * and there is no capability to distinguish between normal data and urgent&#xA;     * data unless provided by a higher level protocol.&#xA;     *&#xA;     * @param on &lt;code>true&lt;/code> to enable OOBINLINE, &#xA;     * &lt;code>false&lt;/code> to disable.&#xA;     *&#xA;     * @exception SocketException if there is an error &#xA;     * in the underlying protocol, such as a TCP error.&#xA;     * &#xA;     * @since   1.4&#xA;     *&#xA;     * @see #getOOBInline()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.13"/>
              </next>
              <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Boolean.class.xmi#//@classifiers.0/@members.9"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getOOBInline">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if OOBINLINE is enabled.&#xA;     *&#xA;     * @return a &lt;code>boolean&lt;/code> indicating whether or not OOBINLINE is enabled.&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     * @since   1.4&#xA;     * @see #setOOBInline(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Boolean.class.xmi#//@classifiers.0/@members.8"/>
          </next>
          <expression xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.15"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.13"/>
                  </next>
                  <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
            </child>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setSoTimeout">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Enable/disable SO_TIMEOUT with the specified timeout, in&#xA;     *  milliseconds.  With this option set to a non-zero timeout,&#xA;     *  a read() call on the InputStream associated with this Socket&#xA;     *  will block for only this amount of time.  If the timeout expires,&#xA;     *  a &lt;B>java.net.SocketTimeoutException&lt;/B> is raised, though the&#xA;     *  Socket is still valid. The option &lt;B>must&lt;/B> be enabled&#xA;     *  prior to entering the blocking operation to have effect. The&#xA;     *  timeout must be > 0.&#xA;     *  A timeout of zero is interpreted as an infinite timeout.&#xA;     * @param timeout the specified timeout, in milliseconds.&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     * @since   JDK 1.1&#xA;     * @see #getSoTimeout()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="timeout can't be negative"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.9"/>
              </next>
              <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSoTimeout">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns setting for SO_TIMEOUT.  0 returns implies that the&#xA;     * option is disabled (i.e., timeout of infinity).&#xA;     * @return the setting for SO_TIMEOUT&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     * @since   JDK1.1&#xA;     * @see #setSoTimeout(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="o">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.15"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.9"/>
                </next>
                <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
              </arguments>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>/* extra type safety */</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:NestedExpression">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.27"/>
              </next>
              <expression xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.1/@variable"/>
              </expression>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@statements.1/@variable"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setSendBufferSize">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="size">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the SO_SNDBUF option to the specified value for this&#xA;     * &lt;tt>Socket&lt;/tt>. The SO_SNDBUF option is used by the platform's&#xA;     * networking code as a hint for the size to set&#xA;     * the underlying network I/O buffers.&#xA;     *&#xA;     * &lt;p>Because SO_SNDBUF is a hint, applications that want to&#xA;     * verify what size the buffers were set to should call&#xA;     * {@link #getSendBufferSize()}.&#xA;     *&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     *&#xA;     * @param size the size to which to set the send buffer&#xA;     * size. This value must be greater than 0.&#xA;     *&#xA;     * @exception IllegalArgumentException if the &#xA;     * value is 0 or is negative.&#xA;     *&#xA;     * @see #getSendBufferSize()&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="negative send size"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.10"/>
              </next>
              <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSendBufferSize">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get value of the SO_SNDBUF option for this &lt;tt>Socket&lt;/tt>, &#xA;     * that is the buffer size used by the platform &#xA;     * for output on this &lt;tt>Socket&lt;/tt>.&#xA;     * @return the value of the SO_SNDBUF option for this &lt;tt>Socket&lt;/tt>.&#xA;     *&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     *&#xA;     * @see #setSendBufferSize(int)&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="o">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.15"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.10"/>
                </next>
                <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
              </arguments>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:NestedExpression">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.27"/>
                </next>
                <expression xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
                </expression>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setReceiveBufferSize">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="size">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the SO_RCVBUF option to the specified value for this&#xA;     * &lt;tt>Socket&lt;/tt>. The SO_RCVBUF option is used by the platform's&#xA;     * networking code as a hint for the size to set&#xA;     * the underlying network I/O buffers.&#xA;     *&#xA;     * &lt;p>Increasing the receive buffer size can increase the performance of&#xA;     * network I/O for high-volume connection, while decreasing it can&#xA;     * help reduce the backlog of incoming data. &#xA;     *&#xA;     * &lt;p>Because SO_RCVBUF is a hint, applications that want to&#xA;     * verify what size the buffers were set to should call&#xA;     * {@link #getReceiveBufferSize()}.&#xA;     *&#xA;     * &lt;p>The value of SO_RCVBUF is also used to set the TCP receive window&#xA;     * that is advertized to the remote peer. Generally, the window size&#xA;     * can be modified at any time when a socket is connected. However, if&#xA;     * a receive window larger than 64K is required then this must be requested&#xA;     * &lt;B>before&lt;/B> the socket is connected to the remote peer. There are two&#xA;     * cases to be aware of:&lt;p>&#xA;     * &lt;ol>&#xA;     * &lt;li>For sockets accepted from a ServerSocket, this must be done by calling&#xA;     * {@link ServerSocket#setReceiveBufferSize(int)} before the ServerSocket &#xA;     * is bound to a local address.&lt;p>&lt;/li>&#xA;     * &lt;li>For client sockets, setReceiveBufferSize() must be called before&#xA;     * connecting the socket to its remote peer.&lt;p>&lt;/li>&lt;/ol>&#xA;     * @param size the size to which to set the receive buffer&#xA;     * size. This value must be greater than 0.&#xA;     *&#xA;     * @exception IllegalArgumentException if the value is 0 or is&#xA;     * negative.&#xA;     *&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error.&#xA;     * &#xA;     * @see #getReceiveBufferSize()&#xA;     * @see ServerSocket#setReceiveBufferSize(int)&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="invalid receive size"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.11"/>
              </next>
              <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getReceiveBufferSize">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the value of the SO_RCVBUF option for this &lt;tt>Socket&lt;/tt>, &#xA;     * that is the buffer size used by the platform for &#xA;     * input on this &lt;tt>Socket&lt;/tt>.&#xA;     *&#xA;     * @return the value of the SO_RCVBUF option for this &lt;tt>Socket&lt;/tt>.&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     * @see #setReceiveBufferSize(int)&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="result">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="o">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.15"/>
              <arguments xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.11"/>
                </next>
                <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
              </arguments>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:NestedExpression">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.27"/>
                </next>
                <expression xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@statements.2/@variable"/>
                </expression>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@statements.2/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setKeepAlive">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="on">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enable/disable SO_KEEPALIVE.&#xA;     * &#xA;     * @param on     whether or not to have socket keep alive turned on.&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     * @since 1.3 &#xA;     * @see #getKeepAlive()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.12"/>
              </next>
              <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Boolean.class.xmi#//@classifiers.0/@members.9"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getKeepAlive">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if SO_KEEPALIVE is enabled.&#xA;     *&#xA;     * @return a &lt;code>boolean&lt;/code> indicating whether or not SO_KEEPALIVE is enabled.&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     * @since   1.3&#xA;     * @see #setKeepAlive(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Boolean.class.xmi#//@classifiers.0/@members.8"/>
          </next>
          <expression xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.15"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.12"/>
                  </next>
                  <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
            </child>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setTrafficClass">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tc">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets traffic class or type-of-service octet in the IP&#xA;     * header for packets sent from this Socket.&#xA;     * As the underlying network implementation may ignore this&#xA;     * value applications should consider it a hint.&#xA;     *&#xA;     * &lt;P> The tc &lt;B>must&lt;/B> be in the range &lt;code> 0 &lt;= tc &lt;=&#xA;     * 255&lt;/code> or an IllegalArgumentException will be thrown.&#xA;     * &lt;p>Notes:&#xA;     * &lt;p> for Internet Protocol v4 the value consists of an octet&#xA;     * with precedence and TOS fields as detailed in RFC 1349. The&#xA;     * TOS field is bitset created by bitwise-or'ing values such&#xA;     * the following :-&#xA;     * &lt;p>&#xA;     * &lt;UL>&#xA;     * &lt;LI>&lt;CODE>IPTOS_LOWCOST (0x02)&lt;/CODE>&lt;/LI>&#xA;     * &lt;LI>&lt;CODE>IPTOS_RELIABILITY (0x04)&lt;/CODE>&lt;/LI>&#xA;     * &lt;LI>&lt;CODE>IPTOS_THROUGHPUT (0x08)&lt;/CODE>&lt;/LI>&#xA;     * &lt;LI>&lt;CODE>IPTOS_LOWDELAY (0x10)&lt;/CODE>&lt;/LI>&#xA;     * &lt;/UL>&#xA;     * The last low order bit is always ignored as this&#xA;     * corresponds to the MBZ (must be zero) bit.&#xA;     * &lt;p>&#xA;     * Setting bits in the precedence field may result in a&#xA;     * SocketException indicating that the operation is not&#xA;     * permitted.&#xA;     * &lt;p>&#xA;     * for Internet Protocol v6 &lt;code>tc&lt;/code> is the value that&#xA;     * would be placed into the sin6_flowinfo field of the IP header.&#xA;     *&#xA;     * @param tc        an &lt;code>int&lt;/code> value for the bitset.&#xA;     * @throws SocketException if there is an error setting the&#xA;     * traffic class or type-of-service&#xA;     * @since 1.4&#xA;     * @see #getTrafficClass&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="tc is not in range 0 -- 255"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="255"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.7"/>
              </next>
              <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTrafficClass">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets traffic class or type-of-service in the IP header&#xA;     * for packets sent from this Socket&#xA;     * &lt;p>&#xA;     * As the underlying network implementation may ignore the&#xA;     * traffic class or type-of-service set using {@link #setTrafficClass(int)}&#xA;     * this method may return a different value than was previously&#xA;     * set using the {@link #setTrafficClass(int)} method on this Socket.&#xA;     *&#xA;     * @return the traffic class or type-of-service already set&#xA;     * @throws SocketException if there is an error obtaining the&#xA;     * traffic class or type-of-service value.&#xA;     * @since 1.4&#xA;     * @see #setTrafficClass(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.27"/>
          </next>
          <expression xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.15"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.7"/>
                    </next>
                    <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
              </expression>
            </child>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setReuseAddress">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="on">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enable/disable the SO_REUSEADDR socket option.&#xA;     * &lt;p>&#xA;     * When a TCP connection is closed the connection may remain&#xA;     * in a timeout state for a period of time after the connection&#xA;     * is closed (typically known as the &lt;tt>TIME_WAIT&lt;/tt> state&#xA;     * or &lt;tt>2MSL&lt;/tt> wait state).&#xA;     * For applications using a well known socket address or port &#xA;     * it may not be possible to bind a socket to the required&#xA;     * &lt;tt>SocketAddress&lt;/tt> if there is a connection in the&#xA;     * timeout state involving the socket address or port.&#xA;     * &lt;p>&#xA;     * Enabling &lt;tt>SO_REUSEADDR&lt;/tt> prior to binding the socket&#xA;     * using {@link #bind(SocketAddress)} allows the socket to be&#xA;     * bound even though a previous connection is in a timeout&#xA;     * state.&#xA;     * &lt;p>&#xA;     * When a &lt;tt>Socket&lt;/tt> is created the initial setting&#xA;     * of &lt;tt>SO_REUSEADDR&lt;/tt> is disabled.&#xA;     * &lt;p>&#xA;     * The behaviour when &lt;tt>SO_REUSEADDR&lt;/tt> is enabled or&#xA;     * disabled after a socket is bound (See {@link #isBound()})&#xA;     * is not defined.&#xA;     * &#xA;     * @param on  whether to enable or disable the socket option&#xA;     * @exception SocketException if an error occurs enabling or&#xA;     *            disabling the &lt;tt>SO_RESUEADDR&lt;/tt> socket option,&#xA;     *&#x9;&#x9;  or the socket is closed.&#xA;     * @since 1.4&#xA;     * @see #getReuseAddress()     &#xA;     * @see #bind(SocketAddress)&#xA;     * @see #isClosed()&#xA;     * @see #isBound()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.2"/>
              </next>
              <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Boolean.class.xmi#//@classifiers.0/@members.9"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getReuseAddress">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if SO_REUSEADDR is enabled.&#xA;     *&#xA;     * @return a &lt;code>boolean&lt;/code> indicating whether or not SO_REUSEADDR is enabled.&#xA;     * @exception SocketException if there is an error&#xA;     * in the underlying protocol, such as a TCP error. &#xA;     * @since   1.4&#xA;     * @see #setReuseAddress(boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Boolean.class.xmi#//@classifiers.0/@members.8"/>
          </next>
          <expression xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/Boolean.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="SocketOptions.class.xmi#//@classifiers.0/@members.15"/>
                  <arguments xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="SocketOptions.class.xmi#//@classifiers.0/@members.2"/>
                    </next>
                    <target xsi:type="classifiers:Interface" href="SocketOptions.class.xmi#//@classifiers.0"/>
                  </arguments>
                </next>
              </expression>
            </child>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="close">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Closes this socket.&#xA;     * &lt;p>&#xA;     * Any thread currently blocked in an I/O operation upon this socket&#xA;     * will throw a {@link SocketException}.&#xA;     * &lt;p>&#xA;     * Once a socket has been closed, it is not available for further networking&#xA;     * use (i.e. can't be reconnected or rebound). A new socket needs to be&#xA;     * created.&#xA;     *&#xA;     * &lt;p> If this socket has an associated channel then the channel is closed&#xA;     * as well.&#xA;     *&#xA;     * @exception  IOException  if an I/O error occurs when closing this socket.&#xA;     * @revised 1.4&#xA;     * @spec JSR-51&#xA;     * @see #isClosed&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return"/>
          <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.17"/>
              </next>
            </expression>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="literals:BooleanLiteral" value="true"/>
          </expression>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="shutdownInput">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Places the input stream for this socket at &quot;end of stream&quot;.&#xA;     * Any data sent to the input stream side of the socket is acknowledged&#xA;     * and then silently discarded.&#xA;     * &lt;p>&#xA;     * If you read from a socket input stream after invoking &#xA;     * shutdownInput() on the socket, the stream will return EOF.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs when shutting down this&#xA;     * socket.&#xA;     *&#xA;     * @since 1.3&#xA;     * @see java.net.Socket#shutdownOutput()&#xA;     * @see java.net.Socket#close()&#xA;     * @see java.net.Socket#setSoLinger(boolean, int)&#xA;     * @see #isInputShutdown&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is not connected"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket input is already shutdown"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.65"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.18"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="shutdownOutput">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Disables the output stream for this socket.&#xA;     * For a TCP socket, any previously written data will be sent&#xA;     * followed by TCP's normal connection termination sequence.&#xA;     *&#xA;     * If you write to a socket output stream after invoking &#xA;     * shutdownOutput() on the socket, the stream will throw &#xA;     * an IOException.&#xA;     *&#xA;     * @exception IOException if an I/O error occurs when shutting down this&#xA;     * socket.&#xA;     *&#xA;     * @since 1.3&#xA;     * @see java.net.Socket#shutdownInput()&#xA;     * @see java.net.Socket#close()&#xA;     * @see java.net.Socket#setSoLinger(boolean, int)&#xA;     * @see #isOutputShutdown&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is closed"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.64"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket is not connected"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Socket output is already shutdown"/>
          </throwable>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.66"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.19"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this socket to a &lt;code>String&lt;/code>.&#xA;     *&#xA;     * @return  a string representation of this socket.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Return">
            <returnValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Socket[addr="/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.21"/>
                </next>
              </children>
              <children xsi:type="references:StringReference" value=",port="/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.22"/>
                </next>
              </children>
              <children xsi:type="references:StringReference" value=",localport="/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="SocketImpl.class.xmi#//@classifiers.0/@members.25"/>
                </next>
              </children>
              <children xsi:type="references:StringReference" value="]"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </returnValue>
          </statement>
          <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.62"/>
        </statements>
        <catcheBlocks>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:StringReference" value="Socket[unconnected]"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isConnected">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the connection state of the socket.&#xA;     *&#xA;     * @return true if the socket successfuly connected to a server&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// Before 1.3 Sockets were always connected during creation</comments>
        <returnValue xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isBound">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the binding state of the socket.&#xA;     *&#xA;     * @return true if the socket successfuly bound to an address&#xA;     * @since 1.4&#xA;     * @see #bind&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// Before 1.3 Sockets were always bound during creation</comments>
        <returnValue xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isClosed">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the closed state of the socket.&#xA;     *&#xA;     * @return true if the socket has been closed&#xA;     * @since 1.4&#xA;     * @see #close&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isInputShutdown">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns whether the read-half of the socket connection is closed.&#xA;     *&#xA;     * @return true if the input of the socket has been shutdown&#xA;     * @since 1.4&#xA;     * @see #shutdownInput&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isOutputShutdown">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns whether the write-half of the socket connection is closed.&#xA;     *&#xA;     * @return true if the output of the socket has been shutdown&#xA;     * @since 1.4&#xA;     * @see #shutdownOutput&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
      </statements>
    </members>
    <members xsi:type="members:Field" name="factory">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="SocketImplFactory.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The factory for all client sockets.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="setSocketImplFactory">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fac">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="SocketImplFactory.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the client socket implementation factory for the&#xA;     * application. The factory can be specified only once.&#xA;     * &lt;p>&#xA;     * When an application creates a new client socket, the socket&#xA;     * implementation factory's &lt;code>createSocketImpl&lt;/code> method is&#xA;     * called to create the actual socket implementation.&#xA;     * &lt;p>&#xA;     * Passing &lt;code>null&lt;/code> to the method is a no-op unless the factory&#xA;     * was already set.&#xA;     * &lt;p>If there is a security manager, this method first calls&#xA;     * the security manager's &lt;code>checkSetFactory&lt;/code> method &#xA;     * to ensure the operation is allowed. &#xA;     * This could result in a SecurityException.&#xA;     *&#xA;     * @param      fac   the desired factory.&#xA;     * @exception  IOException  if an I/O error occurs when setting the&#xA;     *               socket factory.&#xA;     * @exception  SocketException  if the factory is already defined.&#xA;     * @exception  SecurityException  if a security manager exists and its  &#xA;     *             &lt;code>checkSetFactory&lt;/code> method doesn't allow the operation.&#xA;     * @see        java.net.SocketImplFactory#createSocketImpl()&#xA;     * @see        SecurityManager#checkSetFactory&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="SocketException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="factory already defined"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.52"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@statements.1/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.67"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.68/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setPerformancePreferences">
      <comments>/* Not implemented yet */</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="connectionTime">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="latency">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bandwidth">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets performance preferences for this socket.&#xA;     *&#xA;     * &lt;p> Sockets use the TCP/IP protocol by default.  Some implementations&#xA;     * may offer alternative protocols which have different performance&#xA;     * characteristics than TCP/IP.  This method allows the application to&#xA;     * express its own preferences as to how these tradeoffs should be made&#xA;     * when the implementation chooses from the available protocols.&#xA;     *&#xA;     * &lt;p> Performance preferences are described by three integers&#xA;     * whose values indicate the relative importance of short connection time,&#xA;     * low latency, and high bandwidth.  The absolute values of the integers&#xA;     * are irrelevant; in order to choose a protocol the values are simply&#xA;     * compared, with larger values indicating stronger preferences. Negative&#xA;     * values represent a lower priority than positive values. If the&#xA;     * application prefers short connection time over both low latency and high&#xA;     * bandwidth, for example, then it could invoke this method with the values&#xA;     * &lt;tt>(1, 0, 0)&lt;/tt>.  If the application prefers high bandwidth above low&#xA;     * latency, and low latency above short connection time, then it could&#xA;     * invoke this method with the values &lt;tt>(0, 1, 2)&lt;/tt>.&#xA;     *&#xA;     * &lt;p> Invoking this method after this socket has been connected&#xA;     * will have no effect.&#xA;     *&#xA;     * @param  connectionTime&#xA;     *         An &lt;tt>int&lt;/tt> expressing the relative importance of a short&#xA;     *         connection time&#xA;     *&#xA;     * @param  latency&#xA;     *         An &lt;tt>int&lt;/tt> expressing the relative importance of low&#xA;     *         latency&#xA;     *&#xA;     * @param  bandwidth&#xA;     *         An &lt;tt>int&lt;/tt> expressing the relative importance of high&#xA;     *         bandwidth&#xA;     *  &#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This class implements client sockets (also called just&#xA; * &quot;sockets&quot;). A socket is an endpoint for communication&#xA; * between two machines.&#xA; * &lt;p>&#xA; * The actual work of the socket is performed by an instance of the&#xA; * &lt;code>SocketImpl&lt;/code> class. An application, by changing&#xA; * the socket factory that creates the socket implementation,&#xA; * can configure itself to create sockets appropriate to the local&#xA; * firewall.&#xA; *&#xA; * @author  unascribed&#xA; * @version 1.112, 09/11/07&#xA; * @see     java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)&#xA; * @see     java.net.SocketImpl&#xA; * @see     java.nio.channels.SocketChannel&#xA; * @since   JDK1.0&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
