<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="Selector.java">
  <comments>/*&#xA; * @(#)Selector.java&#x9;1.37 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>nio</namespaces>
  <namespaces>channels</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>channels</namespaces>
    <namespaces>spi</namespaces>
    <classifier xsi:type="classifiers:Class" href="spi/SelectorProvider.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../util/Set.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Selector">
    <members xsi:type="members:Constructor" name="Selector">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Initializes a new instance of this class.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="open">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Opens a selector.&#xA;     *&#xA;     * &lt;p> The new selector is created by invoking the {@link&#xA;     * java.nio.channels.spi.SelectorProvider#openSelector openSelector} method&#xA;     * of the system-wide default {@link&#xA;     * java.nio.channels.spi.SelectorProvider} object.  &lt;/p>&#xA;     *&#xA;     * @return  A new selector&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If an I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="spi/SelectorProvider.class.xmi#//@classifiers.0/@members.8"/>
            </next>
            <target xsi:type="members:ClassMethod" href="spi/SelectorProvider.class.xmi#//@classifiers.0/@members.5"/>
          </next>
          <target xsi:type="classifiers:Class" href="spi/SelectorProvider.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isOpen">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tells whether or not this selector is open.  &lt;/p>&#xA;     *&#xA;     * @return &lt;tt>true&lt;/tt> if, and only if, this selector is open&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="provider">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="spi/SelectorProvider.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the provider that created this channel.  &lt;/p>&#xA;     *&#xA;     * @return  The provider that created this channel&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="keys">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SelectionKey.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Set.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns this selector's key set.&#xA;     *&#xA;     * &lt;p> The key set is not directly modifiable.  A key is removed only after&#xA;     * it has been cancelled and its channel has been deregistered.  Any&#xA;     * attempt to modify the key set will cause an {@link&#xA;     * UnsupportedOperationException} to be thrown.&#xA;     *&#xA;     * &lt;p> The key set is &lt;a href=&quot;#ksc&quot;>not thread-safe&lt;/a>. &lt;/p>&#xA;     *&#xA;     * @return  This selector's key set&#xA;     *&#xA;     * @throws  ClosedSelectorException&#xA;     *          If this selector is closed&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="selectedKeys">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SelectionKey.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Set.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns this selector's selected-key set.&#xA;     *&#xA;     * &lt;p> Keys may be removed from, but not directly added to, the&#xA;     * selected-key set.  Any attempt to add an object to the key set will&#xA;     * cause an {@link UnsupportedOperationException} to be thrown.&#xA;     *&#xA;     * &lt;p> The selected-key set is &lt;a href=&quot;#ksc&quot;>not thread-safe&lt;/a>. &lt;/p>&#xA;     *&#xA;     * @return  This selector's selected-key set&#xA;     *&#xA;     * @throws  ClosedSelectorException&#xA;     *          If this selector is closed&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="selectNow">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Selects a set of keys whose corresponding channels are ready for I/O&#xA;     * operations.&#xA;     *&#xA;     * &lt;p> This method performs a non-blocking &lt;a href=&quot;#selop&quot;>selection&#xA;     * operation&lt;/a>.  If no channels have become selectable since the previous&#xA;     * selection operation then this method immediately returns zero.&#xA;     *&#xA;     * &lt;p> Invoking this method clears the effect of any previous invocations&#xA;     * of the {@link #wakeup wakeup} method.  &lt;/p>&#xA;     *&#xA;     * @return  The number of keys, possibly zero, whose ready-operation sets&#xA;     *          were updated by the selection operation&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If an I/O error occurs&#xA;     *&#xA;     * @throws  ClosedSelectorException&#xA;     *          If this selector is closed&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="select">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="timeout">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Selects a set of keys whose corresponding channels are ready for I/O&#xA;     * operations.&#xA;     *&#xA;     * &lt;p> This method performs a blocking &lt;a href=&quot;#selop&quot;>selection&#xA;     * operation&lt;/a>.  It returns only after at least one channel is selected,&#xA;     * this selector's {@link #wakeup wakeup} method is invoked, the current&#xA;     * thread is interrupted, or the given timeout period expires, whichever&#xA;     * comes first.&#xA;     *&#xA;     * &lt;p> This method does not offer real-time guarantees: It schedules the&#xA;     * timeout as if by invoking the {@link Object#wait(long)} method. &lt;/p>&#xA;     *&#xA;     * @param  timeout  If positive, block for up to &lt;tt>timeout&lt;/tt>&#xA;     *                  milliseconds, more or less, while waiting for a&#xA;     *                  channel to become ready; if zero, block indefinitely;&#xA;     *                  must not be negative&#xA;     *&#xA;     * @return  The number of keys, possibly zero,&#xA;     *          whose ready-operation sets were updated&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If an I/O error occurs&#xA;     *&#xA;     * @throws  ClosedSelectorException&#xA;     *          If this selector is closed&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the value of the timeout argument is negative&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="select">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Selects a set of keys whose corresponding channels are ready for I/O&#xA;     * operations.&#xA;     *&#xA;     * &lt;p> This method performs a blocking &lt;a href=&quot;#selop&quot;>selection&#xA;     * operation&lt;/a>.  It returns only after at least one channel is selected,&#xA;     * this selector's {@link #wakeup wakeup} method is invoked, or the current&#xA;     * thread is interrupted, whichever comes first.  &lt;/p>&#xA;     *&#xA;     * @return  The number of keys, possibly zero,&#xA;     *          whose ready-operation sets were updated&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If an I/O error occurs&#xA;     *&#xA;     * @throws  ClosedSelectorException&#xA;     *          If this selector is closed&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="wakeup">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Causes the first selection operation that has not yet returned to return&#xA;     * immediately.&#xA;     *&#xA;     * &lt;p> If another thread is currently blocked in an invocation of the&#xA;     * {@link #select()} or {@link #select(long)} methods then that invocation&#xA;     * will return immediately.  If no selection operation is currently in&#xA;     * progress then the next invocation of one of these methods will return&#xA;     * immediately unless the {@link #selectNow()} method is invoked in the&#xA;     * meantime.  In any case the value returned by that invocation may be&#xA;     * non-zero.  Subsequent invocations of the {@link #select()} or {@link&#xA;     * #select(long)} methods will block as usual unless this method is invoked&#xA;     * again in the meantime.&#xA;     *&#xA;     * &lt;p> Invoking this method more than once between two successive selection&#xA;     * operations has the same effect as invoking it just once.  &lt;/p>&#xA;     *&#xA;     * @return  This selector&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="close">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Closes this selector.&#xA;     *&#xA;     * &lt;p> If a thread is currently blocked in one of this selector's selection&#xA;     * methods then it is interrupted as if by invoking the selector's {@link&#xA;     * #wakeup wakeup} method.&#xA;     *&#xA;     * &lt;p> Any uncancelled keys still associated with this selector are&#xA;     * invalidated, their channels are deregistered, and any other resources&#xA;     * associated with this selector are released.&#xA;     *&#xA;     * &lt;p> If this selector is already closed then invoking this method has no&#xA;     * effect.&#xA;     *&#xA;     * &lt;p> After a selector is closed, any further attempt to use it, except by&#xA;     * invoking this method or the {@link #wakeup wakeup} method, will cause a&#xA;     * {@link ClosedSelectorException} to be thrown. &lt;/p>&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If an I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A multiplexor of {@link SelectableChannel} objects.&#xA; *&#xA; * &lt;p> A selector may be created by invoking the {@link #open open} method of&#xA; * this class, which will use the system's default {@link&#xA; * java.nio.channels.spi.SelectorProvider &lt;/code>selector provider&lt;code>} to&#xA; * create a new selector.  A selector may also be created by invoking the&#xA; * {@link java.nio.channels.spi.SelectorProvider#openSelector openSelector}&#xA; * method of a custom selector provider.  A selector remains open until it is&#xA; * closed via its {@link #close close} method.&#xA; *&#xA; * &lt;a name=&quot;ks&quot;>&#xA; *&#xA; * &lt;p> A selectable channel's registration with a selector is represented by a&#xA; * {@link SelectionKey} object.  A selector maintains three sets of selection&#xA; * keys:&#xA; *&#xA; * &lt;ul>&#xA; *&#xA; *   &lt;li>&lt;p> The &lt;i>key set&lt;/i> contains the keys representing the current&#xA; *   channel registrations of this selector.  This set is returned by the&#xA; *   {@link #keys() keys} method. &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> The &lt;i>selected-key set&lt;/i> is the set of keys such that each&#xA; *   key's channel was detected to be ready for at least one of the operations&#xA; *   identified in the key's interest set during a prior selection operation.&#xA; *   This set is returned by the {@link #selectedKeys() selectedKeys} method.&#xA; *   The selected-key set is always a subset of the key set. &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> The &lt;i>cancelled-key&lt;/i> set is the set of keys that have been&#xA; *   cancelled but whose channels have not yet been deregistered.  This set is&#xA; *   not directly accessible.  The cancelled-key set is always a subset of the&#xA; *   key set. &lt;/p>&lt;/li>&#xA; *&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p> All three sets are empty in a newly-created selector.&#xA; *&#xA; * &lt;p> A key is added to a selector's key set as a side effect of registering a&#xA; * channel via the channel's {@link SelectableChannel#register(Selector,int)&#xA; * register} method.  Cancelled keys are removed from the key set during&#xA; * selection operations.  The key set itself is not directly modifiable.&#xA; *&#xA; * &lt;p> A key is added to its selector's cancelled-key set when it is cancelled,&#xA; * whether by closing its channel or by invoking its {@link SelectionKey#cancel&#xA; * cancel} method.  Cancelling a key will cause its channel to be deregistered&#xA; * during the next selection operation, at which time the key will removed from&#xA; * all of the selector's key sets.&#xA; *&#xA; * &lt;a name=&quot;sks&quot;>&lt;p> Keys are added to the selected-key set by selection&#xA; * operations.  A key may be removed directly from the selected-key set by&#xA; * invoking the set's {@link java.util.Set#remove(java.lang.Object) remove}&#xA; * method or by invoking the {@link java.util.Iterator#remove() remove} method&#xA; * of an {@link java.util.Iterator &lt;/code>iterator&lt;code>} obtained from the&#xA; * set.  Keys are never removed from the selected-key set in any other way;&#xA; * they are not, in particular, removed as a side effect of selection&#xA; * operations.  Keys may not be added directly to the selected-key set. &lt;/p>&#xA; *&#xA; *&#xA; * &lt;a name=&quot;selop&quot;>&#xA; * &lt;h4>Selection&lt;/h4>&#xA; *&#xA; * &lt;p> During each selection operation, keys may be added to and removed from a&#xA; * selector's selected-key set and may be removed from its key and&#xA; * cancelled-key sets.  Selection is performed by the {@link #select()}, {@link&#xA; * #select(long)}, and {@link #selectNow()} methods, and involves three steps:&#xA; * &lt;/p>&#xA; *&#xA; * &lt;ol>&#xA; *&#xA; *   &lt;li>&lt;p> Each key in the cancelled-key set is removed from each key set of&#xA; *   which it is a member, and its channel is deregistered.  This step leaves&#xA; *   the cancelled-key set empty. &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> The underlying operating system is queried for an update as to the&#xA; *   readiness of each remaining channel to perform any of the operations&#xA; *   identified by its key's interest set as of the moment that the selection&#xA; *   operation began.  For a channel that is ready for at least one such&#xA; *   operation, one of the following two actions is performed: &lt;/p>&#xA; *&#xA; *   &lt;ol type=a>&#xA; *&#xA; *     &lt;li>&lt;p> If the channel's key is not already in the selected-key set then&#xA; *     it is added to that set and its ready-operation set is modified to&#xA; *     identify exactly those operations for which the channel is now reported&#xA; *     to be ready.  Any readiness information previously recorded in the ready&#xA; *     set is discarded.  &lt;/p>&lt;/li>&#xA; *&#xA; *     &lt;li>&lt;p> Otherwise the channel's key is already in the selected-key set,&#xA; *     so its ready-operation set is modified to identify any new operations&#xA; *     for which the channel is reported to be ready.  Any readiness&#xA; *     information previously recorded in the ready set is preserved; in other&#xA; *     words, the ready set returned by the underlying system is&#xA; *     bitwise-disjoined into the key's current ready set. &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;/ol>&lt;/li>&#xA; *&#xA; *   If all of the keys in the key set at the start of this step have empty&#xA; *   interest sets then neither the selected-key set nor any of the keys'&#xA; *   ready-operation sets will be updated.&#xA; *&#xA; *   &lt;li>&lt;p> If any keys were added to the cancelled-key set while step (2) was&#xA; *   in progress then they are processed as in step (1). &lt;/p>&lt;/li>&#xA; *&#xA; * &lt;/ol>&#xA; *&#xA; * &lt;p> Whether or not a selection operation blocks to wait for one or more&#xA; * channels to become ready, and if so for how long, is the only essential&#xA; * difference between the three selection methods. &lt;/p>&#xA; *&#xA; *&#xA; * &lt;h4>Concurrency&lt;/h4>&#xA; *&#xA; * &lt;p> Selectors are themselves safe for use by multiple concurrent threads;&#xA; * their key sets, however, are not.&#xA; *&#xA; * &lt;p> The selection operations synchronize on the selector itself, on the key&#xA; * set, and on the selected-key set, in that order.  They also synchronize on&#xA; * the cancelled-key set during steps (1) and (3) above.&#xA; *&#xA; * &lt;p> Changes made to the interest sets of a selector's keys while a&#xA; * selection operation is in progress have no effect upon that operation; they&#xA; * will be seen by the next selection operation.&#xA; *&#xA; * &lt;p> Keys may be cancelled and channels may be closed at any time.  Hence the&#xA; * presence of a key in one or more of a selector's key sets does not imply&#xA; * that the key is valid or that its channel is open.  Application code should&#xA; * be careful to synchronize and check these conditions as necessary if there&#xA; * is any possibility that another thread will cancel a key or close a channel.&#xA; *&#xA; * &lt;p> A thread blocked in one of the {@link #select()} or {@link&#xA; * #select(long)} methods may be interrupted by some other thread in one of&#xA; * three ways:&#xA; *&#xA; * &lt;ul>&#xA; *&#xA; *   &lt;li>&lt;p> By invoking the selector's {@link #wakeup wakeup} method,&#xA; *   &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> By invoking the selector's {@link #close close} method, or&#xA; *   &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> By invoking the blocked thread's {@link&#xA; *   java.lang.Thread#interrupt() interrupt} method, in which case its&#xA; *   interrupt status will be set and the selector's {@link #wakeup wakeup}&#xA; *   method will be invoked. &lt;/p>&lt;/li>&#xA; *&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p> The {@link #close close} method synchronizes on the selector and all&#xA; * three key sets in the same order as in a selection operation.&#xA; *&#xA; * &lt;a name=&quot;ksc&quot;>&#xA; *&#xA; * &lt;p> A selector's key and selected-key sets are not, in general, safe for use&#xA; * by multiple concurrent threads.  If such a thread might modify one of these&#xA; * sets directly then access should be controlled by synchronizing on the set&#xA; * itself.  The iterators returned by these sets' {@link&#xA; * java.util.Set#iterator() iterator} methods are &lt;i>fail-fast:&lt;/i> If the set&#xA; * is modified after the iterator is created, in any way except by invoking the&#xA; * iterator's own {@link java.util.Iterator#remove() remove} method, then a&#xA; * {@link java.util.ConcurrentModificationException} will be thrown. &lt;/p>&#xA; *&#xA; *&#xA; * @author Mark Reinhold&#xA; * @author JSR-51 Expert Group&#xA; * @version 1.37, 04/05/05&#xA; * @since 1.4&#xA; *&#xA; * @see SelectableChannel&#xA; * @see SelectionKey&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
