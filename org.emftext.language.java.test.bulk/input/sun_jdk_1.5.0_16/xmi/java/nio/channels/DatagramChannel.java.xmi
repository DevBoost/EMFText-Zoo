<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="DatagramChannel.java">
  <comments>/*&#xA; * @(#)DatagramChannel.java&#x9;1.32 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>nio</namespaces>
  <namespaces>channels</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>net</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../net/DatagramSocket.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>net</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../net/SocketAddress.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>channels</namespaces>
    <namespaces>spi</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="DatagramChannel">
    <members xsi:type="members:Constructor" name="DatagramChannel">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0/@parameters.0"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="provider">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="spi/SelectorProvider.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Initializes a new instance of this class.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="open">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Opens a datagram channel.&#xA;     *&#xA;     * &lt;p> The new channel is created by invoking the {@link&#xA;     * java.nio.channels.spi.SelectorProvider#openDatagramChannel()&#xA;     * openDatagramChannel} method of the system-wide default {@link&#xA;     * java.nio.channels.spi.SelectorProvider} object.  The channel will not be&#xA;     * connected.  &lt;/p>&#xA;     *&#xA;     * @return  A new datagram channel&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If an I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="spi/SelectorProvider.class.xmi#//@classifiers.0/@members.6"/>
            </next>
            <target xsi:type="members:ClassMethod" href="spi/SelectorProvider.class.xmi#//@classifiers.0/@members.5"/>
          </next>
          <target xsi:type="classifiers:Class" href="spi/SelectorProvider.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="validOps">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an operation set identifying this channel's supported&#xA;     * operations.&#xA;     *&#xA;     * &lt;p> Datagram channels support reading and writing, so this method&#xA;     * returns &lt;tt>(&lt;/tt>{@link SelectionKey#OP_READ} &lt;tt>|&lt;/tt>&amp;nbsp;{@link&#xA;     * SelectionKey#OP_WRITE}&lt;tt>)&lt;/tt>.  &lt;/p>&#xA;     *&#xA;     * @return  The valid-operation set&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:InclusiveOrExpression">
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="SelectionKey.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="SelectionKey.class.xmi#//@classifiers.0"/>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="SelectionKey.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="SelectionKey.class.xmi#//@classifiers.0"/>
            </children>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="socket">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../net/DatagramSocket.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Socket-specific operations --</comments>
        <comments>/**&#xA;     * Retrieves a datagram socket associated with this channel.&#xA;     *&#xA;     * &lt;p> The returned object will not declare any public methods that are not&#xA;     * declared in the {@link java.net.DatagramSocket} class.  &lt;/p>&#xA;     *&#xA;     * @return  A datagram socket associated with this channel&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isConnected">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tells whether or not this channel's socket is connected.  &lt;/p>&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this channel's socket&#xA;     *          is connected&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="connect">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="remote">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../net/SocketAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Connects this channel's socket.&#xA;     *&#xA;     * &lt;p> The channel's socket is configured so that it only receives&#xA;     * datagrams from, and sends datagrams to, the given remote &lt;i>peer&lt;/i>&#xA;     * address.  Once connected, datagrams may not be received from or sent to&#xA;     * any other address.  A datagram socket remains connected until it is&#xA;     * explicitly disconnected or until it is closed.&#xA;     *&#xA;     * &lt;p> This method performs exactly the same security checks as the {@link&#xA;     * java.net.DatagramSocket#connect connect} method of the {@link&#xA;     * java.net.DatagramSocket} class.  That is, if a security manager has been&#xA;     * installed then this method verifies that its {@link&#xA;     * java.lang.SecurityManager#checkAccept checkAccept} and {@link&#xA;     * java.lang.SecurityManager#checkConnect checkConnect} methods permit&#xA;     * datagrams to be received from and sent to, respectively, the given&#xA;     * remote address.&#xA;     *&#xA;     * &lt;p> This method may be invoked at any time.  It will not have any effect &#xA;     * on read or write operations that are already in progress at the moment&#xA;     * that it is invoked.  &lt;/p>&#xA;     *&#xA;     * @param  remote&#xA;     *         The remote address to which this channel is to be connected&#xA;     *&#xA;     * @return  This datagram channel&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  AsynchronousCloseException&#xA;     *          If another thread closes this channel&#xA;     *          while the connect operation is in progress&#xA;     *&#xA;     * @throws  ClosedByInterruptException&#xA;     *          If another thread interrupts the current thread&#xA;     *          while the connect operation is in progress, thereby&#xA;     *          closing the channel and setting the current thread's&#xA;     *          interrupt status&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager has been installed&#xA;     *          and it does not permit access to the given remote address&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="disconnect">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Disconnects this channel's socket.&#xA;     *&#xA;     * &lt;p> The channel's socket is configured so that it can receive datagrams&#xA;     * from, and sends datagrams to, any remote address so long as the security &#xA;     * manager, if installed, permits it.&#xA;     *&#xA;     * &lt;p> This method may be invoked at any time.  It will not have any effect &#xA;     * on read or write operations that are already in progress at the moment&#xA;     * that it is invoked.&#xA;     *&#xA;     * &lt;p> If this channel's socket is not connected, or if the channel is&#xA;     * closed, then invoking this method has no effect.  &lt;/p>&#xA;     *&#xA;     * @return  This datagram channel&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="receive">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../net/SocketAddress.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Receives a datagram via this channel.&#xA;     *&#xA;     * &lt;p> If a datagram is immediately available, or if this channel is in&#xA;     * blocking mode and one eventually becomes available, then the datagram is&#xA;     * copied into the given byte buffer and its source address is returned.&#xA;     * If this channel is in non-blocking mode and a datagram is not&#xA;     * immediately available then this method immediately returns&#xA;     * &lt;tt>null&lt;/tt>.&#xA;     *&#xA;     * &lt;p> The datagram is transferred into the given byte buffer starting at&#xA;     * its current position, as if by a regular {@link&#xA;     * ReadableByteChannel#read(java.nio.ByteBuffer) read} operation.  If there&#xA;     * are fewer bytes remaining in the buffer than are required to hold the&#xA;     * datagram then the remainder of the datagram is silently discarded.&#xA;     *&#xA;     * &lt;p> This method performs exactly the same security checks as the {@link&#xA;     * java.net.DatagramSocket#receive receive} method of the {@link&#xA;     * java.net.DatagramSocket} class.  That is, if the socket is not connected&#xA;     * to a specific remote address and a security manager has been installed&#xA;     * then for each datagram received this method verifies that the source's&#xA;     * address and port number are permitted by the security manager's {@link&#xA;     * java.lang.SecurityManager#checkAccept checkAccept} method.  The overhead&#xA;     * of this security check can be avoided by first connecting the socket via &#xA;     * the {@link #connect connect} method.&#xA;     *&#xA;     * &lt;p> This method may be invoked at any time.  If another thread has&#xA;     * already initiated a read operation upon this channel, however, then an&#xA;     * invocation of this method will block until the first operation is&#xA;     * complete. &lt;/p>&#xA;     *&#xA;     * @param  dst&#xA;     *         The buffer into which the datagram is to be transferred&#xA;     *&#xA;     * @return  The datagram's source address,&#xA;     *          or &lt;tt>null&lt;/tt> if this channel is in non-blocking mode&#xA;     *          and no datagram was immediately available&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  AsynchronousCloseException&#xA;     *          If another thread closes this channel&#xA;     *          while the read operation is in progress&#xA;     *&#xA;     * @throws  ClosedByInterruptException&#xA;     *          If another thread interrupts the current thread&#xA;     *          while the read operation is in progress, thereby&#xA;     *          closing the channel and setting the current thread's&#xA;     *          interrupt status&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager has been installed&#xA;     *          and it does not permit datagrams to be accepted&#xA;     *          from the datagram's sender&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="send">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../net/SocketAddress.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sends a datagram via this channel.&#xA;     *&#xA;     * &lt;p> If this channel is in non-blocking mode and there is sufficient room&#xA;     * in the underlying output buffer, or if this channel is in blocking mode&#xA;     * and sufficient room becomes available, then the remaining bytes in the&#xA;     * given buffer are transmitted as a single datagram to the given target&#xA;     * address.&#xA;     *&#xA;     * &lt;p> The datagram is transferred from the byte buffer as if by a regular&#xA;     * {@link WritableByteChannel#write(java.nio.ByteBuffer) write} operation.&#xA;     *&#xA;     * &lt;p> This method performs exactly the same security checks as the {@link&#xA;     * java.net.DatagramSocket#send send} method of the {@link&#xA;     * java.net.DatagramSocket} class.  That is, if the socket is not connected&#xA;     * to a specific remote address and a security manager has been installed&#xA;     * then for each datagram sent this method verifies that the target address&#xA;     * and port number are permitted by the security manager's {@link&#xA;     * java.lang.SecurityManager#checkConnect checkConnect} method.  The&#xA;     * overhead of this security check can be avoided by first connecting the&#xA;     * socket via the {@link #connect connect} method.&#xA;     *&#xA;     * &lt;p> This method may be invoked at any time.  If another thread has&#xA;     * already initiated a write operation upon this channel, however, then an&#xA;     * invocation of this method will block until the first operation is&#xA;     * complete. &lt;/p>&#xA;     *&#xA;     * @param  src&#xA;     *         The buffer containing the datagram to be sent&#xA;     *&#xA;     * @param  target&#xA;     *         The address to which the datagram is to be sent&#xA;     *&#xA;     * @return   The number of bytes sent, which will be either the number&#xA;     *           of bytes that were remaining in the source buffer when this&#xA;     *           method was invoked or, if this channel is non-blocking, may be&#xA;     *           zero if there was insufficient room for the datagram in the&#xA;     *           underlying output buffer&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  AsynchronousCloseException&#xA;     *          If another thread closes this channel&#xA;     *          while the read operation is in progress&#xA;     *&#xA;     * @throws  ClosedByInterruptException&#xA;     *          If another thread interrupts the current thread&#xA;     *          while the read operation is in progress, thereby&#xA;     *          closing the channel and setting the current thread's&#xA;     *          interrupt status&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager has been installed&#xA;     *          and it does not permit datagrams to be sent&#xA;     *          to the given address&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="read">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- ByteChannel operations --</comments>
        <comments>/**&#xA;     * Reads a datagram from this channel.&#xA;     *&#xA;     * &lt;p> This method may only be invoked if this channel's socket is&#xA;     * connected, and it only accepts datagrams from the socket's peer.  If&#xA;     * there are more bytes in the datagram than remain in the given buffer&#xA;     * then the remainder of the datagram is silently discarded.  Otherwise&#xA;     * this method behaves exactly as specified in the {@link&#xA;     * ReadableByteChannel} interface.  &lt;/p>&#xA;     *&#xA;     * @throws  NotYetConnectedException&#xA;     *          If this channel's socket is not connected&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="read">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dsts">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a datagram from this channel.&#xA;     *&#xA;     * &lt;p> This method may only be invoked if this channel's socket is&#xA;     * connected, and it only accepts datagrams from the socket's peer.  If&#xA;     * there are more bytes in the datagram than remain in the given buffers&#xA;     * then the remainder of the datagram is silently discarded.  Otherwise&#xA;     * this method behaves exactly as specified in the {@link&#xA;     * ScatteringByteChannel} interface.  &lt;/p>&#xA;     *&#xA;     * @throws  NotYetConnectedException&#xA;     *          If this channel's socket is not connected&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="read">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dsts">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a datagram from this channel.&#xA;     *&#xA;     * &lt;p> This method may only be invoked if this channel's socket is&#xA;     * connected, and it only accepts datagrams from the socket's peer.  If&#xA;     * there are more bytes in the datagram than remain in the given buffers&#xA;     * then the remainder of the datagram is silently discarded.  Otherwise&#xA;     * this method behaves exactly as specified in the {@link&#xA;     * ScatteringByteChannel} interface.  &lt;/p>&#xA;     *&#xA;     * @throws  NotYetConnectedException&#xA;     *          If this channel's socket is not connected&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.10">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a datagram to this channel.&#xA;     *&#xA;     * &lt;p> This method may only be invoked if this channel's socket is&#xA;     * connected, in which case it sends datagrams directly to the socket's&#xA;     * peer.  Otherwise it behaves exactly as specified in the {@link&#xA;     * WritableByteChannel} interface.  &lt;/p>&#xA;     *&#xA;     * @throws  NotYetConnectedException&#xA;     *          If this channel's socket is not connected&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="srcs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a datagram to this channel.&#xA;     *&#xA;     * &lt;p> This method may only be invoked if this channel's socket is&#xA;     * connected, in which case it sends datagrams directly to the socket's&#xA;     * peer.  Otherwise it behaves exactly as specified in the {@link&#xA;     * GatheringByteChannel} interface.  &lt;/p>&#xA;     *&#xA;     * @return   The number of bytes sent, which will be either the number&#xA;     *           of bytes that were remaining in the source buffer when this&#xA;     *           method was invoked or, if this channel is non-blocking, may be&#xA;     *           zero if there was insufficient room for the datagram in the&#xA;     *           underlying output buffer&#xA;     *&#xA;     * @throws  NotYetConnectedException&#xA;     *          If this channel's socket is not connected&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="srcs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a datagram to this channel.&#xA;     *&#xA;     * &lt;p> This method may only be invoked if this channel's socket is&#xA;     * connected, in which case it sends datagrams directly to the socket's&#xA;     * peer.  Otherwise it behaves exactly as specified in the {@link&#xA;     * GatheringByteChannel} interface.  &lt;/p>&#xA;     *&#xA;     * @return   The number of bytes sent, which will be either the number&#xA;     *           of bytes that were remaining in the source buffer when this&#xA;     *           method was invoked or, if this channel is non-blocking, may be&#xA;     *           zero if there was insufficient room for the datagram in the&#xA;     *           underlying output buffer&#xA;     *&#xA;     * @throws  NotYetConnectedException&#xA;     *          If this channel's socket is not connected&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A selectable channel for datagram-oriented sockets.&#xA; *&#xA; *&#xA; * &lt;p> Datagram channels are not a complete abstraction of network datagram&#xA; * sockets.  Binding and the manipulation of socket options must be done&#xA; * through an associated {@link java.net.DatagramSocket} object obtained by&#xA; * invoking the {@link #socket() socket} method.  It is not possible to create&#xA; * a channel for an arbitrary, pre-existing datagram socket, nor is it possible&#xA; * to specify the {@link java.net.DatagramSocketImpl} object to be used by a&#xA; * datagram socket associated with a datagram channel.&#xA; *&#xA; * &lt;p> A datagram channel is created by invoking the {@link #open open} method&#xA; * of this class.  A newly-created datagram channel is open but not connected.&#xA; * A datagram channel need not be connected in order for the {@link #send send}&#xA; * and {@link #receive receive} methods to be used.  A datagram channel may be&#xA; * connected, by invoking its {@link #connect connect} method, in order to&#xA; * avoid the overhead of the security checks are otherwise performed as part of&#xA; * every send and receive operation.  A datagram channel must be connected in&#xA; * order to use the {@link #read(java.nio.ByteBuffer) read} and {@link&#xA; * #write(java.nio.ByteBuffer) write} methods, since those methods do not&#xA; * accept or return socket addresses.&#xA; *&#xA; * &lt;p> Once connected, a datagram channel remains connected until it is&#xA; * disconnected or closed.  Whether or not a datagram channel is connected may&#xA; * be determined by invoking its {@link #isConnected isConnected} method.&#xA; *&#xA; * &lt;p> Datagram channels are safe for use by multiple concurrent threads.  They&#xA; * support concurrent reading and writing, though at most one thread may be&#xA; * reading and at most one thread may be writing at any given time.  &lt;/p>&#xA; *&#xA; *&#xA; * @author Mark Reinhold&#xA; * @author JSR-51 Expert Group&#xA; * @version 1.32, 03/12/19&#xA; * @since 1.4&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="ByteChannel.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="ScatteringByteChannel.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="GatheringByteChannel.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="spi/AbstractSelectableChannel.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
