<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="SelectionKey.java">
  <comments>/*&#xA; * @(#)SelectionKey.java&#x9;1.24 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>nio</namespaces>
  <namespaces>channels</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="SelectionKey">
    <members xsi:type="members:Constructor" name="SelectionKey">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Constructs an instance of this class.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="channel">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SelectableChannel.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Channel and selector operations --</comments>
        <comments>/**&#xA;     * Returns the channel for which this key was created.  This method will&#xA;     * continue to return the channel even after the key is cancelled.  &lt;/p>&#xA;     *&#xA;     * @return  This key's channel&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="selector">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Selector.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the selector for which this key was created.  This method will&#xA;     * continue to return the selector even after the key is cancelled.  &lt;/p>&#xA;     *&#xA;     * @return  This key's selector&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isValid">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tells whether or not this key is valid.&#xA;     *&#xA;     * &lt;p> A key is valid upon creation and remains so until it is cancelled,&#xA;     * its channel is closed, or its selector is closed.  &lt;/p>&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this key is valid&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="cancel">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Requests that the registration of this key's channel with its selector&#xA;     * be cancelled.  Upon return the key will be invalid and will have been&#xA;     * added to its selector's cancelled-key set.  The key will be removed from&#xA;     * all of the selector's key sets during the next selection operation.&#xA;     *&#xA;     * &lt;p> If this key has already been cancelled then invoking this method has&#xA;     * no effect.  Once cancelled, a key remains forever invalid. &lt;/p>&#xA;     *&#xA;     * &lt;p> This method may be invoked at any time.  It synchronizes on the&#xA;     * selector's cancelled-key set, and therefore may block briefly if invoked&#xA;     * concurrently with a cancellation or selection operation involving the&#xA;     * same selector.  &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="interestOps">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Operation-set accessors --</comments>
        <comments>/**&#xA;     * Retrieves this key's interest set.&#xA;     *&#xA;     * &lt;p> It is guaranteed that the returned set will only contain operation&#xA;     * bits that are valid for this key's channel.&#xA;     *&#xA;     * &lt;p> This method may be invoked at any time.  Whether or not it blocks,&#xA;     * and for how long, is implementation-dependent.  &lt;/p>&#xA;     *&#xA;     * @return  This key's interest set&#xA;     *&#xA;     * @throws  CancelledKeyException&#xA;     *          If this key has been cancelled&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="interestOps">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ops">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets this key's interest set to the given value.&#xA;     *&#xA;     * &lt;p> This method may be invoked at any time.  Whether or not it blocks,&#xA;     * and for how long, is implementation-dependent.  &lt;/p>&#xA;     *&#xA;     * @param  ops  The new interest set&#xA;     *&#xA;     * @return  This selection key&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If a bit in the set does not correspond to an operation that&#xA;     *          is supported by this key's channel, that is, if&#xA;     *          &lt;tt>set &amp; ~(channel().validOps()) != 0&lt;/tt>&#xA;     *&#xA;     * @throws  CancelledKeyException&#xA;     *          If this key has been cancelled&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readyOps">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves this key's ready-operation set.&#xA;     *&#xA;     * &lt;p> It is guaranteed that the returned set will only contain operation&#xA;     * bits that are valid for this key's channel.  &lt;/p>&#xA;     *&#xA;     * @return  This key's ready-operation set&#xA;     *&#xA;     * @throws  CancelledKeyException&#xA;     *          If this key has been cancelled&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:Field" name="OP_READ">
      <initialValue xsi:type="expressions:ShiftExpression">
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        <shiftOperators xsi:type="operators:LeftShift"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Operation bits and bit-testing convenience methods --</comments>
        <comments>/**&#xA;     * Operation-set bit for read operations.&#xA;     *&#xA;     * &lt;p> Suppose that a selection key's interest set contains&#xA;     * &lt;tt>OP_READ&lt;/tt> at the start of a &lt;a&#xA;     * href=&quot;Selector.html#selop&quot;>selection operation&lt;/a>.  If the selector&#xA;     * detects that the corresponding channel is ready for reading, has reached&#xA;     * end-of-stream, has been remotely shut down for further reading, or has&#xA;     * an error pending, then it will add &lt;tt>OP_READ&lt;/tt> to the key's&#xA;     * ready-operation set and add the key to its selected-key&amp;nbsp;set.  &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="OP_WRITE">
      <initialValue xsi:type="expressions:ShiftExpression">
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
        <shiftOperators xsi:type="operators:LeftShift"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Operation-set bit for write operations.  &lt;/p>&#xA;     *&#xA;     * &lt;p> Suppose that a selection key's interest set contains&#xA;     * &lt;tt>OP_WRITE&lt;/tt> at the start of a &lt;a&#xA;     * href=&quot;Selector.html#selop&quot;>selection operation&lt;/a>.  If the selector&#xA;     * detects that the corresponding channel is ready for writing, has been&#xA;     * remotely shut down for further writing, or has an error pending, then it&#xA;     * will add &lt;tt>OP_WRITE&lt;/tt> to the key's ready set and add the key to its&#xA;     * selected-key&amp;nbsp;set.  &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="OP_CONNECT">
      <initialValue xsi:type="expressions:ShiftExpression">
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
        <shiftOperators xsi:type="operators:LeftShift"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Operation-set bit for socket-connect operations.  &lt;/p>&#xA;     *&#xA;     * &lt;p> Suppose that a selection key's interest set contains&#xA;     * &lt;tt>OP_CONNECT&lt;/tt> at the start of a &lt;a&#xA;     * href=&quot;Selector.html#selop&quot;>selection operation&lt;/a>.  If the selector&#xA;     * detects that the corresponding socket channel is ready to complete its&#xA;     * connection sequence, or has an error pending, then it will add&#xA;     * &lt;tt>OP_CONNECT&lt;/tt> to the key's ready set and add the key to its&#xA;     * selected-key&amp;nbsp;set.  &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="OP_ACCEPT">
      <initialValue xsi:type="expressions:ShiftExpression">
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
        <shiftOperators xsi:type="operators:LeftShift"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Operation-set bit for socket-accept operations.  &lt;/p>&#xA;     *&#xA;     * &lt;p> Suppose that a selection key's interest set contains&#xA;     * &lt;tt>OP_ACCEPT&lt;/tt> at the start of a &lt;a&#xA;     * href=&quot;Selector.html#selop&quot;>selection operation&lt;/a>.  If the selector&#xA;     * detects that the corresponding server-socket channel is ready to accept&#xA;     * another connection, or has an error pending, then it will add&#xA;     * &lt;tt>OP_ACCEPT&lt;/tt> to the key's ready set and add the key to its&#xA;     * selected-key&amp;nbsp;set.  &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:ClassMethod" name="isReadable">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests whether this key's channel is ready for reading.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>k.isReadable()&lt;/tt>&#xA;     * behaves in exactly the same way as the expression&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * k.readyOps()&amp;nbsp;&amp;amp;&amp;nbsp;OP_READ&amp;nbsp;!=&amp;nbsp;0&lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * &lt;p> If this key's channel does not support read operations then this&#xA;     * method always returns &lt;tt>false&lt;/tt>.  &lt;/p>&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if,&#xA;     *          &lt;tt>readyOps()&lt;/tt>&amp;nbsp;&lt;tt>&amp;&lt;/tt>&amp;nbsp;&lt;tt>OP_READ&lt;/tt> is&#xA;     *          nonzero&#xA;     *&#xA;     * @throws  CancelledKeyException&#xA;     *          If this key has been cancelled&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.7"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isWritable">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests whether this key's channel is ready for writing.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>k.isWritable()&lt;/tt>&#xA;     * behaves in exactly the same way as the expression&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * k.readyOps()&amp;nbsp;&amp;amp;&amp;nbsp;OP_WRITE&amp;nbsp;!=&amp;nbsp;0&lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * &lt;p> If this key's channel does not support write operations then this&#xA;     * method always returns &lt;tt>false&lt;/tt>.  &lt;/p>&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if,&#xA;     *          &lt;tt>readyOps()&lt;/tt>&amp;nbsp;&lt;tt>&amp;&lt;/tt>&amp;nbsp;&lt;tt>OP_WRITE&lt;/tt>&#xA;     *          is nonzero&#xA;     *&#xA;     * @throws  CancelledKeyException&#xA;     *          If this key has been cancelled&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.7"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isConnectable">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests whether this key's channel has either finished, or failed to&#xA;     * finish, its socket-connection operation.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>k.isConnectable()&lt;/tt>&#xA;     * behaves in exactly the same way as the expression&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * k.readyOps()&amp;nbsp;&amp;amp;&amp;nbsp;OP_CONNECT&amp;nbsp;!=&amp;nbsp;0&lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * &lt;p> If this key's channel does not support socket-connect operations&#xA;     * then this method always returns &lt;tt>false&lt;/tt>.  &lt;/p>&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if,&#xA;     *          &lt;tt>readyOps()&lt;/tt>&amp;nbsp;&lt;tt>&amp;&lt;/tt>&amp;nbsp;&lt;tt>OP_CONNECT&lt;/tt>&#xA;     *          is nonzero&#xA;     *&#xA;     * @throws  CancelledKeyException&#xA;     *          If this key has been cancelled&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.7"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isAcceptable">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests whether this key's channel is ready to accept a new socket&#xA;     * connection.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>k.isAcceptable()&lt;/tt>&#xA;     * behaves in exactly the same way as the expression&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * k.readyOps()&amp;nbsp;&amp;amp;&amp;nbsp;OP_ACCEPT&amp;nbsp;!=&amp;nbsp;0&lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * &lt;p> If this key's channel does not support socket-accept operations then&#xA;     * this method always returns &lt;tt>false&lt;/tt>.  &lt;/p>&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if,&#xA;     *          &lt;tt>readyOps()&lt;/tt>&amp;nbsp;&lt;tt>&amp;&lt;/tt>&amp;nbsp;&lt;tt>OP_ACCEPT&lt;/tt>&#xA;     *          is nonzero&#xA;     *&#xA;     * @throws  CancelledKeyException&#xA;     *          If this key has been cancelled&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.7"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="attachment">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// -- Attachments --</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Volatile"/>
    </members>
    <members xsi:type="members:ClassMethod" name="attach">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ob">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Attaches the given object to this key.&#xA;     *&#xA;     * &lt;p> An attached object may later be retrieved via the {@link #attachment&#xA;     * attachment} method.  Only one object may be attached at a time; invoking&#xA;     * this method causes any previous attachment to be discarded.  The current&#xA;     * attachment may be discarded by attaching &lt;tt>null&lt;/tt>.  &lt;/p>&#xA;     *&#xA;     * @param  ob&#xA;     *         The object to be attached; may be &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @return  The previously-attached object, if any,&#xA;     *          otherwise &lt;tt>null&lt;/tt>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="a">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="attachment">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Retrieves the current attachment.  &lt;/p>&#xA;     *&#xA;     * @return  The object currently attached to this key,&#xA;     *          or &lt;tt>null&lt;/tt> if there is no attachment&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A token representing the registration of a {@link SelectableChannel} with a&#xA; * {@link Selector}.&#xA; *&#xA; * &lt;p> A selection key is created each time a channel is registered with a&#xA; * selector.  A key remains valid until it is &lt;i>cancelled&lt;/i> by invoking its&#xA; * {@link #cancel cancel} method, by closing its channel, or by closing its&#xA; * selector.  Cancelling a key does not immediately remove it from its&#xA; * selector; it is instead added to the selector's &lt;a&#xA; * href=&quot;Selector.html#ks&quot;>&lt;i>cancelled-key set&lt;/i>&lt;/a> for removal during the&#xA; * next selection operation.  The validity of a key may be tested by invoking&#xA; * its {@link #isValid isValid} method.&#xA; *&#xA; * &lt;a name=&quot;opsets&quot;>&#xA; *&#xA; * &lt;p> A selection key contains two &lt;i>operation sets&lt;/i> represented as&#xA; * integer values.  Each bit of an operation set denotes a category of&#xA; * selectable operations that are supported by the key's channel.&#xA; *&#xA; * &lt;ul>&#xA; *&#xA; *   &lt;li>&lt;p> The &lt;i>interest set&lt;/i> determines which operation categories will&#xA; *   be tested for readiness the next time one of the selector's selection&#xA; *   methods is invoked.  The interest set is initialized with the value given&#xA; *   when the key is created; it may later be changed via the {@link&#xA; *   #interestOps(int)} method. &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> The &lt;i>ready set&lt;/i> identifies the operation categories for which&#xA; *   the key's channel has been detected to be ready by the key's selector.&#xA; *   The ready set is initialized to zero when the key is created; it may later&#xA; *   be updated by the selector during a selection operation, but it cannot be&#xA; *   updated directly. &lt;/p>&lt;/li>&#xA; *&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p> That a selection key's ready set indicates that its channel is ready for&#xA; * some operation category is a hint, but not a guarantee, that an operation in&#xA; * such a category may be performed by a thread without causing the thread to&#xA; * block.  A ready set is most likely to be accurate immediately after the&#xA; * completion of a selection operation.  It is likely to be made inaccurate by&#xA; * external events and by I/O operations that are invoked upon the&#xA; * corresponding channel.&#xA; *&#xA; * &lt;p> This class defines all known operation-set bits, but precisely which&#xA; * bits are supported by a given channel depends upon the type of the channel.&#xA; * Each subclass of {@link SelectableChannel} defines an {@link&#xA; * SelectableChannel#validOps() validOps()} method which returns a set&#xA; * identifying just those operations that are supported by the channel.  An&#xA; * attempt to set or test an operation-set bit that is not supported by a key's&#xA; * channel will result in an appropriate run-time exception.&#xA; *&#xA; * &lt;p> It is often necessary to associate some application-specific data with a&#xA; * selection key, for example an object that represents the state of a&#xA; * higher-level protocol and handles readiness notifications in order to&#xA; * implement that protocol.  Selection keys therefore support the&#xA; * &lt;i>attachment&lt;/i> of a single arbitrary object to a key.  An object can be&#xA; * attached via the {@link #attach attach} method and then later retrieved via&#xA; * the {@link #attachment attachment} method.&#xA; *&#xA; * &lt;p> Selection keys are safe for use by multiple concurrent threads.  The&#xA; * operations of reading and writing the interest set will, in general, be&#xA; * synchronized with certain operations of the selector.  Exactly how this&#xA; * synchronization is performed is implementation-dependent: In a naive&#xA; * implementation, reading or writing the interest set may block indefinitely&#xA; * if a selection operation is already in progress; in a high-performance&#xA; * implementation, reading or writing the interest set may block briefly, if at&#xA; * all.  In any case, a selection operation will always use the interest-set&#xA; * value that was current at the moment that the operation began.  &lt;/p>&#xA; *&#xA; *&#xA; * @author Mark Reinhold&#xA; * @author JSR-51 Expert Group&#xA; * @version 1.24, 03/12/19&#xA; * @since 1.4&#xA; *&#xA; * @see SelectableChannel&#xA; * @see Selector&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
