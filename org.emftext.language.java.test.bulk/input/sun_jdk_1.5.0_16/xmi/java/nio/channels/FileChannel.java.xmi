<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="FileChannel.java">
  <comments>/*&#xA; * @(#)FileChannel.java&#x9;1.40 04/01/12&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>nio</namespaces>
  <namespaces>channels</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../MappedByteBuffer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>channels</namespaces>
    <namespaces>spi</namespaces>
    <classifier xsi:type="classifiers:Class" href="spi/AbstractInterruptibleChannel.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="FileChannel">
    <members xsi:type="members:Constructor" name="FileChannel">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Initializes a new instance of this class.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="read">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Channel operations --</comments>
        <comments>/**&#xA;     * Reads a sequence of bytes from this channel into the given buffer.&#xA;     *&#xA;     * &lt;p> Bytes are read starting at this channel's current file position, and&#xA;     * then the file position is updated with the number of bytes actually&#xA;     * read.  Otherwise this method behaves exactly as specified in the {@link&#xA;     * ReadableByteChannel} interface. &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="read">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dsts">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a sequence of bytes from this channel into a subsequence of the&#xA;     * given buffers.&#xA;     *&#xA;     * &lt;p> Bytes are read starting at this channel's current file position, and&#xA;     * then the file position is updated with the number of bytes actually&#xA;     * read.  Otherwise this method behaves exactly as specified in the {@link&#xA;     * ScatteringByteChannel} interface.  &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="read">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dsts">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a sequence of bytes from this channel into the given buffers.&#xA;     *&#xA;     * &lt;p> Bytes are read starting at this channel's current file position, and&#xA;     * then the file position is updated with the number of bytes actually&#xA;     * read.  Otherwise this method behaves exactly as specified in the {@link&#xA;     * ScatteringByteChannel} interface.  &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.2">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a sequence of bytes to this channel from the given buffer.&#xA;     *&#xA;     * &lt;p> Bytes are written starting at this channel's current file position&#xA;     * unless the channel is in append mode, in which case the position is&#xA;     * first advanced to the end of the file.  The file is grown, if necessary,&#xA;     * to accommodate the written bytes, and then the file position is updated&#xA;     * with the number of bytes actually written.  Otherwise this method&#xA;     * behaves exactly as specified by the {@link WritableByteChannel}&#xA;     * interface. &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="srcs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a sequence of bytes to this channel from a subsequence of the&#xA;     * given buffers.&#xA;     *&#xA;     * &lt;p> Bytes are written starting at this channel's current file position&#xA;     * unless the channel is in append mode, in which case the position is&#xA;     * first advanced to the end of the file.  The file is grown, if necessary,&#xA;     * to accommodate the written bytes, and then the file position is updated&#xA;     * with the number of bytes actually written.  Otherwise this method&#xA;     * behaves exactly as specified in the {@link GatheringByteChannel}&#xA;     * interface.  &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="srcs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a sequence of bytes to this channel from the given buffers.&#xA;     *&#xA;     * &lt;p> Bytes are written starting at this channel's current file position&#xA;     * unless the channel is in append mode, in which case the position is&#xA;     * first advanced to the end of the file.  The file is grown, if necessary,&#xA;     * to accommodate the written bytes, and then the file position is updated&#xA;     * with the number of bytes actually written.  Otherwise this method&#xA;     * behaves exactly as specified in the {@link GatheringByteChannel}&#xA;     * interface.  &lt;/p>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.5">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="position">
      <typeReference xsi:type="types:Long"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Other operations --</comments>
        <comments>/**&#xA;     * Returns this channel's file position.  &lt;/p>&#xA;     *&#xA;     * @return  This channel's file position,&#xA;     *          a non-negative integer counting the number of bytes&#xA;     *          from the beginning of the file to the current position&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="position">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newPosition">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets this channel's file position.&#xA;     *&#xA;     * &lt;p> Setting the position to a value that is greater than the file's&#xA;     * current size is legal but does not change the size of the file.  A later&#xA;     * attempt to read bytes at such a position will immediately return an&#xA;     * end-of-file indication.  A later attempt to write bytes at such a&#xA;     * position will cause the file to be grown to accommodate the new bytes;&#xA;     * the values of any bytes between the previous end-of-file and the&#xA;     * newly-written bytes are unspecified.  &lt;/p>&#xA;     *&#xA;     * @param  newPosition&#xA;     *         The new position, a non-negative integer counting&#xA;     *         the number of bytes from the beginning of the file&#xA;     *&#xA;     * @return  This file channel&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the new position is negative&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="size">
      <typeReference xsi:type="types:Long"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current size of this channel's file. &lt;/p>&#xA;     *&#xA;     * @return  The current size of this channel's file,&#xA;     *          measured in bytes&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="truncate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="size">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Truncates this channel's file to the given size.&#xA;     *&#xA;     * &lt;p> If the given size is less than the file's current size then the file&#xA;     * is truncated, discarding any bytes beyond the new end of the file.  If&#xA;     * the given size is greater than or equal to the file's current size then&#xA;     * the file is not modified.  In either case, if this channel's file&#xA;     * position is greater than the given size then it is set to that size.&#xA;     * &lt;/p>&#xA;     *&#xA;     * @param  size&#xA;     *         The new size, a non-negative byte count&#xA;     *&#xA;     * @return  This file channel&#xA;     *&#xA;     * @throws  NonWritableChannelException&#xA;     *          If this channel was not opened for writing&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the new size is negative&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="force">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="metaData">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Forces any updates to this channel's file to be written to the storage&#xA;     * device that contains it.&#xA;     *&#xA;     * &lt;p> If this channel's file resides on a local storage device then when&#xA;     * this method returns it is guaranteed that all changes made to the file&#xA;     * since this channel was created, or since this method was last invoked,&#xA;     * will have been written to that device.  This is useful for ensuring that&#xA;     * critical information is not lost in the event of a system crash.&#xA;     *&#xA;     * &lt;p> If the file does not reside on a local device then no such guarantee&#xA;     * is made.&#xA;     *&#xA;     * &lt;p> The &lt;tt>metaData&lt;/tt> parameter can be used to limit the number of&#xA;     * I/O operations that this method is required to perform.  Passing&#xA;     * &lt;tt>false&lt;/tt> for this parameter indicates that only updates to the&#xA;     * file's content need be written to storage; passing &lt;tt>true&lt;/tt>&#xA;     * indicates that updates to both the file's content and metadata must be&#xA;     * written, which generally requires at least one more I/O operation.&#xA;     * Whether this parameter actually has any effect is dependent upon the&#xA;     * underlying operating system and is therefore unspecified.&#xA;     *&#xA;     * &lt;p> Invoking this method may cause an I/O operation to occur even if the&#xA;     * channel was only opened for reading.  Some operating systems, for&#xA;     * example, maintain a last-access time as part of a file's metadata, and&#xA;     * this time is updated whenever the file is read.  Whether or not this is&#xA;     * actually done is system-dependent and is therefore unspecified.&#xA;     *&#xA;     * &lt;p> This method is only guaranteed to force changes that were made to&#xA;     * this channel's file via the methods defined in this class.  It may or&#xA;     * may not force changes that were made by modifying the content of a&#xA;     * {@link MappedByteBuffer &lt;/code>mapped byte buffer&lt;code>} obtained by&#xA;     * invoking the {@link #map map} method.  Invoking the {@link&#xA;     * MappedByteBuffer#force force} method of the mapped byte buffer will&#xA;     * force changes made to the buffer's content to be written.  &lt;/p>&#xA;     *&#xA;     * @param   metaData&#xA;     *          If &lt;tt>true&lt;/tt> then this method is required to force changes&#xA;     *          to both the file's content and metadata to be written to&#xA;     *          storage; otherwise, it need only force content changes to be&#xA;     *          written&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="transferTo">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="position">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="WritableByteChannel.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Transfers bytes from this channel's file to the given writable byte&#xA;     * channel.&#xA;     *&#xA;     * &lt;p> An attempt is made to read up to &lt;tt>count&lt;/tt> bytes starting at&#xA;     * the given &lt;tt>position&lt;/tt> in this channel's file and write them to the&#xA;     * target channel.  An invocation of this method may or may not transfer&#xA;     * all of the requested bytes; whether or not it does so depends upon the&#xA;     * natures and states of the channels.  Fewer than the requested number of&#xA;     * bytes are transferred if this channel's file contains fewer than&#xA;     * &lt;tt>count&lt;/tt> bytes starting at the given &lt;tt>position&lt;/tt>, or if the&#xA;     * target channel is non-blocking and it has fewer than &lt;tt>count&lt;/tt>&#xA;     * bytes free in its output buffer.&#xA;     *&#xA;     * &lt;p> This method does not modify this channel's position.  If the given&#xA;     * position is greater than the file's current size then no bytes are&#xA;     * transferred.  If the target channel has a position then bytes are&#xA;     * written starting at that position and then the position is incremented&#xA;     * by the number of bytes written.&#xA;     *&#xA;     * &lt;p> This method is potentially much more efficient than a simple loop&#xA;     * that reads from this channel and writes to the target channel.  Many&#xA;     * operating systems can transfer bytes directly from the filesystem cache&#xA;     * to the target channel without actually copying them.  &lt;/p>&#xA;     *&#xA;     * @param  position&#xA;     *         The position within the file at which the transfer is to begin;&#xA;     *         must be non-negative&#xA;     *&#xA;     * @param  count&#xA;     *         The maximum number of bytes to be transferred; must be&#xA;     *         non-negative&#xA;     *&#xA;     * @param  target&#xA;     *         The target channel&#xA;     *&#xA;     * @return  The number of bytes, possibly zero,&#xA;     *          that were actually transferred&#xA;     *&#xA;     * @throws IllegalArgumentException&#xA;     *         If the preconditions on the parameters do not hold&#xA;     *&#xA;     * @throws  NonReadableChannelException&#xA;     *          If this channel was not opened for reading&#xA;     *&#xA;     * @throws  NonWritableChannelException&#xA;     *          If the target channel was not opened for writing&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If either this channel or the target channel is closed&#xA;     *&#xA;     * @throws  AsynchronousCloseException&#xA;     *          If another thread closes either channel&#xA;     *          while the transfer is in progress&#xA;     *&#xA;     * @throws  ClosedByInterruptException&#xA;     *          If another thread interrupts the current thread while the&#xA;     *          transfer is in progress, thereby closing both channels and&#xA;     *          setting the current thread's interrupt status&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="transferFrom">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="ReadableByteChannel.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="position">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="count">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Transfers bytes into this channel's file from the given readable byte&#xA;     * channel.&#xA;     *&#xA;     * &lt;p> An attempt is made to read up to &lt;tt>count&lt;/tt> bytes from the&#xA;     * source channel and write them to this channel's file starting at the&#xA;     * given &lt;tt>position&lt;/tt>.  An invocation of this method may or may not&#xA;     * transfer all of the requested bytes; whether or not it does so depends&#xA;     * upon the natures and states of the channels.  Fewer than the requested&#xA;     * number of bytes will be transferred if the source channel has fewer than&#xA;     * &lt;tt>count&lt;/tt> bytes remaining, or if the source channel is non-blocking&#xA;     * and has fewer than &lt;tt>count&lt;/tt> bytes immediately available in its&#xA;     * input buffer.&#xA;     *&#xA;     * &lt;p> This method does not modify this channel's position.  If the given&#xA;     * position is greater than the file's current size then no bytes are&#xA;     * transferred.  If the source channel has a position then bytes are read&#xA;     * starting at that position and then the position is incremented by the&#xA;     * number of bytes read.&#xA;     *&#xA;     * &lt;p> This method is potentially much more efficient than a simple loop&#xA;     * that reads from the source channel and writes to this channel.  Many&#xA;     * operating systems can transfer bytes directly from the source channel&#xA;     * into the filesystem cache without actually copying them.  &lt;/p>&#xA;     *&#xA;     * @param  src&#xA;     *         The source channel&#xA;     *&#xA;     * @param  position&#xA;     *         The position within the file at which the transfer is to begin;&#xA;     *         must be non-negative&#xA;     *&#xA;     * @param  count&#xA;     *         The maximum number of bytes to be transferred; must be&#xA;     *         non-negative&#xA;     *&#xA;     * @return  The number of bytes, possibly zero,&#xA;     *          that were actually transferred&#xA;     *&#xA;     * @throws IllegalArgumentException&#xA;     *         If the preconditions on the parameters do not hold&#xA;     *&#xA;     * @throws  NonReadableChannelException&#xA;     *          If the source channel was not opened for reading&#xA;     *&#xA;     * @throws  NonWritableChannelException&#xA;     *          If this channel was not opened for writing&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If either this channel or the source channel is closed&#xA;     *&#xA;     * @throws  AsynchronousCloseException&#xA;     *          If another thread closes either channel&#xA;     *          while the transfer is in progress&#xA;     *&#xA;     * @throws  ClosedByInterruptException&#xA;     *          If another thread interrupts the current thread while the&#xA;     *          transfer is in progress, thereby closing both channels and&#xA;     *          setting the current thread's interrupt status&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="read">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="position">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a sequence of bytes from this channel into the given buffer,&#xA;     * starting at the given file position.&#xA;     *&#xA;     * &lt;p> This method works in the same manner as the {@link&#xA;     * #read(ByteBuffer)} method, except that bytes are read starting at the&#xA;     * given file position rather than at the channel's current position.  This&#xA;     * method does not modify this channel's position.  If the given position&#xA;     * is greater than the file's current size then no bytes are read.  &lt;/p>&#xA;     *&#xA;     * @param  dst&#xA;     *         The buffer into which bytes are to be transferred&#xA;     *&#xA;     * @param  position&#xA;     *         The file position at which the transfer is to begin;&#xA;     *         must be non-negative&#xA;     *&#xA;     * @return  The number of bytes read, possibly zero, or &lt;tt>-1&lt;/tt> if the&#xA;     *          given position is greater than or equal to the file's current&#xA;     *          size&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the position is negative&#xA;     *&#xA;     * @throws  NonReadableChannelException&#xA;     *          If this channel was not opened for reading&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  AsynchronousCloseException&#xA;     *          If another thread closes this channel&#xA;     *          while the read operation is in progress&#xA;     *&#xA;     * @throws  ClosedByInterruptException&#xA;     *          If another thread interrupts the current thread&#xA;     *          while the read operation is in progress, thereby&#xA;     *          closing the channel and setting the current thread's&#xA;     *          interrupt status&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="position">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a sequence of bytes to this channel from the given buffer,&#xA;     * starting at the given file position.&#xA;     *&#xA;     * &lt;p> This method works in the same manner as the {@link&#xA;     * #write(ByteBuffer)} method, except that bytes are written starting at&#xA;     * the given file position rather than at the channel's current position.&#xA;     * This method does not modify this channel's position.  If the given&#xA;     * position is greater than the file's current size then the file will be&#xA;     * grown to accommodate the new bytes; the values of any bytes between the&#xA;     * previous end-of-file and the newly-written bytes are unspecified.  &lt;/p>&#xA;     *&#xA;     * @param  src&#xA;     *         The buffer from which bytes are to be transferred&#xA;     *&#xA;     * @param  position&#xA;     *         The file position at which the transfer is to begin;&#xA;     *         must be non-negative&#xA;     *&#xA;     * @return  The number of bytes written, possibly zero&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the position is negative&#xA;     *&#xA;     * @throws  NonWritableChannelException&#xA;     *          If this channel was not opened for writing&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  AsynchronousCloseException&#xA;     *          If another thread closes this channel&#xA;     *          while the write operation is in progress&#xA;     *&#xA;     * @throws  ClosedByInterruptException&#xA;     *          If another thread interrupts the current thread&#xA;     *          while the write operation is in progress, thereby&#xA;     *          closing the channel and setting the current thread's&#xA;     *          interrupt status&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="classifiers:Class" name="MapMode">
      <members xsi:type="members:Field" name="READ_ONLY">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.16"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="READ_ONLY"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.16"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Mode for a read-only mapping.&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="READ_WRITE">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.16"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="READ_WRITE"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.16"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Mode for a read/write mapping.&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="PRIVATE">
        <initialValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0/@members.16"/>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="PRIVATE"/>
        </initialValue>
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.16"/>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Mode for a private (copy-on-write) mapping.&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
        <annotationsAndModifiers xsi:type="modifiers:Static"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Field" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
        <annotationsAndModifiers xsi:type="modifiers:Final"/>
      </members>
      <members xsi:type="members:Constructor" name="MapMode">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.3"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.4/@parameters.0"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="name">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Private"/>
      </members>
      <members xsi:type="members:ClassMethod" name="toString">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <annotationsAndModifiers xsi:type="modifiers:Public">
          <comments>/**&#xA;&#x9; * Returns a string describing this file-mapping mode.&#xA;&#x9; *&#xA;&#x9; * @return  A descriptive string&#xA;&#x9; */</comments>
        </annotationsAndModifiers>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@members.3"/>
        </statements>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Memory-mapped buffers --</comments>
        <comments>/**&#xA;     * A typesafe enumeration for file-mapping modes.&#xA;     *&#xA;     * @version 1.40, 04/01/12&#xA;     * @since 1.4&#xA;     *&#xA;     * @see java.nio.channels.FileChannel#map&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="map">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../MappedByteBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0/@members.16"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="position">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="size">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Maps a region of this channel's file directly into memory.&#xA;     *&#xA;     * &lt;p> A region of a file may be mapped into memory in one of three modes:&#xA;     * &lt;/p>&#xA;     *&#xA;     * &lt;ul type=disc>&#xA;     *&#xA;     *   &lt;li>&lt;p> &lt;i>Read-only:&lt;/i> Any attempt to modify the resulting buffer&#xA;     *   will cause a {@link java.nio.ReadOnlyBufferException} to be thrown.&#xA;     *   ({@link MapMode#READ_ONLY MapMode.READ_ONLY}) &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> &lt;i>Read/write:&lt;/i> Changes made to the resulting buffer will&#xA;     *   eventually be propagated to the file; they may or may not be made&#xA;     *   visible to other programs that have mapped the same file.  ({@link&#xA;     *   MapMode#READ_WRITE MapMode.READ_WRITE}) &lt;/p>&lt;/li>&#xA;     *&#xA;     *   &lt;li>&lt;p> &lt;i>Private:&lt;/i> Changes made to the resulting buffer will not&#xA;     *   be propagated to the file and will not be visible to other programs&#xA;     *   that have mapped the same file; instead, they will cause private&#xA;     *   copies of the modified portions of the buffer to be created.  ({@link&#xA;     *   MapMode#PRIVATE MapMode.PRIVATE}) &lt;/p>&lt;/li>&#xA;     *&#xA;     * &lt;/ul>&#xA;     *&#xA;     * &lt;p> For a read-only mapping, this channel must have been opened for&#xA;     * reading; for a read/write or private mapping, this channel must have&#xA;     * been opened for both reading and writing.&#xA;     *&#xA;     * &lt;p> The {@link MappedByteBuffer &lt;/code>mapped byte buffer&lt;code>}&#xA;     * returned by this method will have a position of zero and a limit and&#xA;     * capacity of &lt;tt>size&lt;/tt>; its mark will be undefined.  The buffer and&#xA;     * the mapping that it represents will remain valid until the buffer itself&#xA;     * is garbage-collected.&#xA;     *&#xA;     * &lt;p> A mapping, once established, is not dependent upon the file channel&#xA;     * that was used to create it.  Closing the channel, in particular, has no&#xA;     * effect upon the validity of the mapping.&#xA;     *&#xA;     * &lt;p> Many of the details of memory-mapped files are inherently dependent&#xA;     * upon the underlying operating system and are therefore unspecified.  The&#xA;     * behavior of this method when the requested region is not completely&#xA;     * contained within this channel's file is unspecified.  Whether changes&#xA;     * made to the content or size of the underlying file, by this program or&#xA;     * another, are propagated to the buffer is unspecified.  The rate at which&#xA;     * changes to the buffer are propagated to the file is unspecified.&#xA;     *&#xA;     * &lt;p> For most operating systems, mapping a file into memory is more&#xA;     * expensive than reading or writing a few tens of kilobytes of data via&#xA;     * the usual {@link #read read} and {@link #write write} methods.  From the&#xA;     * standpoint of performance it is generally only worth mapping relatively&#xA;     * large files into memory.  &lt;/p>&#xA;     *&#xA;     * @param  mode&#xA;     *         One of the constants {@link MapMode#READ_ONLY READ_ONLY}, {@link&#xA;     *         MapMode#READ_WRITE READ_WRITE}, or {@link MapMode#PRIVATE&#xA;     *         PRIVATE} defined in the {@link MapMode} class, according to&#xA;     *         whether the file is to be mapped read-only, read/write, or&#xA;     *         privately (copy-on-write), respectively&#xA;     *&#xA;     * @param  position&#xA;     *         The position within the file at which the mapped region&#xA;     *         is to start; must be non-negative&#xA;     *&#xA;     * @param  size&#xA;     *         The size of the region to be mapped; must be non-negative and&#xA;     *         no greater than {@link java.lang.Integer#MAX_VALUE}&#xA;     *&#xA;     * @throws NonReadableChannelException&#xA;     *         If the &lt;tt>mode&lt;/tt> is {@link MapMode#READ_ONLY READ_ONLY} but&#xA;     *         this channel was not opened for reading&#xA;     *&#xA;     * @throws NonWritableChannelException&#xA;     *         If the &lt;tt>mode&lt;/tt> is {@link MapMode#READ_WRITE READ_WRITE} or&#xA;     *         {@link MapMode#PRIVATE PRIVATE} but this channel was not opened&#xA;     *         for both reading and writing&#xA;     *&#xA;     * @throws IllegalArgumentException&#xA;     *         If the preconditions on the parameters do not hold&#xA;     *&#xA;     * @throws IOException&#xA;     *         If some other I/O error occurs&#xA;     *&#xA;     * @see java.nio.channels.FileChannel.MapMode&#xA;     * @see java.nio.MappedByteBuffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="lock">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileLock.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="position">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="size">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="shared">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Locks --</comments>
        <comments>/**&#xA;     * Acquires a lock on the given region of this channel's file.&#xA;     *&#xA;     * &lt;p> An invocation of this method will block until the region can be&#xA;     * locked, this channel is closed, or the invoking thread is interrupted,&#xA;     * whichever comes first.&#xA;     * &#xA;     * &lt;p> If this channel is closed by another thread during an invocation of&#xA;     * this method then an {@link AsynchronousCloseException} will be thrown.&#xA;     * &#xA;     * &lt;p> If the invoking thread is interrupted while waiting to acquire the&#xA;     * lock then its interrupt status will be set and a {@link&#xA;     * FileLockInterruptionException} will be thrown.  If the invoker's&#xA;     * interrupt status is set when this method is invoked then that exception&#xA;     * will be thrown immediately; the thread's interrupt status will not be&#xA;     * changed.&#xA;     *&#xA;     * &lt;p> The region specified by the &lt;tt>position&lt;/tt> and &lt;tt>size&lt;/tt>&#xA;     * parameters need not be contained within, or even overlap, the actual&#xA;     * underlying file.  Lock regions are fixed in size; if a locked region&#xA;     * initially contains the end of the file and the file grows beyond the&#xA;     * region then the new portion of the file will not be covered by the lock.&#xA;     * If a file is expected to grow in size and a lock on the entire file is&#xA;     * required then a region starting at zero, and no smaller than the&#xA;     * expected maximum size of the file, should be locked.  The zero-argument&#xA;     * {@link #lock()} method simply locks a region of size {@link&#xA;     * Long#MAX_VALUE}.&#xA;     *&#xA;     * &lt;p> Some operating systems do not support shared locks, in which case a&#xA;     * request for a shared lock is automatically converted into a request for&#xA;     * an exclusive lock.  Whether the newly-acquired lock is shared or&#xA;     * exclusive may be tested by invoking the resulting lock object's {@link&#xA;     * FileLock#isShared() isShared} method.&#xA;     *&#xA;     * &lt;p> File locks are held on behalf of the entire Java virtual machine.&#xA;     * They are not suitable for controlling access to a file by multiple&#xA;     * threads within the same virtual machine.  &lt;/p>&#xA;     *&#xA;     * @param  position&#xA;     *         The position at which the locked region is to start; must be&#xA;     *         non-negative&#xA;     *&#xA;     * @param  size&#xA;     *         The size of the locked region; must be non-negative, and the sum&#xA;     *         &lt;tt>position&lt;/tt>&amp;nbsp;+&amp;nbsp;&lt;tt>size&lt;/tt> must be non-negative&#xA;     *&#xA;     * @param  shared&#xA;     *         &lt;tt>true&lt;/tt> to request a shared lock, in which case this&#xA;     *         channel must be open for reading (and possibly writing);&#xA;     *         &lt;tt>false&lt;/tt> to request an exclusive lock, in which case this&#xA;     *         channel must be open for writing (and possibly reading)&#xA;     *&#xA;     * @return  A lock object representing the newly-acquired lock&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the preconditions on the parameters do not hold&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  AsynchronousCloseException&#xA;     *          If another thread closes this channel while the invoking&#xA;     *          thread is blocked in this method&#xA;     *&#xA;     * @throws  FileLockInterruptionException&#xA;     *          If the invoking thread is interrupted while blocked in this&#xA;     *          method&#xA;     *&#xA;     * @throws  OverlappingFileLockException&#xA;     *          If a lock that overlaps the requested region is already held by&#xA;     *          this Java virtual machine, or if another thread is already&#xA;     *          blocked in this method and is attempting to lock an overlapping&#xA;     *          region&#xA;     *&#xA;     * @throws  NonReadableChannelException&#xA;     *          If &lt;tt>shared&lt;/tt> is &lt;tt>true&lt;/tt> this channel was not&#xA;     *          opened for reading&#xA;     *&#xA;     * @throws  NonWritableChannelException&#xA;     *          If &lt;tt>shared&lt;/tt> is &lt;tt>false&lt;/tt> but this channel was not&#xA;     *          opened for writing&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     *&#xA;     * @see     #lock()&#xA;     * @see     #tryLock()&#xA;     * @see     #tryLock(long,long,boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="lock">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileLock.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Acquires an exclusive lock on this channel's file.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>fc.lock()&lt;/tt> behaves&#xA;     * in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     fc.{@link #lock(long,long,boolean) lock}(0L, Long.MAX_VALUE, false) &lt;/pre>&#xA;     *&#xA;     * @return  A lock object representing the newly-acquired lock&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  AsynchronousCloseException&#xA;     *          If another thread closes this channel while the invoking&#xA;     *          thread is blocked in this method&#xA;     *&#xA;     * @throws  FileLockInterruptionException&#xA;     *          If the invoking thread is interrupted while blocked in this&#xA;     *          method&#xA;     *&#xA;     * @throws  OverlappingFileLockException&#xA;     *          If a lock that overlaps the requested region is already held by&#xA;     *          this Java virtual machine, or if another thread is already&#xA;     *          blocked in this method and is attempting to lock an overlapping&#xA;     *          region of the same file&#xA;     *&#xA;     * @throws  NonReadableChannelException&#xA;     *          If &lt;tt>shared&lt;/tt> is &lt;tt>true&lt;/tt> this channel was not&#xA;     *          opened for reading&#xA;     *&#xA;     * @throws  NonWritableChannelException&#xA;     *          If &lt;tt>shared&lt;/tt> is &lt;tt>false&lt;/tt> but this channel was not&#xA;     *          opened for writing&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     *&#xA;     * @see     #lock(long,long,boolean)&#xA;     * @see     #tryLock()&#xA;     * @see     #tryLock(long,long,boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="literals:DecimalLongLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Long.class.xmi#//@classifiers.0"/>
          </arguments>
          <arguments xsi:type="literals:BooleanLiteral"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="tryLock">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileLock.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="position">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="size">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="shared">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Attempts to acquire a lock on the given region of this channel's file.&#xA;     *&#xA;     * &lt;p> This method does not block.  An invocation of this always returns&#xA;     * immediately, either having acquired a lock on the requested region or&#xA;     * having failed to do so.  If it fails to acquire a lock because an&#xA;     * overlapping lock is held by another program then it returns&#xA;     * &lt;tt>null&lt;/tt>.  If it fails to acquire a lock for any other reason then&#xA;     * an appropriate exception is thrown.&#xA;     *&#xA;     * &lt;p> The region specified by the &lt;tt>position&lt;/tt> and &lt;tt>size&lt;/tt>&#xA;     * parameters need not be contained within, or even overlap, the actual&#xA;     * underlying file.  Lock regions are fixed in size; if a locked region&#xA;     * initially contains the end of the file and the file grows beyond the&#xA;     * region then the new portion of the file will not be covered by the lock.&#xA;     * If a file is expected to grow in size and a lock on the entire file is&#xA;     * required then a region starting at zero, and no smaller than the&#xA;     * expected maximum size of the file, should be locked.  The zero-argument&#xA;     * {@link #tryLock()} method simply locks a region of size {@link&#xA;     * Long#MAX_VALUE}.&#xA;     *&#xA;     * &lt;p> Some operating systems do not support shared locks, in which case a&#xA;     * request for a shared lock is automatically converted into a request for&#xA;     * an exclusive lock.  Whether the newly-acquired lock is shared or&#xA;     * exclusive may be tested by invoking the resulting lock object's {@link&#xA;     * FileLock#isShared() isShared} method.&#xA;     *&#xA;     * &lt;p> File locks are held on behalf of the entire Java virtual machine.&#xA;     * They are not suitable for controlling access to a file by multiple&#xA;     * threads within the same virtual machine.  &lt;/p>&#xA;     *&#xA;     * @param  position&#xA;     *         The position at which the locked region is to start; must be&#xA;     *         non-negative&#xA;     *&#xA;     * @param  size&#xA;     *         The size of the locked region; must be non-negative, and the sum&#xA;     *         &lt;tt>position&lt;/tt>&amp;nbsp;+&amp;nbsp;&lt;tt>size&lt;/tt> must be non-negative&#xA;     *&#xA;     * @param  shared&#xA;     *         &lt;tt>true&lt;/tt> to request a shared lock,&#xA;     *         &lt;tt>false&lt;/tt> to request an exclusive lock&#xA;     *&#xA;     * @return  A lock object representing the newly-acquired lock,&#xA;     *          or &lt;tt>null&lt;/tt> if the lock could not be acquired&#xA;     *          because another program holds an overlapping lock&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the preconditions on the parameters do not hold&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  OverlappingFileLockException&#xA;     *          If a lock that overlaps the requested region is already held by&#xA;     *          this Java virtual machine, or if another thread is already&#xA;     *          blocked in this method and is attempting to lock an overlapping&#xA;     *          region of the same file&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     *&#xA;     * @see     #lock()&#xA;     * @see     #lock(long,long,boolean)&#xA;     * @see     #tryLock()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="tryLock">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileLock.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Attempts to acquire an exclusive lock on this channel's file.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>fc.tryLock()&lt;/tt>&#xA;     * behaves in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     fc.{@link #tryLock(long,long,boolean) tryLock}(0L, Long.MAX_VALUE, false) &lt;/pre>&#xA;     *&#xA;     * @return  A lock object representing the newly-acquired lock,&#xA;     *          or &lt;tt>null&lt;/tt> if the lock could not be acquired&#xA;     *          because another program holds an overlapping lock&#xA;     *&#xA;     * @throws  ClosedChannelException&#xA;     *          If this channel is closed&#xA;     *&#xA;     * @throws  OverlappingFileLockException&#xA;     *          If a lock that overlaps the requested region is already held by&#xA;     *          this Java virtual machine, or if another thread is already&#xA;     *          blocked in this method and is attempting to lock an overlapping&#xA;     *          region&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If some other I/O error occurs&#xA;     *&#xA;     * @see     #lock()&#xA;     * @see     #lock(long,long,boolean)&#xA;     * @see     #tryLock(long,long,boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
          <arguments xsi:type="literals:DecimalLongLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../../lang/Long.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Long.class.xmi#//@classifiers.0"/>
          </arguments>
          <arguments xsi:type="literals:BooleanLiteral"/>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A channel for reading, writing, mapping, and manipulating a file.&#xA; *&#xA; * &lt;p> A file channel has a current &lt;i>position&lt;/i> within its file which can&#xA; * be both {@link #position() &lt;/code>queried&lt;code>} and {@link #position(long)&#xA; * &lt;/code>modified&lt;code>}.  The file itself contains a variable-length sequence&#xA; * of bytes that can be read and written and whose current {@link #size&#xA; * &lt;/code>&lt;i>size&lt;/i>&lt;code>} can be queried.  The size of the file increases&#xA; * when bytes are written beyond its current size; the size of the file&#xA; * decreases when it is {@link #truncate &lt;/code>&lt;i>truncated&lt;/i>&lt;code>}.  The&#xA; * file may also have some associated &lt;i>metadata&lt;/i> such as access&#xA; * permissions, content type, and last-modification time; this class does not&#xA; * define methods for metadata access.&#xA; *&#xA; * &lt;p> In addition to the familiar read, write, and close operations of byte&#xA; * channels, this class defines the following file-specific operations: &lt;/p>&#xA; *&#xA; * &lt;ul>&#xA; *&#xA; *   &lt;li>&lt;p> Bytes may be {@link #read(ByteBuffer, long) &lt;/code>read&lt;code>} or&#xA; *   {@link #write(ByteBuffer, long) &lt;/code>written&lt;code>} at an absolute&#xA; *   position in a file in a way that does not affect the channel's current&#xA; *   position.  &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> A region of a file may be {@link #map &lt;/code>mapped&lt;code>}&#xA; *   directly into memory; for large files this is often much more efficient&#xA; *   than invoking the usual &lt;tt>read&lt;/tt> or &lt;tt>write&lt;/tt> methods.&#xA; *   &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> Updates made to a file may be {@link #force &lt;/code>forced&#xA; *   out&lt;code>} to the underlying storage device, ensuring that data are not&#xA; *   lost in the event of a system crash.  &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> Bytes can be transferred from a file {@link #transferTo &lt;/code>to&#xA; *   some other channel&lt;code>}, and {@link #transferFrom &lt;/code>vice&#xA; *   versa&lt;code>}, in a way that can be optimized by many operating systems&#xA; *   into a very fast transfer directly to or from the filesystem cache.&#xA; *   &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> A region of a file may be {@link FileLock &lt;/code>locked&lt;code>}&#xA; *   against access by other programs.  &lt;/p>&lt;/li>&#xA; *&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p> File channels are safe for use by multiple concurrent threads.  The&#xA; * {@link Channel#close close} method may be invoked at any time, as specified&#xA; * by the {@link Channel} interface.  Only one operation that involves the&#xA; * channel's position or can change its file's size may be in progress at any&#xA; * given time; attempts to initiate a second such operation while the first is&#xA; * still in progress will block until the first operation completes.  Other&#xA; * operations, in particular those that take an explicit position, may proceed&#xA; * concurrently; whether they in fact do so is dependent upon the underlying&#xA; * implementation and is therefore unspecified.&#xA; *&#xA; * &lt;p> The view of a file provided by an instance of this class is guaranteed&#xA; * to be consistent with other views of the same file provided by other&#xA; * instances in the same program.  The view provided by an instance of this&#xA; * class may or may not, however, be consistent with the views seen by other&#xA; * concurrently-running programs due to caching performed by the underlying&#xA; * operating system and delays induced by network-filesystem protocols.  This&#xA; * is true regardless of the language in which these other programs are&#xA; * written, and whether they are running on the same machine or on some other&#xA; * machine.  The exact nature of any such inconsistencies are system-dependent&#xA; * and are therefore unspecified.&#xA; *&#xA; * &lt;p> This class does not define methods for opening existing files or for&#xA; * creating new ones; such methods may be added in a future release.  In this&#xA; * release a file channel can be obtained from an existing {@link&#xA; * java.io.FileInputStream#getChannel FileInputStream}, {@link&#xA; * java.io.FileOutputStream#getChannel FileOutputStream}, or {@link&#xA; * java.io.RandomAccessFile#getChannel RandomAccessFile} object by invoking&#xA; * that object's &lt;tt>getChannel&lt;/tt> method, which returns a file channel that&#xA; * is connected to the same underlying file.&#xA; *&#xA; * &lt;p> The state of a file channel is intimately connected to that of the&#xA; * object whose &lt;tt>getChannel&lt;/tt> method returned the channel.  Changing the&#xA; * channel's position, whether explicitly or by reading or writing bytes, will&#xA; * change the file position of the originating object, and vice versa.&#xA; * Changing the file's length via the file channel will change the length seen&#xA; * via the originating object, and vice versa.  Changing the file's content by&#xA; * writing bytes will change the content seen by the originating object, and&#xA; * vice versa.&#xA; *&#xA; * &lt;a name=&quot;open-mode&quot;>&lt;p> At various points this class specifies that an&#xA; * instance that is &quot;open for reading,&quot; &quot;open for writing,&quot; or &quot;open for&#xA; * reading and writing&quot; is required.  A channel obtained via the {@link&#xA; * java.io.FileInputStream#getChannel getChannel} method of a {@link&#xA; * java.io.FileInputStream} instance will be open for reading.  A channel&#xA; * obtained via the {@link java.io.FileOutputStream#getChannel getChannel}&#xA; * method of a {@link java.io.FileOutputStream} instance will be open for&#xA; * writing.  Finally, a channel obtained via the {@link&#xA; * java.io.RandomAccessFile#getChannel getChannel} method of a {@link&#xA; * java.io.RandomAccessFile} instance will be open for reading if the instance&#xA; * was created with mode &lt;tt>&quot;r&quot;&lt;/tt> and will be open for reading and writing&#xA; * if the instance was created with mode &lt;tt>&quot;rw&quot;&lt;/tt>.&#xA; *&#xA; * &lt;a name=&quot;append-mode&quot;>&lt;p> A file channel that is open for writing may be in&#xA; * &lt;i>append mode&lt;/i>, for example if it was obtained from a file-output stream&#xA; * that was created by invoking the {@link&#xA; * java.io.FileOutputStream#FileOutputStream(java.io.File,boolean)&#xA; * FileOutputStream(File,boolean)} constructor and passing &lt;tt>true&lt;/tt> for&#xA; * the second parameter.  In this mode each invocation of a relative write&#xA; * operation first advances the position to the end of the file and then writes&#xA; * the requested data.  Whether the advancement of the position and the writing&#xA; * of the data are done in a single atomic operation is system-dependent and&#xA; * therefore unspecified.&#xA; *&#xA; *&#xA; * @see java.io.FileInputStream#getChannel()&#xA; * @see java.io.FileOutputStream#getChannel()&#xA; * @see java.io.RandomAccessFile#getChannel()&#xA; *&#xA; * @author Mark Reinhold&#xA; * @author Mike McCloskey&#xA; * @author JSR-51 Expert Group&#xA; * @version 1.40, 04/01/12&#xA; * @since 1.4&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="ByteChannel.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="GatheringByteChannel.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="ScatteringByteChannel.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="spi/AbstractInterruptibleChannel.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
