<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="ByteBuffer.java">
  <comments>/*&#xD;&#xA; * @(#)X-Buffer.java&#x9;1.56 04/07/16&#xD;&#xA; *&#xD;&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xD;&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xD;&#xA; */</comments>
  <comments>// -- This file was mechanically generated: Do not edit! -- //</comments>
  <namespaces>java</namespaces>
  <namespaces>nio</namespaces>
  <classifiers xsi:type="classifiers:Class" name="ByteBuffer">
    <members xsi:type="members:Field" name="hb">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// These fields are declared here rather than in Heap-X-Buffer in order to</comments>
        <comments>// reduce the number of virtual method invocations needed to access these</comments>
        <comments>// values, which is especially costly when coding small buffers.</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="offset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// Non-null only for heap buffers</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="isReadOnly">
      <typeReference xsi:type="types:Boolean"/>
    </members>
    <members xsi:type="members:Constructor" name="ByteBuffer">
      <comments>// Valid only for heap buffers</comments>
      <comments>// Creates a new buffer with the given mark, position, limit, capacity,</comments>
      <comments>// backing array, and array offset</comments>
      <comments>//</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.3"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.4"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.5"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mark">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lim">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cap">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hb">
        <typeReference xsi:type="types:Byte">
          <comments>// package-private</comments>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:Constructor" name="ByteBuffer">
      <comments>// Creates a new buffer with the given mark, position, limit, and capacity</comments>
      <comments>//</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.3"/>
          <arguments xsi:type="literals:NullLiteral"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <callTarget xsi:type="literals:This">
            <comments>// package-private</comments>
          </callTarget>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mark">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lim">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cap">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:ClassMethod" name="allocateDirect">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="capacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Allocates a new direct byte buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its limit will be its&#xD;&#xA;     * capacity, and its mark will be undefined.  Whether or not it has a&#xD;&#xA;     * {@link #hasArray &lt;/code>backing array&lt;code>} is unspecified.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  capacity&#xD;&#xA;     *         The new buffer's capacity, in bytes&#xD;&#xA;     *&#xD;&#xA;     * @return  The new byte buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalArgumentException&#xD;&#xA;     *          If the &lt;tt>capacity&lt;/tt> is a negative integer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DirectByteBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="allocate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="capacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Allocates a new byte buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its limit will be its&#xD;&#xA;     * capacity, and its mark will be undefined.  It will have a {@link #array&#xD;&#xA;     * &lt;/code>backing array&lt;code>}, and its {@link #arrayOffset &lt;/code>array&#xD;&#xA;     * offset&lt;code>} will be zero.&#xD;&#xA;     *&#xD;&#xA;     * @param  capacity&#xD;&#xA;     *         The new buffer's capacity, in bytes&#xD;&#xA;     *&#xD;&#xA;     * @return  The new byte buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalArgumentException&#xD;&#xA;     *          If the &lt;tt>capacity&lt;/tt> is a negative integer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="HeapByteBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="wrap">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Wraps a byte array into a buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer will be backed by the given byte array;&#xD;&#xA;     * that is, modifications to the buffer will cause the array to be modified&#xD;&#xA;     * and vice versa.  The new buffer's capacity will be&#xD;&#xA;     * &lt;tt>array.length&lt;/tt>, its position will be &lt;tt>offset&lt;/tt>, its limit&#xD;&#xA;     * will be &lt;tt>offset + length&lt;/tt>, and its mark will be undefined.  Its&#xD;&#xA;     * {@link #array &lt;/code>backing array&lt;code>} will be the given array, and&#xD;&#xA;     * its {@link #arrayOffset &lt;/code>array offset&lt;code>} will be zero.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  array&#xD;&#xA;     *         The array that will back the new buffer&#xD;&#xA;     *&#xD;&#xA;     * @param  offset&#xD;&#xA;     *         The offset of the subarray to be used; must be non-negative and&#xD;&#xA;     *         no larger than &lt;tt>array.length&lt;/tt>.  The new buffer's position&#xD;&#xA;     *         will be set to this value.&#xD;&#xA;     *&#xD;&#xA;     * @param  length&#xD;&#xA;     *         The length of the subarray to be used;&#xD;&#xA;     *         must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>array.length - offset&lt;/tt>.&#xD;&#xA;     *         The new buffer's limit will be set to &lt;tt>offset + length&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * @return  The new byte buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on the &lt;tt>offset&lt;/tt> and &lt;tt>length&lt;/tt>&#xD;&#xA;     *          parameters do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="HeapByteBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.2"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="wrap">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Wraps a byte array into a buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer will be backed by the given byte array;&#xD;&#xA;     * that is, modifications to the buffer will cause the array to be modified&#xD;&#xA;     * and vice versa.  The new buffer's capacity and limit will be&#xD;&#xA;     * &lt;tt>array.length&lt;/tt>, its position will be zero, and its mark will be&#xD;&#xA;     * undefined.  Its {@link #array &lt;/code>backing array&lt;code>} will be the&#xD;&#xA;     * given array, and its {@link #arrayOffset &lt;/code>array offset&lt;code>} will&#xD;&#xA;     * be zero.  &lt;/p> &#xD;&#xA;     *&#xD;&#xA;     * @param  array&#xD;&#xA;     *         The array that will back this buffer&#xD;&#xA;     *&#xD;&#xA;     * @return  The new byte buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="slice">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a new byte buffer whose content is a shared subsequence of&#xD;&#xA;     * this buffer's content.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will start at this buffer's current&#xD;&#xA;     * position.  Changes to this buffer's content will be visible in the new&#xD;&#xA;     * buffer, and vice versa; the two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its capacity and its limit&#xD;&#xA;     * will be the number of bytes remaining in this buffer, and its mark&#xD;&#xA;     * will be undefined.  The new buffer will be direct if, and only if, this&#xD;&#xA;     * buffer is direct, and it will be read-only if, and only if, this buffer&#xD;&#xA;     * is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The new byte buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="duplicate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a new byte buffer that shares this buffer's content.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will be that of this buffer.  Changes&#xD;&#xA;     * to this buffer's content will be visible in the new buffer, and vice&#xD;&#xA;     * versa; the two buffers' position, limit, and mark values will be&#xD;&#xA;     * independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's capacity, limit, position, and mark values will be&#xD;&#xA;     * identical to those of this buffer.  The new buffer will be direct if,&#xD;&#xA;     * and only if, this buffer is direct, and it will be read-only if, and&#xD;&#xA;     * only if, this buffer is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The new byte buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asReadOnlyBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a new, read-only byte buffer that shares this buffer's&#xD;&#xA;     * content.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will be that of this buffer.  Changes&#xD;&#xA;     * to this buffer's content will be visible in the new buffer; the new&#xD;&#xA;     * buffer itself, however, will be read-only and will not allow the shared&#xD;&#xA;     * content to be modified.  The two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's capacity, limit, position, and mark values will be&#xD;&#xA;     * identical to those of this buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> If this buffer is itself read-only then this method behaves in&#xD;&#xA;     * exactly the same way as the {@link #duplicate duplicate} method.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The new, read-only byte buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:Byte"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Singleton get/put methods --</comments>
        <comments>/**&#xD;&#xA;     * Relative &lt;i>get&lt;/i> method.  Reads the byte at this buffer's&#xD;&#xA;     * current position, and then increments the position. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The byte at the buffer's current position&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If the buffer's current position is not smaller than its limit&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     * &#xD;&#xA;     * &lt;p> Writes the given byte into this buffer at the current&#xD;&#xA;     * position, and then increments the position. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  b&#xD;&#xA;     *         The byte to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If this buffer's current position is not smaller than its limit&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:Byte"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>get&lt;/i> method.  Reads the byte at the given&#xD;&#xA;     * index. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index from which the byte will be read&#xD;&#xA;     *&#xD;&#xA;     * @return  The byte at the given index&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     * &#xD;&#xA;     * &lt;p> Writes the given byte into this buffer at the given&#xD;&#xA;     * index. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index at which the byte will be written&#xD;&#xA;     *&#xD;&#xA;     * @param  b&#xD;&#xA;     *         The byte value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Bulk get operations --</comments>
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>get&lt;/i> method.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers bytes from this buffer into the given&#xD;&#xA;     * destination array.  If there are fewer bytes remaining in the&#xD;&#xA;     * buffer than are required to satisfy the request, that is, if&#xD;&#xA;     * &lt;tt>length&lt;/tt>&amp;nbsp;&lt;tt>&amp;gt;&lt;/tt>&amp;nbsp;&lt;tt>remaining()&lt;/tt>, then no&#xD;&#xA;     * bytes are transferred and a {@link BufferUnderflowException} is&#xD;&#xA;     * thrown.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Otherwise, this method copies &lt;tt>length&lt;/tt> bytes from this&#xD;&#xA;     * buffer into the given array, starting at the current position of this&#xD;&#xA;     * buffer and at the given offset in the array.  The position of this&#xD;&#xA;     * buffer is then incremented by &lt;tt>length&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> In other words, an invocation of this method of the form&#xD;&#xA;     * &lt;tt>src.get(dst,&amp;nbsp;off,&amp;nbsp;len)&lt;/tt> has exactly the same effect as&#xD;&#xA;     * the loop&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     for (int i = off; i &lt; off + len; i++)&#xD;&#xA;     *         dst[i] = src.get(); &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * except that it first checks that there are sufficient bytes in&#xD;&#xA;     * this buffer and it is potentially much more efficient. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  dst&#xD;&#xA;     *         The array into which bytes are to be written&#xD;&#xA;     *&#xD;&#xA;     * @param  offset&#xD;&#xA;     *         The offset within the array of the first byte to be&#xD;&#xA;     *         written; must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>dst.length&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @param  length&#xD;&#xA;     *         The maximum number of bytes to be written to the given&#xD;&#xA;     *         array; must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>dst.length - offset&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than &lt;tt>length&lt;/tt> bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on the &lt;tt>offset&lt;/tt> and &lt;tt>length&lt;/tt>&#xD;&#xA;     *          parameters do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.26"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferUnderflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="end">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.3/@init"/>
              </arraySelectors>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>get&lt;/i> method.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers bytes from this buffer into the given&#xD;&#xA;     * destination array.  An invocation of this method of the form&#xD;&#xA;     * &lt;tt>src.get(a)&lt;/tt> behaves in exactly the same way as the invocation&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     src.get(a, 0, a.length) &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than &lt;tt>length&lt;/tt> bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Bulk put operations --</comments>
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers the bytes remaining in the given source&#xD;&#xA;     * buffer into this buffer.  If there are more bytes remaining in the&#xD;&#xA;     * source buffer than in this buffer, that is, if&#xD;&#xA;     * &lt;tt>src.remaining()&lt;/tt>&amp;nbsp;&lt;tt>&amp;gt;&lt;/tt>&amp;nbsp;&lt;tt>remaining()&lt;/tt>,&#xD;&#xA;     * then no bytes are transferred and a {@link&#xD;&#xA;     * BufferOverflowException} is thrown.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Otherwise, this method copies&#xD;&#xA;     * &lt;i>n&lt;/i>&amp;nbsp;=&amp;nbsp;&lt;tt>src.remaining()&lt;/tt> bytes from the given&#xD;&#xA;     * buffer into this buffer, starting at each buffer's current position.&#xD;&#xA;     * The positions of both buffers are then incremented by &lt;i>n&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> In other words, an invocation of this method of the form&#xD;&#xA;     * &lt;tt>dst.put(src)&lt;/tt> has exactly the same effect as the loop&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     while (src.hasRemaining())&#xD;&#xA;     *         dst.put(src.get()); &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * except that it first checks that there is sufficient space in this&#xD;&#xA;     * buffer and it is potentially much more efficient. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  src&#xD;&#xA;     *         The source buffer from which bytes are to be read;&#xD;&#xA;     *         must not be this buffer&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *          for the remaining bytes in the source buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalArgumentException&#xD;&#xA;     *          If the source buffer is this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferOverflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            </arguments>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers bytes into this buffer from the given&#xD;&#xA;     * source array.  If there are more bytes to be copied from the array&#xD;&#xA;     * than remain in this buffer, that is, if&#xD;&#xA;     * &lt;tt>length&lt;/tt>&amp;nbsp;&lt;tt>&amp;gt;&lt;/tt>&amp;nbsp;&lt;tt>remaining()&lt;/tt>, then no&#xD;&#xA;     * bytes are transferred and a {@link BufferOverflowException} is&#xD;&#xA;     * thrown.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Otherwise, this method copies &lt;tt>length&lt;/tt> bytes from the&#xD;&#xA;     * given array into this buffer, starting at the given offset in the array&#xD;&#xA;     * and at the current position of this buffer.  The position of this buffer&#xD;&#xA;     * is then incremented by &lt;tt>length&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> In other words, an invocation of this method of the form&#xD;&#xA;     * &lt;tt>dst.put(src,&amp;nbsp;off,&amp;nbsp;len)&lt;/tt> has exactly the same effect as&#xD;&#xA;     * the loop&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     for (int i = off; i &lt; off + len; i++)&#xD;&#xA;     *         dst.put(a[i]); &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * except that it first checks that there is sufficient space in this&#xD;&#xA;     * buffer and it is potentially much more efficient. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  src&#xD;&#xA;     *         The array from which bytes are to be read&#xD;&#xA;     *&#xD;&#xA;     * @param  offset&#xD;&#xA;     *         The offset within the array of the first byte to be read;&#xD;&#xA;     *         must be non-negative and no larger than &lt;tt>array.length&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @param  length&#xD;&#xA;     *         The number of bytes to be read from the given array;&#xD;&#xA;     *         must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>array.length - offset&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on the &lt;tt>offset&lt;/tt> and &lt;tt>length&lt;/tt>&#xD;&#xA;     *          parameters do not hold&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.26"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferOverflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.2"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="end">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@init"/>
                </arraySelectors>
              </arguments>
            </next>
            <self xsi:type="literals:This"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers the entire content of the given source&#xD;&#xA;     * byte array into this buffer.  An invocation of this method of the&#xD;&#xA;     * form &lt;tt>dst.put(a)&lt;/tt> behaves in exactly the same way as the&#xD;&#xA;     * invocation&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     dst.put(a, 0, a.length) &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasArray">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Other stuff --</comments>
        <comments>/**&#xD;&#xA;     * Tells whether or not this buffer is backed by an accessible byte&#xD;&#xA;     * array.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> If this method returns &lt;tt>true&lt;/tt> then the {@link #array() array}&#xD;&#xA;     * and {@link #arrayOffset() arrayOffset} methods may safely be invoked.&#xD;&#xA;     * &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this buffer&#xD;&#xA;     *          is backed by an array and is not read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="array">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the byte array that backs this&#xD;&#xA;     * buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Modifications to this buffer's content will cause the returned&#xD;&#xA;     * array's content to be modified, and vice versa.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Invoke the {@link #hasArray hasArray} method before invoking this&#xD;&#xA;     * method in order to ensure that this buffer has an accessible backing&#xD;&#xA;     * array.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The array that backs this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is backed by an array but is read-only&#xD;&#xA;     *&#xD;&#xA;     * @throws  UnsupportedOperationException&#xD;&#xA;     *          If this buffer is not backed by an accessible array&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ReadOnlyBufferException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="arrayOffset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the offset within this buffer's backing array of the first&#xD;&#xA;     * element of the buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> If this buffer is backed by an array then buffer position &lt;i>p&lt;/i>&#xD;&#xA;     * corresponds to array index &lt;i>p&lt;/i>&amp;nbsp;+&amp;nbsp;&lt;tt>arrayOffset()&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Invoke the {@link #hasArray hasArray} method before invoking this&#xD;&#xA;     * method in order to ensure that this buffer has an accessible backing&#xD;&#xA;     * array.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The offset within this buffer's array&#xD;&#xA;     *          of the first element of the buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is backed by an array but is read-only&#xD;&#xA;     *&#xD;&#xA;     * @throws  UnsupportedOperationException&#xD;&#xA;     *          If this buffer is not backed by an accessible array&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ReadOnlyBufferException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="compact">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Compacts this buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The bytes between the buffer's current position and its limit,&#xD;&#xA;     * if any, are copied to the beginning of the buffer.  That is, the&#xD;&#xA;     * byte at index &lt;i>p&lt;/i>&amp;nbsp;=&amp;nbsp;&lt;tt>position()&lt;/tt> is copied&#xD;&#xA;     * to index zero, the byte at index &lt;i>p&lt;/i>&amp;nbsp;+&amp;nbsp;1 is copied&#xD;&#xA;     * to index one, and so forth until the byte at index&#xD;&#xA;     * &lt;tt>limit()&lt;/tt>&amp;nbsp;-&amp;nbsp;1 is copied to index&#xD;&#xA;     * &lt;i>n&lt;/i>&amp;nbsp;=&amp;nbsp;&lt;tt>limit()&lt;/tt>&amp;nbsp;-&amp;nbsp;&lt;tt>1&lt;/tt>&amp;nbsp;-&amp;nbsp;&lt;i>p&lt;/i>.&#xD;&#xA;     * The buffer's position is then set to &lt;i>n+1&lt;/i> and its limit is set to&#xD;&#xA;     * its capacity.  The mark, if defined, is discarded.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The buffer's position is set to the number of bytes copied,&#xD;&#xA;     * rather than to zero, so that an invocation of this method can be&#xD;&#xA;     * followed immediately by an invocation of another relative &lt;i>put&lt;/i>&#xD;&#xA;     * method. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Invoke this method after writing data from a buffer in case the&#xD;&#xA;     * write was incomplete.  The following loop, for example, copies bytes&#xD;&#xA;     * from one channel to another via the buffer &lt;tt>buf&lt;/tt>:&#xD;&#xA;     *&#xD;&#xA;     * &lt;blockquote>&lt;pre>&#xD;&#xA;     * buf.clear();          // Prepare buffer for use&#xD;&#xA;     * for (;;) {&#xD;&#xA;     *     if (in.read(buf) &lt; 0 &amp;&amp; !buf.hasRemaining())&#xD;&#xA;     *         break;        // No more bytes to transfer&#xD;&#xA;     *     buf.flip();&#xD;&#xA;     *     out.write(buf);&#xD;&#xA;     *     buf.compact();    // In case of partial write&#xD;&#xA;     * }&lt;/pre>&lt;/blockquote>&#xD;&#xA;     * &#xD;&#xA;&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isDirect">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Tells whether or not this byte buffer is direct. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this buffer is direct&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns a string summarizing the state of this buffer.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  A summary string&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Class.class.xmi#//@classifiers.0/@members.44"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:StringReference" value="[pos="/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.27"/>
            <arguments xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:StringReference" value=" lim="/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.27"/>
            <arguments xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:StringReference" value=" cap="/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.27"/>
            <arguments xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.6"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:StringReference" value="]"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the current hash code of this buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The hash code of a byte buffer depends only upon its remaining&#xD;&#xA;     * elements; that is, upon the elements from &lt;tt>position()&lt;/tt> up to, and&#xD;&#xA;     * including, the element at &lt;tt>limit()&lt;/tt>&amp;nbsp;-&amp;nbsp;&lt;tt>1&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Because buffer hash codes are content-dependent, it is inadvisable&#xD;&#xA;     * to use buffers as keys in hash maps or similar data structures unless it&#xD;&#xA;     * is known that their contents will not change.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The current hash code of this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="h">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="31"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </children>
              <children xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Int"/>
                <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.2/@init"/>
                </child>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.2/@init"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ob">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Tells whether or not this buffer is equal to another object.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Two byte buffers are equal if, and only if,&#xD;&#xA;     *&#xD;&#xA;     * &lt;p>&lt;ol>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> They have the same element type,  &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> They have the same number of remaining elements, and&#xD;&#xA;     *   &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> The two sequences of remaining elements, considered&#xD;&#xA;     *   independently of their starting positions, are pointwise equal.&#xD;&#xA;     *   &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     * &lt;/ol>&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> A byte buffer is not equal to any other type of object.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  ob  The object to which this buffer is to be compared&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this buffer is equal to the&#xD;&#xA;     *           given object&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="that">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v1">
              <typeReference xsi:type="types:Byte"/>
              <initialValue xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.4/@init"/>
                </next>
                <self xsi:type="literals:This"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v2">
              <typeReference xsi:type="types:Byte"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.4/@init/@additionalLocalVariables.0"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Continue">
                  <comments>// For float and double</comments>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.4/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.4/@statement/@statements.0/@variable"/>
                    </expression>
                  </children>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.4/@statement/@statements.1/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.4/@statement/@statements.1/@variable"/>
                    </expression>
                  </children>
                </condition>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.4/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.4/@statement/@statements.1/@variable"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.4/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@variable"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
          <additionalLocalVariables name="j">
            <initialValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
                </next>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </initialValue>
          </additionalLocalVariables>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.4/@init"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.4/@init/@additionalLocalVariables.0"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="that">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Compares this buffer to another.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Two byte buffers are compared by comparing their sequences of&#xD;&#xA;     * remaining elements lexicographically, without regard to the starting&#xD;&#xA;     * position of each sequence within its corresponding buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> A byte buffer is not comparable to any other type of object.&#xD;&#xA;     *&#xD;&#xA;     * @return  A negative integer, zero, or a positive integer as this buffer&#xD;&#xA;     *&#x9;&#x9;is less than, equal to, or greater than the given buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                <arguments xsi:type="references:SelfReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
                  </next>
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
                  </next>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v1">
              <typeReference xsi:type="types:Byte"/>
              <initialValue xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@init"/>
                </next>
                <self xsi:type="literals:This"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v2">
              <typeReference xsi:type="types:Byte"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@init/@additionalLocalVariables.0"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Continue"/>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@statement/@statements.1/@variable"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Continue">
              <comments>// For float and double</comments>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@statement/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@statement/@statements.0/@variable"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@statement/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@statement/@statements.1/@variable"/>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@statement/@statements.1/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Addition"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
          <additionalLocalVariables name="j">
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
              </next>
            </initialValue>
          </additionalLocalVariables>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.1/@init/@additionalLocalVariables.0"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
          </children>
          <additiveOperators xsi:type="operators:Subtraction"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="bigEndian">
      <comments>// package-private</comments>
      <initialValue xsi:type="literals:BooleanLiteral" value="true"/>
      <typeReference xsi:type="types:Boolean">
        <comments>// -- Other char stuff --</comments>
        <comments>// -- Other byte stuff: Access to binary data --</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Field" name="nativeByteOrder">
      <comments>// package-private</comments>
      <initialValue xsi:type="expressions:NestedExpression">
        <expression xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Bits.class.xmi#//@classifiers.0/@members.111"/>
            </next>
            <target xsi:type="classifiers:Class" href="Bits.class.xmi#//@classifiers.0"/>
          </children>
          <children xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="ByteOrder.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="ByteOrder.class.xmi#//@classifiers.0"/>
          </children>
        </expression>
      </initialValue>
      <typeReference xsi:type="types:Boolean"/>
    </members>
    <members xsi:type="members:ClassMethod" name="order">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ByteOrder.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Retrieves this buffer's byte order.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The byte order is used when reading or writing multibyte values, and&#xD;&#xA;     * when creating buffers that are views of this byte buffer.  The order of&#xD;&#xA;     * a newly-created byte buffer is always {@link ByteOrder#BIG_ENDIAN&#xD;&#xA;     * BIG_ENDIAN}.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer's byte order&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30"/>
          <expressionIf xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="ByteOrder.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="ByteOrder.class.xmi#//@classifiers.0"/>
          </expressionIf>
          <expressionElse xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="ByteOrder.class.xmi#//@classifiers.0/@members.2"/>
            </next>
            <target xsi:type="classifiers:Class" href="ByteOrder.class.xmi#//@classifiers.0"/>
          </expressionElse>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="order">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bo">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ByteOrder.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Modifies this buffer's byte order.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  bo&#xD;&#xA;     *         The new byte order,&#xD;&#xA;     *         either {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}&#xD;&#xA;     *         or {@link ByteOrder#LITTLE_ENDIAN LITTLE_ENDIAN}&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="ByteOrder.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="ByteOrder.class.xmi#//@classifiers.0"/>
              </children>
            </expression>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="Bits.class.xmi#//@classifiers.0/@members.111"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="Bits.class.xmi#//@classifiers.0"/>
                  </children>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="ByteOrder.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="ByteOrder.class.xmi#//@classifiers.0"/>
                  </children>
                </expression>
              </children>
            </expression>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="_get">
      <typeReference xsi:type="types:Byte"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>// Unchecked accessors, for use by ByteBufferAs-X-Buffer classes</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="_put">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Abstract">
        <comments>// package-private</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getChar">
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// package-private</comments>
        <comments>/**&#xD;&#xA;     * Relative &lt;i>get&lt;/i> method for reading a char value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads the next two bytes at this buffer's current position,&#xD;&#xA;     * composing them into a char value according to the current byte order,&#xD;&#xA;     * and then increments the position by two.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The char value at the buffer's current position&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than two bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putChar">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>put&lt;/i> method for writing a char&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes two bytes containing the given char value, in the&#xD;&#xA;     * current byte order, into this buffer at the current position, and then&#xD;&#xA;     * increments the position by two.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The char value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there are fewer than two bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getChar">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>get&lt;/i> method for reading a char value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads two bytes at the given index, composing them into a&#xD;&#xA;     * char value according to the current byte order.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index from which the bytes will be read&#xD;&#xA;     *&#xD;&#xA;     * @return  The char value at the given index&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus one&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putChar">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>put&lt;/i> method for writing a char&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes two bytes containing the given char value, in the&#xD;&#xA;     * current byte order, into this buffer at the given index.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index at which the bytes will be written&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The char value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus one&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asCharBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CharBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a view of this byte buffer as a char buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will start at this buffer's current&#xD;&#xA;     * position.  Changes to this buffer's content will be visible in the new&#xD;&#xA;     * buffer, and vice versa; the two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its capacity and its limit&#xD;&#xA;     * will be the number of bytes remaining in this buffer divided by&#xD;&#xA;     * two, and its mark will be undefined.  The new buffer will be direct&#xD;&#xA;     * if, and only if, this buffer is direct, and it will be read-only if, and&#xD;&#xA;     * only if, this buffer is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  A new char buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getShort">
      <typeReference xsi:type="types:Short"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>get&lt;/i> method for reading a short value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads the next two bytes at this buffer's current position,&#xD;&#xA;     * composing them into a short value according to the current byte order,&#xD;&#xA;     * and then increments the position by two.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The short value at the buffer's current position&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than two bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putShort">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Short"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>put&lt;/i> method for writing a short&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes two bytes containing the given short value, in the&#xD;&#xA;     * current byte order, into this buffer at the current position, and then&#xD;&#xA;     * increments the position by two.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The short value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there are fewer than two bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getShort">
      <typeReference xsi:type="types:Short"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>get&lt;/i> method for reading a short value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads two bytes at the given index, composing them into a&#xD;&#xA;     * short value according to the current byte order.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index from which the bytes will be read&#xD;&#xA;     *&#xD;&#xA;     * @return  The short value at the given index&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus one&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putShort">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Short"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>put&lt;/i> method for writing a short&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes two bytes containing the given short value, in the&#xD;&#xA;     * current byte order, into this buffer at the given index.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index at which the bytes will be written&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The short value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus one&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asShortBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ShortBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a view of this byte buffer as a short buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will start at this buffer's current&#xD;&#xA;     * position.  Changes to this buffer's content will be visible in the new&#xD;&#xA;     * buffer, and vice versa; the two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its capacity and its limit&#xD;&#xA;     * will be the number of bytes remaining in this buffer divided by&#xD;&#xA;     * two, and its mark will be undefined.  The new buffer will be direct&#xD;&#xA;     * if, and only if, this buffer is direct, and it will be read-only if, and&#xD;&#xA;     * only if, this buffer is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  A new short buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getInt">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>get&lt;/i> method for reading an int value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads the next four bytes at this buffer's current position,&#xD;&#xA;     * composing them into an int value according to the current byte order,&#xD;&#xA;     * and then increments the position by four.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The int value at the buffer's current position&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than four bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putInt">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>put&lt;/i> method for writing an int&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes four bytes containing the given int value, in the&#xD;&#xA;     * current byte order, into this buffer at the current position, and then&#xD;&#xA;     * increments the position by four.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The int value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there are fewer than four bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getInt">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>get&lt;/i> method for reading an int value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads four bytes at the given index, composing them into a&#xD;&#xA;     * int value according to the current byte order.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index from which the bytes will be read&#xD;&#xA;     *&#xD;&#xA;     * @return  The int value at the given index&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus three&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putInt">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>put&lt;/i> method for writing an int&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes four bytes containing the given int value, in the&#xD;&#xA;     * current byte order, into this buffer at the given index.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index at which the bytes will be written&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The int value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus three&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asIntBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IntBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a view of this byte buffer as an int buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will start at this buffer's current&#xD;&#xA;     * position.  Changes to this buffer's content will be visible in the new&#xD;&#xA;     * buffer, and vice versa; the two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its capacity and its limit&#xD;&#xA;     * will be the number of bytes remaining in this buffer divided by&#xD;&#xA;     * four, and its mark will be undefined.  The new buffer will be direct&#xD;&#xA;     * if, and only if, this buffer is direct, and it will be read-only if, and&#xD;&#xA;     * only if, this buffer is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  A new int buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLong">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>get&lt;/i> method for reading a long value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads the next eight bytes at this buffer's current position,&#xD;&#xA;     * composing them into a long value according to the current byte order,&#xD;&#xA;     * and then increments the position by eight.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The long value at the buffer's current position&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than eight bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putLong">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>put&lt;/i> method for writing a long&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes eight bytes containing the given long value, in the&#xD;&#xA;     * current byte order, into this buffer at the current position, and then&#xD;&#xA;     * increments the position by eight.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The long value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there are fewer than eight bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLong">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>get&lt;/i> method for reading a long value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads eight bytes at the given index, composing them into a&#xD;&#xA;     * long value according to the current byte order.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index from which the bytes will be read&#xD;&#xA;     *&#xD;&#xA;     * @return  The long value at the given index&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus seven&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putLong">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>put&lt;/i> method for writing a long&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes eight bytes containing the given long value, in the&#xD;&#xA;     * current byte order, into this buffer at the given index.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index at which the bytes will be written&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The long value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus seven&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asLongBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="LongBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a view of this byte buffer as a long buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will start at this buffer's current&#xD;&#xA;     * position.  Changes to this buffer's content will be visible in the new&#xD;&#xA;     * buffer, and vice versa; the two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its capacity and its limit&#xD;&#xA;     * will be the number of bytes remaining in this buffer divided by&#xD;&#xA;     * eight, and its mark will be undefined.  The new buffer will be direct&#xD;&#xA;     * if, and only if, this buffer is direct, and it will be read-only if, and&#xD;&#xA;     * only if, this buffer is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  A new long buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFloat">
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>get&lt;/i> method for reading a float value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads the next four bytes at this buffer's current position,&#xD;&#xA;     * composing them into a float value according to the current byte order,&#xD;&#xA;     * and then increments the position by four.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The float value at the buffer's current position&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than four bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putFloat">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>put&lt;/i> method for writing a float&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes four bytes containing the given float value, in the&#xD;&#xA;     * current byte order, into this buffer at the current position, and then&#xD;&#xA;     * increments the position by four.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The float value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there are fewer than four bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFloat">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>get&lt;/i> method for reading a float value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads four bytes at the given index, composing them into a&#xD;&#xA;     * float value according to the current byte order.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index from which the bytes will be read&#xD;&#xA;     *&#xD;&#xA;     * @return  The float value at the given index&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus three&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putFloat">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>put&lt;/i> method for writing a float&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes four bytes containing the given float value, in the&#xD;&#xA;     * current byte order, into this buffer at the given index.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index at which the bytes will be written&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The float value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus three&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asFloatBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FloatBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a view of this byte buffer as a float buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will start at this buffer's current&#xD;&#xA;     * position.  Changes to this buffer's content will be visible in the new&#xD;&#xA;     * buffer, and vice versa; the two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its capacity and its limit&#xD;&#xA;     * will be the number of bytes remaining in this buffer divided by&#xD;&#xA;     * four, and its mark will be undefined.  The new buffer will be direct&#xD;&#xA;     * if, and only if, this buffer is direct, and it will be read-only if, and&#xD;&#xA;     * only if, this buffer is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  A new float buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDouble">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>get&lt;/i> method for reading a double value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads the next eight bytes at this buffer's current position,&#xD;&#xA;     * composing them into a double value according to the current byte order,&#xD;&#xA;     * and then increments the position by eight.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The double value at the buffer's current position&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than eight bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putDouble">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>put&lt;/i> method for writing a double&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes eight bytes containing the given double value, in the&#xD;&#xA;     * current byte order, into this buffer at the current position, and then&#xD;&#xA;     * increments the position by eight.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The double value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there are fewer than eight bytes&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDouble">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>get&lt;/i> method for reading a double value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Reads eight bytes at the given index, composing them into a&#xD;&#xA;     * double value according to the current byte order.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index from which the bytes will be read&#xD;&#xA;     *&#xD;&#xA;     * @return  The double value at the given index&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus seven&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="putDouble">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="value">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>put&lt;/i> method for writing a double&#xD;&#xA;     * value&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Writes eight bytes containing the given double value, in the&#xD;&#xA;     * current byte order, into this buffer at the given index.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index at which the bytes will be written&#xD;&#xA;     *&#xD;&#xA;     * @param  value&#xD;&#xA;     *         The double value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit,&#xD;&#xA;     *          minus seven&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asDoubleBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DoubleBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a view of this byte buffer as a double buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will start at this buffer's current&#xD;&#xA;     * position.  Changes to this buffer's content will be visible in the new&#xD;&#xA;     * buffer, and vice versa; the two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its capacity and its limit&#xD;&#xA;     * will be the number of bytes remaining in this buffer divided by&#xD;&#xA;     * eight, and its mark will be undefined.  The new buffer will be direct&#xD;&#xA;     * if, and only if, this buffer is direct, and it will be read-only if, and&#xD;&#xA;     * only if, this buffer is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  A new double buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xD;&#xA; * A byte buffer.&#xD;&#xA; *&#xD;&#xA; * &lt;p> This class defines six categories of operations upon&#xD;&#xA; * byte buffers:&#xD;&#xA; *&#xD;&#xA; * &lt;ul>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Absolute and relative {@link #get() &lt;/code>&lt;i>get&lt;/i>&lt;code>} and&#xD;&#xA; *   {@link #put(byte) &lt;/code>&lt;i>put&lt;/i>&lt;code>} methods that read and write&#xD;&#xA; *   single bytes; &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Relative {@link #get(byte[]) &lt;/code>&lt;i>bulk get&lt;/i>&lt;code>}&#xD;&#xA; *   methods that transfer contiguous sequences of bytes from this buffer&#xD;&#xA; *   into an array; &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Relative {@link #put(byte[]) &lt;/code>&lt;i>bulk put&lt;/i>&lt;code>}&#xD;&#xA; *   methods that transfer contiguous sequences of bytes from a&#xD;&#xA; *   byte array or some other byte&#xD;&#xA; *   buffer into this buffer; &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Absolute and relative {@link #getChar() &lt;/code>&lt;i>get&lt;/i>&lt;code>}&#xD;&#xA; *   and {@link #putChar(char) &lt;/code>&lt;i>put&lt;/i>&lt;code>} methods that read and&#xD;&#xA; *   write values of other primitive types, translating them to and from&#xD;&#xA; *   sequences of bytes in a particular byte order; &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Methods for creating &lt;i>&lt;a href=&quot;#views&quot;>view buffers&lt;/a>&lt;/i>,&#xD;&#xA; *   which allow a byte buffer to be viewed as a buffer containing values of&#xD;&#xA; *   some other primitive type; and &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Methods for {@link #compact &lt;/code>compacting&lt;code>}, {@link&#xD;&#xA; *   #duplicate &lt;/code>duplicating&lt;code>}, and {@link #slice&#xD;&#xA; *   &lt;/code>slicing&lt;code>} a byte buffer.  &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; * &lt;/ul>&#xD;&#xA; *&#xD;&#xA; * &lt;p> Byte buffers can be created either by {@link #allocate&#xD;&#xA; * &lt;/code>&lt;i>allocation&lt;/i>&lt;code>}, which allocates space for the buffer's&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * content, or by {@link #wrap(byte[]) &lt;/code>&lt;i>wrapping&lt;/i>&lt;code>} an&#xD;&#xA; * existing byte array  into a buffer.&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * &lt;a name=&quot;direct&quot;>&#xD;&#xA; * &lt;h4> Direct &lt;i>vs.&lt;/i> non-direct buffers &lt;/h4>&#xD;&#xA; *&#xD;&#xA; * &lt;p> A byte buffer is either &lt;i>direct&lt;/i> or &lt;i>non-direct&lt;/i>.  Given a&#xD;&#xA; * direct byte buffer, the Java virtual machine will make a best effort to&#xD;&#xA; * perform native I/O operations directly upon it.  That is, it will attempt to&#xD;&#xA; * avoid copying the buffer's content to (or from) an intermediate buffer&#xD;&#xA; * before (or after) each invocation of one of the underlying operating&#xD;&#xA; * system's native I/O operations.&#xD;&#xA; *&#xD;&#xA; * &lt;p> A direct byte buffer may be created by invoking the {@link&#xD;&#xA; * #allocateDirect(int) allocateDirect} factory method of this class.  The&#xD;&#xA; * buffers returned by this method typically have somewhat higher allocation&#xD;&#xA; * and deallocation costs than non-direct buffers.  The contents of direct&#xD;&#xA; * buffers may reside outside of the normal garbage-collected heap, and so&#xD;&#xA; * their impact upon the memory footprint of an application might not be&#xD;&#xA; * obvious.  It is therefore recommended that direct buffers be allocated&#xD;&#xA; * primarily for large, long-lived buffers that are subject to the underlying&#xD;&#xA; * system's native I/O operations.  In general it is best to allocate direct&#xD;&#xA; * buffers only when they yield a measureable gain in program performance.&#xD;&#xA; *&#xD;&#xA; * &lt;p> A direct byte buffer may also be created by {@link&#xD;&#xA; * java.nio.channels.FileChannel#map &lt;/code>mapping&lt;code>} a region of a file&#xD;&#xA; * directly into memory.  An implementation of the Java platform may optionally&#xD;&#xA; * support the creation of direct byte buffers from native code via JNI.  If an&#xD;&#xA; * instance of one of these kinds of buffers refers to an inaccessible region&#xD;&#xA; * of memory then an attempt to access that region will not change the buffer's&#xD;&#xA; * content and will cause an unspecified exception to be thrown either at the&#xD;&#xA; * time of the access or at some later time.&#xD;&#xA; *&#xD;&#xA; * &lt;p> Whether a byte buffer is direct or non-direct may be determined by&#xD;&#xA; * invoking its {@link #isDirect isDirect} method.  This method is provided so&#xD;&#xA; * that explicit buffer management can be done in performance-critical code.&#xD;&#xA; *&#xD;&#xA; *&#xD;&#xA; * &lt;a name=&quot;bin&quot;>&#xD;&#xA; * &lt;h4> Access to binary data &lt;/h4>&#xD;&#xA; *&#xD;&#xA; * &lt;p> This class defines methods for reading and writing values of all other&#xD;&#xA; * primitive types, except &lt;tt>boolean&lt;/tt>.  Primitive values are translated&#xD;&#xA; * to (or from) sequences of bytes according to the buffer's current byte&#xD;&#xA; * order, which may be retrieved and modified via the {@link #order order}&#xD;&#xA; * methods.  Specific byte orders are represented by instances of the {@link&#xD;&#xA; * ByteOrder} class.  The initial order of a byte buffer is always {@link&#xD;&#xA; * ByteOrder#BIG_ENDIAN BIG_ENDIAN}.&#xD;&#xA; *&#xD;&#xA; * &lt;p> For access to heterogeneous binary data, that is, sequences of values of&#xD;&#xA; * different types, this class defines a family of absolute and relative&#xD;&#xA; * &lt;i>get&lt;/i> and &lt;i>put&lt;/i> methods for each type.  For 32-bit floating-point&#xD;&#xA; * values, for example, this class defines:&#xD;&#xA; *&#xD;&#xA; * &lt;blockquote>&lt;pre>&#xD;&#xA; * float  {@link #getFloat()}&#xD;&#xA; * float  {@link #getFloat(int) getFloat(int index)}&#xD;&#xA; *  void  {@link #putFloat(float) putFloat(float f)}&#xD;&#xA; *  void  {@link #putFloat(int,float) putFloat(int index, float f)}&lt;/pre>&lt;/blockquote>&#xD;&#xA; *&#xD;&#xA; * &lt;p> Corresponding methods are defined for the types &lt;tt>char&lt;/tt>,&#xD;&#xA; * &lt;tt>short&lt;/tt>, &lt;tt>int&lt;/tt>, &lt;tt>long&lt;/tt>, and &lt;tt>double&lt;/tt>.  The index&#xD;&#xA; * parameters of the absolute &lt;i>get&lt;/i> and &lt;i>put&lt;/i> methods are in terms of&#xD;&#xA; * bytes rather than of the type being read or written.&#xD;&#xA; *&#xD;&#xA; * &lt;a name=&quot;views&quot;>&#xD;&#xA; *&#xD;&#xA; * &lt;p> For access to homogeneous binary data, that is, sequences of values of&#xD;&#xA; * the same type, this class defines methods that can create &lt;i>views&lt;/i> of a&#xD;&#xA; * given byte buffer.  A &lt;i>view buffer&lt;/i> is simply another buffer whose&#xD;&#xA; * content is backed by the byte buffer.  Changes to the byte buffer's content&#xD;&#xA; * will be visible in the view buffer, and vice versa; the two buffers'&#xD;&#xA; * position, limit, and mark values are independent.  The {@link&#xD;&#xA; * #asFloatBuffer() asFloatBuffer} method, for example, creates an instance of&#xD;&#xA; * the {@link FloatBuffer} class that is backed by the byte buffer upon which&#xD;&#xA; * the method is invoked.  Corresponding view-creation methods are defined for&#xD;&#xA; * the types &lt;tt>char&lt;/tt>, &lt;tt>short&lt;/tt>, &lt;tt>int&lt;/tt>, &lt;tt>long&lt;/tt>, and&#xD;&#xA; * &lt;tt>double&lt;/tt>.&#xD;&#xA; *&#xD;&#xA; * &lt;p> View buffers have three important advantages over the families of&#xD;&#xA; * type-specific &lt;i>get&lt;/i> and &lt;i>put&lt;/i> methods described above:&#xD;&#xA; *&#xD;&#xA; * &lt;ul>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> A view buffer is indexed not in terms of bytes but rather in terms&#xD;&#xA; *   of the type-specific size of its values;  &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> A view buffer provides relative bulk &lt;i>get&lt;/i> and &lt;i>put&lt;/i>&#xD;&#xA; *   methods that can transfer contiguous sequences of values between a buffer&#xD;&#xA; *   and an array or some other buffer of the same type; and  &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> A view buffer is potentially much more efficient because it will&#xD;&#xA; *   be direct if, and only if, its backing byte buffer is direct.  &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; * &lt;/ul>&#xD;&#xA; *&#xD;&#xA; * &lt;p> The byte order of a view buffer is fixed to be that of its byte buffer&#xD;&#xA; * at the time that the view is created.  &lt;/p>&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;*&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;*&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA; * &lt;h4> Invocation chaining &lt;/h4>&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * &lt;p> Methods in this class that do not otherwise have a value to return are&#xD;&#xA; * specified to return the buffer upon which they are invoked.  This allows&#xD;&#xA; * method invocations to be chained.&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * The sequence of statements&#xD;&#xA; *&#xD;&#xA; * &lt;blockquote>&lt;pre>&#xD;&#xA; * bb.putInt(0xCAFEBABE);&#xD;&#xA; * bb.putShort(3);&#xD;&#xA; * bb.putShort(45);&lt;/pre>&lt;/blockquote>&#xD;&#xA; *&#xD;&#xA; * can, for example, be replaced by the single statement&#xD;&#xA; *&#xD;&#xA; * &lt;blockquote>&lt;pre>&#xD;&#xA; * bb.putInt(0xCAFEBABE).putShort(3).putShort(45);&lt;/pre>&lt;/blockquote>&#xD;&#xA; * &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; *&#xD;&#xA; * @author Mark Reinhold&#xD;&#xA; * @author JSR-51 Expert Group&#xD;&#xA; * @version 1.56, 04/07/16&#xD;&#xA; * @since 1.4&#xD;&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../lang/Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Buffer.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
