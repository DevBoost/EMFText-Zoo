<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="CharsetEncoder.java">
  <comments>/*&#xD;&#xA; * @(#)Charset-X-Coder.java&#x9;1.42 05/03/03&#xD;&#xA; *&#xD;&#xA; * Copyright 2005 Sun Microsystems, Inc. All rights reserved.&#xD;&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xD;&#xA; */</comments>
  <comments>// -- This file was mechanically generated: Do not edit! -- //</comments>
  <namespaces>java</namespaces>
  <namespaces>nio</namespaces>
  <namespaces>charset</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../Buffer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../BufferOverflowException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <classifier xsi:type="classifiers:Class" href="../BufferUnderflowException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <namespaces>ref</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../lang/ref/WeakReference.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>charset</namespaces>
    <classifier xsi:type="classifiers:Class" href="CoderMalfunctionError.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="CharsetEncoder">
    <members xsi:type="members:Field" name="charset">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Charset.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="averageBytesPerChar">
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="maxBytesPerChar">
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="replacement">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="malformedInputAction">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="CodingErrorAction.class.xmi#//@classifiers.0/@members.3"/>
        </next>
        <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="unmappableCharacterAction">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="CodingErrorAction.class.xmi#//@classifiers.0/@members.3"/>
        </next>
        <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="ST_RESET">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Internal states</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ST_CODING">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ST_END">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="ST_FLUSHED">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="state">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="stateNames">
      <initialValue xsi:type="arrays:ArrayInstantiationByValues">
        <arrayInitializer>
          <initialValues xsi:type="references:StringReference" value="RESET"/>
          <initialValues xsi:type="references:StringReference" value="CODING"/>
          <initialValues xsi:type="references:StringReference" value="CODING_END"/>
          <initialValues xsi:type="references:StringReference" value="FLUSHED"/>
        </arrayInitializer>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsAfter/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Constructor" name="CharsetEncoder">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Non-positive "/>
              <children xsi:type="references:StringReference" value="averageBytesPerChar"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
          <children xsi:type="literals:DecimalFloatLiteral"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Non-positive "/>
              <children xsi:type="references:StringReference" value="maxBytesPerChar"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.2"/>
          <children xsi:type="literals:DecimalFloatLiteral"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:StringReference" value="averageBytesPerChar"/>
                  <children xsi:type="references:StringReference" value=" exceeds "/>
                  <children xsi:type="references:StringReference" value="maxBytesPerChar"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </arguments>
              </throwable>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.2"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Charset.class.xmi#//@classifiers.0/@members.12"/>
              <arguments xsi:type="references:StringReference" value="1.4"/>
            </next>
            <target xsi:type="classifiers:Class" href="Charset.class.xmi#//@classifiers.0"/>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.3"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.3"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Charset.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="averageBytesPerChar">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="maxBytesPerChar">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="replacement">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xD;&#xA;     * Initializes a new encoder.  The new encoder will have the given&#xD;&#xA;     * bytes-per-char and replacement values. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  averageBytesPerChar&#xD;&#xA;     *         A positive float value indicating the expected number of&#xD;&#xA;     *         bytes that will be produced for each input character&#xD;&#xA;     *&#xD;&#xA;     * @param  maxBytesPerChar&#xD;&#xA;     *         A positive float value indicating the maximum number of&#xD;&#xA;     *         bytes that will be produced for each input character&#xD;&#xA;     *&#xD;&#xA;     * @param  replacement&#xD;&#xA;     *         The initial replacement; must not be &lt;tt>null&lt;/tt>, must have&#xD;&#xA;     *         non-zero length, must not be longer than maxBytesPerChar,&#xD;&#xA;     *         and must be {@link #isLegalReplacement &lt;/code>legal&lt;code>}&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalArgumentException&#xD;&#xA;     *          If the preconditions on the parameters do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="CharsetEncoder">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
          <arguments xsi:type="arrays:ArrayInstantiationByValues">
            <typeReference xsi:type="types:Byte"/>
            <arrayDimensionsBefore/>
            <arrayInitializer>
              <initialValues xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Byte"/>
                <child xsi:type="literals:CharacterLiteral" value="63"/>
              </initialValues>
            </arrayInitializer>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Charset.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="averageBytesPerChar">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="maxBytesPerChar">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xD;&#xA;     * Initializes a new encoder.  The new encoder will have the given&#xD;&#xA;     * bytes-per-char values and its replacement will be the&#xD;&#xA;     * byte array &lt;tt>{&lt;/tt>&amp;nbsp;&lt;tt>(byte)'?'&lt;/tt>&amp;nbsp;&lt;tt>}&lt;/tt>. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  averageBytesPerChar&#xD;&#xA;     *         A positive float value indicating the expected number of&#xD;&#xA;     *         bytes that will be produced for each input character&#xD;&#xA;     *&#xD;&#xA;     * @param  maxBytesPerChar&#xD;&#xA;     *         A positive float value indicating the maximum number of&#xD;&#xA;     *         bytes that will be produced for each input character&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalArgumentException&#xD;&#xA;     *          If the preconditions on the parameters do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="charset">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Charset.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the charset that created this encoder.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  This encoder's charset&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replacement">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns this encoder's replacement value. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  This encoder's current replacement,&#xD;&#xA;     *          which is never &lt;tt>null&lt;/tt> and is never empty&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="replaceWith">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newReplacement">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Changes this encoder's replacement value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method invokes the {@link #implReplaceWith implReplaceWith}&#xD;&#xA;     * method, passing the new replacement, after checking that the new&#xD;&#xA;     * replacement is acceptable.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  newReplacement&#xD;&#xA;     *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;     *         The new replacement; must not be &lt;tt>null&lt;/tt>, must have&#xD;&#xA;     *         non-zero length, must not be longer than the value returned by&#xD;&#xA;     *         the {@link #maxBytesPerChar maxBytesPerChar} method, and&#xD;&#xA;     *         must be {@link #isLegalReplacement &lt;/code>legal&lt;code>}&#xD;&#xA;&#xD;&#xA;     *&#xD;&#xA;     * @return  This encoder&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalArgumentException&#xD;&#xA;     *          If the preconditions on the parameter do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Null replacement"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Empty replacement"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.1/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Replacement too long"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.1/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Illegal replacement"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.17">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="implReplaceWith">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newReplacement">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xD;&#xA;     * Reports a change to this encoder's replacement value.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The default implementation of this method does nothing.  This method&#xD;&#xA;     * should be overridden by encoders that require notification of changes to&#xD;&#xA;     * the replacement.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  newReplacement&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="cachedDecoder">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/ref/WeakReference.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:ClassMethod" name="isLegalReplacement">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="repl">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Tells whether or not the given byte array is a legal replacement value&#xD;&#xA;     * for this encoder.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> A replacement is legal if, and only if, it is a legal sequence of&#xD;&#xA;     * bytes in this encoder's charset; that is, it must be possible to decode&#xD;&#xA;     * the replacement into one or more sixteen-bit Unicode characters.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The default implementation of this method is not very efficient; it&#xD;&#xA;     * should generally be overridden to improve performance.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  repl  The byte array to be tested&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, the given byte array&#xD;&#xA;     *          is a legal replacement value for this encoder&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="wr">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/ref/WeakReference.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dec">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="CharsetDecoder.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Charset.class.xmi#//@classifiers.0/@members.33"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CharsetDecoder.class.xmi#//@classifiers.0/@members.20"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="CodingErrorAction.class.xmi#//@classifiers.0/@members.3"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CharsetDecoder.class.xmi#//@classifiers.0/@members.23"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="CodingErrorAction.class.xmi#//@classifiers.0/@members.3"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
                </arguments>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../lang/ref/WeakReference.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="CharsetDecoder.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.0/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../lang/ref/Reference.class.xmi#//@classifiers.0/@members.6"/>
                      </next>
                    </child>
                  </value>
                </expression>
              </children>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CharsetDecoder.class.xmi#//@classifiers.0/@members.30"/>
              </next>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../ByteBuffer.class.xmi#//@classifiers.0/@members.10"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// We need to perform double, not float, arithmetic; otherwise</comments>
              <comments>// we lose low order bits when src is larger than 2**24.</comments>
              <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../CharBuffer.class.xmi#//@classifiers.0/@members.5"/>
              <arguments xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Int"/>
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:MultiplicativeExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../Buffer.class.xmi#//@classifiers.0/@members.16"/>
                      </next>
                    </children>
                    <children xsi:type="expressions:CastExpression">
                      <typeReference xsi:type="types:Double"/>
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="CharsetDecoder.class.xmi#//@classifiers.0/@members.26"/>
                        </next>
                      </child>
                    </children>
                    <multiplicativeOperators xsi:type="operators:Multiplication"/>
                  </expression>
                </child>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cr">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="CoderResult.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="CharsetDecoder.class.xmi#//@classifiers.0/@members.27"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.4/@variable"/>
              <arguments xsi:type="literals:BooleanLiteral" value="true"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.5/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="CoderResult.class.xmi#//@classifiers.0/@members.17"/>
            </next>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="malformedInputAction">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns this encoder's current action for malformed-input errors.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return The current malformed-input action, which is never &lt;tt>null&lt;/tt>&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="onMalformedInput">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newAction">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Changes this encoder's action for malformed-input errors.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method invokes the {@link #implOnMalformedInput&#xD;&#xA;     * implOnMalformedInput} method, passing the new action.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  newAction  The new action; must not be &lt;tt>null&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @return  This encoder&#xD;&#xA;     *&#xD;&#xA;     * @throws IllegalArgumentException&#xD;&#xA;     *         If the precondition on the parameter does not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Null action"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="implOnMalformedInput">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newAction">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xD;&#xA;     * Reports a change to this encoder's malformed-input action.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The default implementation of this method does nothing.  This method&#xD;&#xA;     * should be overridden by encoders that require notification of changes to&#xD;&#xA;     * the malformed-input action.  &lt;/p>&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="unmappableCharacterAction">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns this encoder's current action for unmappable-character errors.&#xD;&#xA;     * &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return The current unmappable-character action, which is never&#xD;&#xA;     *         &lt;tt>null&lt;/tt>&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="onUnmappableCharacter">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newAction">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Changes this encoder's action for unmappable-character errors.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method invokes the {@link #implOnUnmappableCharacter&#xD;&#xA;     * implOnUnmappableCharacter} method, passing the new action.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  newAction  The new action; must not be &lt;tt>null&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @return  This encoder&#xD;&#xA;     *&#xD;&#xA;     * @throws IllegalArgumentException&#xD;&#xA;     *         If the precondition on the parameter does not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Null action"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="implOnUnmappableCharacter">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newAction">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xD;&#xA;     * Reports a change to this encoder's unmappable-character action.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The default implementation of this method does nothing.  This method&#xD;&#xA;     * should be overridden by encoders that require notification of changes to&#xD;&#xA;     * the unmappable-character action.  &lt;/p>&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="averageBytesPerChar">
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the average number of bytes that will be produced for each&#xD;&#xA;     * character of input.  This heuristic value may be used to estimate the size&#xD;&#xA;     * of the output buffer required for a given input sequence. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The average number of bytes produced&#xD;&#xA;     *          per character of input&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="maxBytesPerChar">
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the maximum number of bytes that will be produced for each&#xD;&#xA;     * character of input.  This value may be used to compute the worst-case size&#xD;&#xA;     * of the output buffer required for a given input sequence. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The maximum number of bytes that will be produced per&#xD;&#xA;     *          character of input&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="encode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CoderResult.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="in">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="endOfInput">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Encodes as many characters as possible from the given input buffer,&#xD;&#xA;     * writing the results to the given output buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The buffers are read from, and written to, starting at their current&#xD;&#xA;     * positions.  At most {@link Buffer#remaining in.remaining()} characters&#xD;&#xA;     * will be read and at most {@link Buffer#remaining out.remaining()}&#xD;&#xA;     * bytes will be written.  The buffers' positions will be advanced to&#xD;&#xA;     * reflect the characters read and the bytes written, but their marks and&#xD;&#xA;     * limits will not be modified.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> In addition to reading characters from the input buffer and writing&#xD;&#xA;     * bytes to the output buffer, this method returns a {@link CoderResult}&#xD;&#xA;     * object to describe its reason for termination:&#xD;&#xA;     *&#xD;&#xA;     * &lt;ul>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> {@link CoderResult#UNDERFLOW} indicates that as much of the&#xD;&#xA;     *   input buffer as possible has been encoded.  If there are no characters&#xD;&#xA;     *   remaining and the invoker has no further input then the encoding&#xD;&#xA;     *   operation is complete.  Otherwise there is insufficient input for the&#xD;&#xA;     *   operation to proceed, so this method should be invoked again with&#xD;&#xA;     *   further input.  &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> {@link CoderResult#OVERFLOW} indicates that the output buffer&#xD;&#xA;     *   is full.  This method should be invoked again with a non-full output&#xD;&#xA;     *   buffer.  &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> A {@link CoderResult#malformedForLength&#xD;&#xA;     *   &lt;/code>malformed-input&lt;code>} result indicates that a malformed-input&#xD;&#xA;     *   error has been detected.  The malformed characters begin at the input&#xD;&#xA;     *   buffer's (possibly incremented) position; the number of malformed&#xD;&#xA;     *   characters may be determined by invoking the result object's {@link&#xD;&#xA;     *   CoderResult#length length} method.  This case applies only if the&#xD;&#xA;     *   {@link #onMalformedInput &lt;/code>malformed action&lt;code>} of this encoder&#xD;&#xA;     *   is {@link CodingErrorAction#REPORT}; otherwise the malformed input&#xD;&#xA;     *   will be ignored or replaced, as requested.  &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> An {@link CoderResult#unmappableForLength&#xD;&#xA;     *   &lt;/code>unmappable-character&lt;code>} result indicates that an&#xD;&#xA;     *   unmappable-character error has been detected.  The characters that&#xD;&#xA;     *   encode the unmappable character begin at the input buffer's (possibly&#xD;&#xA;     *   incremented) position; the number of such characters may be determined&#xD;&#xA;     *   by invoking the result object's {@link CoderResult#length length}&#xD;&#xA;     *   method.  This case applies only if the {@link #onUnmappableCharacter&#xD;&#xA;     *   &lt;/code>unmappable action&lt;code>} of this encoder is {@link&#xD;&#xA;     *   CodingErrorAction#REPORT}; otherwise the unmappable character will be&#xD;&#xA;     *   ignored or replaced, as requested.  &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     * &lt;/ul>&#xD;&#xA;     *&#xD;&#xA;     * In any case, if this method is to be reinvoked in the same encoding&#xD;&#xA;     * operation then care should be taken to preserve any characters remaining&#xD;&#xA;     * in the input buffer so that they are available to the next invocation.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The &lt;tt>endOfInput&lt;/tt> parameter advises this method as to whether&#xD;&#xA;     * the invoker can provide further input beyond that contained in the given&#xD;&#xA;     * input buffer.  If there is a possibility of providing additional input&#xD;&#xA;     * then the invoker should pass &lt;tt>false&lt;/tt> for this parameter; if there&#xD;&#xA;     * is no possibility of providing further input then the invoker should&#xD;&#xA;     * pass &lt;tt>true&lt;/tt>.  It is not erroneous, and in fact it is quite&#xD;&#xA;     * common, to pass &lt;tt>false&lt;/tt> in one invocation and later discover that&#xD;&#xA;     * no further input was actually available.  It is critical, however, that&#xD;&#xA;     * the final invocation of this method in a sequence of invocations always&#xD;&#xA;     * pass &lt;tt>true&lt;/tt> so that any remaining unencoded input will be treated&#xD;&#xA;     * as being malformed.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method works by invoking the {@link #encodeLoop encodeLoop}&#xD;&#xA;     * method, interpreting its results, handling error conditions, and&#xD;&#xA;     * reinvoking it as necessary.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     *&#xD;&#xA;     * @param  in&#xD;&#xA;     *         The input character buffer&#xD;&#xA;     *&#xD;&#xA;     * @param  out&#xD;&#xA;     *         The output byte buffer&#xD;&#xA;     *&#xD;&#xA;     * @param  endOfInput&#xD;&#xA;     *         &lt;tt>true&lt;/tt> if, and only if, the invoker can provide no&#xD;&#xA;     *         additional input characters beyond those in the given buffer&#xD;&#xA;     *&#xD;&#xA;     * @return  A coder-result object describing the reason for termination&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalStateException&#xD;&#xA;     *          If an encoding operation is already in progress and the previous&#xD;&#xA;     *          step was an invocation neither of the {@link #reset reset}&#xD;&#xA;     *          method, nor of this method with a value of &lt;tt>false&lt;/tt> for&#xD;&#xA;     *          the &lt;tt>endOfInput&lt;/tt> parameter, nor of this method with a&#xD;&#xA;     *          value of &lt;tt>true&lt;/tt> for the &lt;tt>endOfInput&lt;/tt> parameter&#xD;&#xA;     *          but a return value indicating an incomplete encoding operation&#xD;&#xA;     *&#xD;&#xA;     * @throws  CoderMalfunctionError&#xD;&#xA;     *          If an invocation of the encodeLoop method threw&#xD;&#xA;     *          an unexpected exception&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newState">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.2"/>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.38">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            </expression>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ConditionalAndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.2"/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
                  </expression>
                </children>
              </expression>
            </child>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="cr">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="CoderResult.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </variable>
          </statements>
          <statements xsi:type="statements:TryBlock">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.33">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
                </value>
              </expression>
            </statements>
            <catcheBlocks>
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="CoderMalfunctionError.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.1/@catcheBlocks.0/@parameter"/>
                </throwable>
              </statements>
              <parameter name="x">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../BufferUnderflowException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
            <catcheBlocks>
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="CoderMalfunctionError.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.1/@catcheBlocks.1/@parameter"/>
                </throwable>
              </statements>
              <parameter name="x">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../BufferOverflowException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.0/@variable"/>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CoderResult.class.xmi#//@classifiers.0/@members.16"/>
              </next>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <comments>// Fall through to malformed-input case</comments>
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.0/@variable"/>
                      <assignmentOperator xsi:type="operators:Assignment"/>
                      <value xsi:type="references:IdentifierReference">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="CoderResult.class.xmi#//@classifiers.0/@members.21"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../Buffer.class.xmi#//@classifiers.0/@members.16"/>
                            </next>
                          </arguments>
                        </next>
                        <target xsi:type="classifiers:Class" href="CoderResult.class.xmi#//@classifiers.0"/>
                      </value>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.2"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../Buffer.class.xmi#//@classifiers.0/@members.17"/>
                    </next>
                  </children>
                </condition>
                <elseStatement xsi:type="statements:Block">
                  <statements xsi:type="statements:Return">
                    <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.0/@variable"/>
                  </statements>
                </elseStatement>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CoderResult.class.xmi#//@classifiers.0/@members.15"/>
              </next>
            </condition>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="action">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="literals:NullLiteral"/>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.4/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CoderResult.class.xmi#//@classifiers.0/@members.18"/>
              </next>
            </condition>
            <elseStatement xsi:type="statements:Condition">
              <statement xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.4/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                </expression>
              </statement>
              <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="CoderResult.class.xmi#//@classifiers.0/@members.19"/>
                </next>
              </condition>
              <elseStatement xsi:type="statements:Assert">
                <condition xsi:type="literals:BooleanLiteral"/>
                <errorMessage xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="CoderResult.class.xmi#//@classifiers.0/@members.14"/>
                  </next>
                </errorMessage>
              </elseStatement>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.0/@variable"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.4/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="CodingErrorAction.class.xmi#//@classifiers.0/@members.3"/>
                </next>
                <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Return">
                  <returnValue xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="CoderResult.class.xmi#//@classifiers.0/@members.9"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CoderResult.class.xmi#//@classifiers.0"/>
                  </returnValue>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../Buffer.class.xmi#//@classifiers.0/@members.16"/>
                    </next>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
                    <next xsi:type="references:IdentifierReference"/>
                  </children>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../ByteBuffer.class.xmi#//@classifiers.0/@members.22"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.4/@variable"/>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="CodingErrorAction.class.xmi#//@classifiers.0/@members.2"/>
                </next>
                <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0">
                  <comments>// Skip erroneous input either way</comments>
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../Buffer.class.xmi#//@classifiers.0/@members.8"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="../Buffer.class.xmi#//@classifiers.0/@members.7"/>
                        </next>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.0/@variable">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="CoderResult.class.xmi#//@classifiers.0/@members.20"/>
                        </next>
                      </children>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:Continue"/>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.4/@variable"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="CodingErrorAction.class.xmi#//@classifiers.0/@members.1"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
                  </children>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.3/@statement/@statements.4/@variable"/>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:IdentifierReference">
                      <target xsi:type="members:Field" href="CodingErrorAction.class.xmi#//@classifiers.0/@members.2"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
                  </children>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Assert">
            <condition xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="flush">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CoderResult.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Flushes this encoder.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Some encoders maintain internal state and may need to write some&#xD;&#xA;     * final bytes to the output buffer once the overall input sequence has&#xD;&#xA;     * been read.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Any additional output is written to the output buffer beginning at&#xD;&#xA;     * its current position.  At most {@link Buffer#remaining out.remaining()}&#xD;&#xA;     * bytes will be written.  The buffer's position will be advanced&#xD;&#xA;     * appropriately, but its mark and limit will not be modified.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> If this method completes successfully then it returns {@link&#xD;&#xA;     * CoderResult#UNDERFLOW}.  If there is insufficient room in the output&#xD;&#xA;     * buffer then it returns {@link CoderResult#OVERFLOW}.  If this happens&#xD;&#xA;     * then this method must be invoked again, with an output buffer that has&#xD;&#xA;     * more room, in order to complete the current &lt;a href=&quot;#steps&quot;>encoding&#xD;&#xA;     * operation&lt;/a>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method invokes the {@link #implFlush implFlush} method to&#xD;&#xA;     * perform the actual flushing operation.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  out&#xD;&#xA;     *         The output byte buffer&#xD;&#xA;     *&#xD;&#xA;     * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or&#xD;&#xA;     *          {@link CoderResult#OVERFLOW}&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalStateException&#xD;&#xA;     *          If the previous step of the current encoding operation was an&#xD;&#xA;     *          invocation neither of the {@link #reset reset} method nor of&#xD;&#xA;     *          the three-argument {@link&#xD;&#xA;     *          #encode(CharBuffer,ByteBuffer,boolean) encode} method&#xD;&#xA;     *          with a value of &lt;tt>true&lt;/tt> for the &lt;tt>endOfInput&lt;/tt>&#xD;&#xA;     *          parameter&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.38">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="implFlush">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CoderResult.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xD;&#xA;     * Flushes this encoder.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The default implementation of this method does nothing, and always&#xD;&#xA;     * returns {@link CoderResult#UNDERFLOW}.  This method should be overridden&#xD;&#xA;     * by encoders that may need to write final bytes to the output buffer&#xD;&#xA;     * once the entire input sequence has been read. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  out&#xD;&#xA;     *         The output byte buffer&#xD;&#xA;     *&#xD;&#xA;     * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or&#xD;&#xA;     *          {@link CoderResult#OVERFLOW}&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="CoderResult.class.xmi#//@classifiers.0/@members.8"/>
          </next>
          <target xsi:type="classifiers:Class" href="CoderResult.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="reset">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Resets this encoder, clearing any internal state.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method resets charset-independent state and also invokes the&#xD;&#xA;     * {@link #implReset() implReset} method in order to perform any&#xD;&#xA;     * charset-specific reset actions.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  This encoder&#xD;&#xA;     *&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.32"/>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="implReset">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xD;&#xA;     * Resets this encoder, clearing any charset-specific internal state.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The default implementation of this method does nothing.  This method&#xD;&#xA;     * should be overridden by encoders that maintain internal state.  &lt;/p>&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="encodeLoop">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CoderResult.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="in">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xD;&#xA;     * Encodes one or more characters into one or more bytes.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method encapsulates the basic encoding loop, encoding as many&#xD;&#xA;     * characters as possible until it either runs out of input, runs out of room&#xD;&#xA;     * in the output buffer, or encounters an encoding error.  This method is&#xD;&#xA;     * invoked by the {@link #encode encode} method, which handles result&#xD;&#xA;     * interpretation and error recovery.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The buffers are read from, and written to, starting at their current&#xD;&#xA;     * positions.  At most {@link Buffer#remaining in.remaining()} characters&#xD;&#xA;     * will be read, and at most {@link Buffer#remaining out.remaining()}&#xD;&#xA;     * bytes will be written.  The buffers' positions will be advanced to&#xD;&#xA;     * reflect the characters read and the bytes written, but their marks and&#xD;&#xA;     * limits will not be modified.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method returns a {@link CoderResult} object to describe its&#xD;&#xA;     * reason for termination, in the same manner as the {@link #encode encode}&#xD;&#xA;     * method.  Most implementations of this method will handle encoding errors&#xD;&#xA;     * by returning an appropriate result object for interpretation by the&#xD;&#xA;     * {@link #encode encode} method.  An optimized implementation may instead&#xD;&#xA;     * examine the relevant error action and implement that action itself.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> An implementation of this method may perform arbitrary lookahead by&#xD;&#xA;     * returning {@link CoderResult#UNDERFLOW} until it receives sufficient&#xD;&#xA;     * input.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  in&#xD;&#xA;     *         The input character buffer&#xD;&#xA;     *&#xD;&#xA;     * @param  out&#xD;&#xA;     *         The output byte buffer&#xD;&#xA;     *&#xD;&#xA;     * @return  A coder-result object describing the reason for termination&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="encode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="in">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CharacterCodingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Convenience method that encodes the remaining content of a single input&#xD;&#xA;     * character buffer into a newly-allocated byte buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method implements an entire &lt;a href=&quot;#steps&quot;>encoding&#xD;&#xA;     * operation&lt;/a>; that is, it resets this encoder, then it encodes the&#xD;&#xA;     * characters in the given character buffer, and finally it flushes this&#xD;&#xA;     * encoder.  This method should therefore not be invoked if an encoding&#xD;&#xA;     * operation is already in progress.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  in&#xD;&#xA;     *         The input character buffer&#xD;&#xA;     *&#xD;&#xA;     * @return A newly-allocated byte buffer containing the result of the&#xD;&#xA;     *         encoding operation.  The buffer's position will be zero and its&#xD;&#xA;     *         limit will follow the last byte written.&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalStateException&#xD;&#xA;     *          If an encoding operation is already in progress&#xD;&#xA;     *&#xD;&#xA;     * @throws  MalformedInputException&#xD;&#xA;     *          If the character sequence starting at the input buffer's current&#xD;&#xA;     *          position is not a legal sixteen-bit Unicode sequence and the current malformed-input action&#xD;&#xA;     *          is {@link CodingErrorAction#REPORT}&#xD;&#xA;     *&#xD;&#xA;     * @throws  UnmappableCharacterException&#xD;&#xA;     *          If the character sequence starting at the input buffer's current&#xD;&#xA;     *          position cannot be mapped to an equivalent byte sequence and&#xD;&#xA;     *          the current unmappable-character action is {@link&#xD;&#xA;     *          CodingErrorAction#REPORT}&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../Buffer.class.xmi#//@classifiers.0/@members.16"/>
                  </next>
                </children>
                <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.26"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </expression>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="out">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../ByteBuffer.class.xmi#//@classifiers.0/@members.8"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
            </next>
            <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.31"/>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="cr">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="CoderResult.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.4/@statement/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
                  <arguments xsi:type="literals:BooleanLiteral" value="true"/>
                </value>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../Buffer.class.xmi#//@classifiers.0/@members.17"/>
              </next>
            </condition>
            <elseStatement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.4/@statement/@statements.0/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.29">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
                </value>
              </expression>
            </elseStatement>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Break"/>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.4/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CoderResult.class.xmi#//@classifiers.0/@members.15"/>
              </next>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:AssignmentMultiplication"/>
                  <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                </expression>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="o">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <initialValue xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../ByteBuffer.class.xmi#//@classifiers.0/@members.8"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../ByteBuffer.class.xmi#//@classifiers.0"/>
                  </initialValue>
                </variable>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../Buffer.class.xmi#//@classifiers.0/@members.14"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.4/@statement/@statements.3/@statement/@statements.1/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../ByteBuffer.class.xmi#//@classifiers.0/@members.20"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.4/@statement/@statements.3/@statement/@statements.1/@variable"/>
                </expression>
              </statements>
              <statements xsi:type="statements:Continue"/>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.4/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CoderResult.class.xmi#//@classifiers.0/@members.16"/>
              </next>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.4/@statement/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="CoderResult.class.xmi#//@classifiers.0/@members.23"/>
              </next>
            </expression>
          </statements>
        </statement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../Buffer.class.xmi#//@classifiers.0/@members.14"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canEncode">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cb">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.31"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.38">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ma">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.20"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ua">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.23"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.21">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="CodingErrorAction.class.xmi#//@classifiers.0/@members.3"/>
              </next>
              <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
            </arguments>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
            <arguments xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="CodingErrorAction.class.xmi#//@classifiers.0/@members.3"/>
              </next>
              <target xsi:type="classifiers:Class" href="CodingErrorAction.class.xmi#//@classifiers.0"/>
            </arguments>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.34">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="CharacterCodingException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <finallyBlock>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.21">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.1/@variable"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.2/@variable"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.31"/>
          </statements>
        </finallyBlock>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canEncode">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Tells whether or not this encoder can encode the given character.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method returns &lt;tt>false&lt;/tt> if the given character is a&#xD;&#xA;     * surrogate character; such characters can be interpreted only when they&#xD;&#xA;     * are members of a pair consisting of a high surrogate followed by a low&#xD;&#xA;     * surrogate.  The {@link #canEncode(java.lang.CharSequence)&#xD;&#xA;     * canEncode(CharSequence)} method may be used to test whether or not a&#xD;&#xA;     * character sequence can be encoded.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method may modify this encoder's state; it should therefore not&#xD;&#xA;     * be invoked if an &lt;a href=&quot;#steps&quot;>encoding operation&lt;/a> is already in&#xD;&#xA;     * progress.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The default implementation of this method is not very efficient; it&#xD;&#xA;     * should generally be overridden to improve performance.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this encoder can encode&#xD;&#xA;     *          the given character&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalStateException&#xD;&#xA;     *          If an encoding operation is already in progress&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../CharBuffer.class.xmi#//@classifiers.0/@members.5"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </next>
            <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../CharBuffer.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../Buffer.class.xmi#//@classifiers.0/@members.14"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.35">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canEncode">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../../lang/CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Tells whether or not this encoder can encode the given character&#xD;&#xA;     * sequence.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> If this method returns &lt;tt>false&lt;/tt> for a particular character&#xD;&#xA;     * sequence then more information about why the sequence cannot be encoded&#xD;&#xA;     * may be obtained by performing a full &lt;a href=&quot;#steps&quot;>encoding&#xD;&#xA;     * operation&lt;/a>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method may modify this encoder's state; it should therefore not&#xD;&#xA;     * be invoked if an encoding operation is already in progress.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The default implementation of this method is not very efficient; it&#xD;&#xA;     * should generally be overridden to improve performance.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this encoder can encode&#xD;&#xA;     *          the given character without throwing any exceptions and without&#xD;&#xA;     *          performing any replacements&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalStateException&#xD;&#xA;     *          If an encoding operation is already in progress&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:NestedExpression">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../CharBuffer.class.xmi#//@classifiers.0/@members.12"/>
              </next>
              <expression xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
              </expression>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../CharBuffer.class.xmi#//@classifiers.0/@members.10"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:InterfaceMethod" href="../../lang/CharSequence.class.xmi#//@classifiers.0/@members.3"/>
                  </next>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../CharBuffer.class.xmi#//@classifiers.0"/>
            </value>
          </expression>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.35">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="throwIllegalStateException">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="from">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="to">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/IllegalStateException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:StringReference" value="Current state = "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
              </arraySelectors>
            </children>
            <children xsi:type="references:StringReference" value=", new state = "/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.1"/>
              </arraySelectors>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
        </throwable>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>// javadoc</comments>
      <comments>/**&#xD;&#xA; * An engine that can transform a sequence of sixteen-bit Unicode characters into a sequence of&#xD;&#xA; * bytes in a specific charset.&#xD;&#xA; *&#xD;&#xA; * &lt;a name=&quot;steps&quot;>&#xD;&#xA; *&#xD;&#xA; * &lt;p> The input character sequence is provided in a character buffer or a series&#xD;&#xA; * of such buffers.  The output byte sequence is written to a byte buffer&#xD;&#xA; * or a series of such buffers.  An encoder should always be used by making&#xD;&#xA; * the following sequence of method invocations, hereinafter referred to as an&#xD;&#xA; * &lt;i>encoding operation&lt;/i>:&#xD;&#xA; *&#xD;&#xA; * &lt;ol>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Reset the encoder via the {@link #reset reset} method, unless it&#xD;&#xA; *   has not been used before; &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Invoke the {@link #encode encode} method zero or more times, as&#xD;&#xA; *   long as additional input may be available, passing &lt;tt>false&lt;/tt> for the&#xD;&#xA; *   &lt;tt>endOfInput&lt;/tt> argument and filling the input buffer and flushing the&#xD;&#xA; *   output buffer between invocations; &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Invoke the {@link #encode encode} method one final time, passing&#xD;&#xA; *   &lt;tt>true&lt;/tt> for the &lt;tt>endOfInput&lt;/tt> argument; and then &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Invoke the {@link #flush flush} method so that the encoder can&#xD;&#xA; *   flush any internal state to the output buffer. &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; * &lt;/ol>&#xD;&#xA; *&#xD;&#xA; * Each invocation of the {@link #encode encode} method will encode as many&#xD;&#xA; * characters as possible from the input buffer, writing the resulting bytes&#xD;&#xA; * to the output buffer.  The {@link #encode encode} method returns when more&#xD;&#xA; * input is required, when there is not enough room in the output buffer, or&#xD;&#xA; * when an encoding error has occurred.  In each case a {@link CoderResult}&#xD;&#xA; * object is returned to describe the reason for termination.  An invoker can&#xD;&#xA; * examine this object and fill the input buffer, flush the output buffer, or&#xD;&#xA; * attempt to recover from an encoding error, as appropriate, and try again.&#xD;&#xA; *&#xD;&#xA; * &lt;a name=&quot;ce&quot;>&#xD;&#xA; *&#xD;&#xA; * &lt;p> There are two general types of encoding errors.  If the input character&#xD;&#xA; * sequence is not a legal sixteen-bit Unicode sequence then the input is considered &lt;i>malformed&lt;/i>.  If&#xD;&#xA; * the input character sequence is legal but cannot be mapped to a valid&#xD;&#xA; * byte sequence in the given charset then an &lt;i>unmappable character&lt;/i> has been encountered.&#xD;&#xA; *&#xD;&#xA; * &lt;a name=&quot;cae&quot;>&#xD;&#xA; *&#xD;&#xA; * &lt;p> How an encoding error is handled depends upon the action requested for&#xD;&#xA; * that type of error, which is described by an instance of the {@link&#xD;&#xA; * CodingErrorAction} class.  The possible error actions are to {@link&#xD;&#xA; * CodingErrorAction#IGNORE &lt;/code>ignore&lt;code>} the erroneous input, {@link&#xD;&#xA; * CodingErrorAction#REPORT &lt;/code>report&lt;code>} the error to the invoker via&#xD;&#xA; * the returned {@link CoderResult} object, or {@link CodingErrorAction#REPLACE&#xD;&#xA; * &lt;/code>replace&lt;code>} the erroneous input with the current value of the&#xD;&#xA; * replacement byte array.  The replacement&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA; * is initially set to the encoder's default replacement, which often&#xD;&#xA; * (but not always) has the initial value&amp;nbsp;&lt;tt>{&lt;/tt>&amp;nbsp;&lt;tt>(byte)'?'&lt;/tt>&amp;nbsp;&lt;tt>}&lt;/tt>;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * its value may be changed via the {@link #replaceWith(byte[])&#xD;&#xA; * replaceWith} method.&#xD;&#xA; *&#xD;&#xA; * &lt;p> The default action for malformed-input and unmappable-character errors&#xD;&#xA; * is to {@link CodingErrorAction#REPORT &lt;/code>report&lt;code>} them.  The&#xD;&#xA; * malformed-input error action may be changed via the {@link&#xD;&#xA; * #onMalformedInput(CodingErrorAction) onMalformedInput} method; the&#xD;&#xA; * unmappable-character action may be changed via the {@link&#xD;&#xA; * #onUnmappableCharacter(CodingErrorAction) onUnmappableCharacter} method.&#xD;&#xA; *&#xD;&#xA; * &lt;p> This class is designed to handle many of the details of the encoding&#xD;&#xA; * process, including the implementation of error actions.  An encoder for a&#xD;&#xA; * specific charset, which is a concrete subclass of this class, need only&#xD;&#xA; * implement the abstract {@link #encodeLoop encodeLoop} method, which&#xD;&#xA; * encapsulates the basic encoding loop.  A subclass that maintains internal&#xD;&#xA; * state should, additionally, override the {@link #flush flush} and {@link&#xD;&#xA; * #reset reset} methods.&#xD;&#xA; *&#xD;&#xA; * &lt;p> Instances of this class are not safe for use by multiple concurrent&#xD;&#xA; * threads.  &lt;/p>&#xD;&#xA; *&#xD;&#xA; *&#xD;&#xA; * @version 1.42, 05/03/03&#xD;&#xA; * @author Mark Reinhold&#xD;&#xA; * @author JSR-51 Expert Group&#xD;&#xA; * @since 1.4&#xD;&#xA; *&#xD;&#xA; * @see ByteBuffer&#xD;&#xA; * @see CharBuffer&#xD;&#xA; * @see Charset&#xD;&#xA; * @see CharsetDecoder&#xD;&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
