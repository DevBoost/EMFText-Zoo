<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="LongBuffer.java">
  <comments>/*&#xD;&#xA; * @(#)X-Buffer.java&#x9;1.56 04/07/16&#xD;&#xA; *&#xD;&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xD;&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xD;&#xA; */</comments>
  <comments>// -- This file was mechanically generated: Do not edit! -- //</comments>
  <namespaces>java</namespaces>
  <namespaces>nio</namespaces>
  <classifiers xsi:type="classifiers:Class" name="LongBuffer">
    <members xsi:type="members:Field" name="hb">
      <typeReference xsi:type="types:Long"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// These fields are declared here rather than in Heap-X-Buffer in order to</comments>
        <comments>// reduce the number of virtual method invocations needed to access these</comments>
        <comments>// values, which is especially costly when coding small buffers.</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="offset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// Non-null only for heap buffers</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="isReadOnly">
      <typeReference xsi:type="types:Boolean"/>
    </members>
    <members xsi:type="members:Constructor" name="LongBuffer">
      <comments>// Valid only for heap buffers</comments>
      <comments>// Creates a new buffer with the given mark, position, limit, capacity,</comments>
      <comments>// backing array, and array offset</comments>
      <comments>//</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.3"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.4"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.5"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mark">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lim">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cap">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hb">
        <typeReference xsi:type="types:Long">
          <comments>// package-private</comments>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:Constructor" name="LongBuffer">
      <comments>// Creates a new buffer with the given mark, position, limit, and capacity</comments>
      <comments>//</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.3"/>
          <arguments xsi:type="literals:NullLiteral"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <callTarget xsi:type="literals:This">
            <comments>// package-private</comments>
          </callTarget>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mark">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lim">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cap">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:ClassMethod" name="allocate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="capacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Allocates a new long buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its limit will be its&#xD;&#xA;     * capacity, and its mark will be undefined.  It will have a {@link #array&#xD;&#xA;     * &lt;/code>backing array&lt;code>}, and its {@link #arrayOffset &lt;/code>array&#xD;&#xA;     * offset&lt;code>} will be zero.&#xD;&#xA;     *&#xD;&#xA;     * @param  capacity&#xD;&#xA;     *         The new buffer's capacity, in longs&#xD;&#xA;     *&#xD;&#xA;     * @return  The new long buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalArgumentException&#xD;&#xA;     *          If the &lt;tt>capacity&lt;/tt> is a negative integer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="HeapLongBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="wrap">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:Long"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Wraps a long array into a buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer will be backed by the given long array;&#xD;&#xA;     * that is, modifications to the buffer will cause the array to be modified&#xD;&#xA;     * and vice versa.  The new buffer's capacity will be&#xD;&#xA;     * &lt;tt>array.length&lt;/tt>, its position will be &lt;tt>offset&lt;/tt>, its limit&#xD;&#xA;     * will be &lt;tt>offset + length&lt;/tt>, and its mark will be undefined.  Its&#xD;&#xA;     * {@link #array &lt;/code>backing array&lt;code>} will be the given array, and&#xD;&#xA;     * its {@link #arrayOffset &lt;/code>array offset&lt;code>} will be zero.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  array&#xD;&#xA;     *         The array that will back the new buffer&#xD;&#xA;     *&#xD;&#xA;     * @param  offset&#xD;&#xA;     *         The offset of the subarray to be used; must be non-negative and&#xD;&#xA;     *         no larger than &lt;tt>array.length&lt;/tt>.  The new buffer's position&#xD;&#xA;     *         will be set to this value.&#xD;&#xA;     *&#xD;&#xA;     * @param  length&#xD;&#xA;     *         The length of the subarray to be used;&#xD;&#xA;     *         must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>array.length - offset&lt;/tt>.&#xD;&#xA;     *         The new buffer's limit will be set to &lt;tt>offset + length&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * @return  The new long buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on the &lt;tt>offset&lt;/tt> and &lt;tt>length&lt;/tt>&#xD;&#xA;     *          parameters do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="HeapLongBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.2"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="wrap">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:Long"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Wraps a long array into a buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer will be backed by the given long array;&#xD;&#xA;     * that is, modifications to the buffer will cause the array to be modified&#xD;&#xA;     * and vice versa.  The new buffer's capacity and limit will be&#xD;&#xA;     * &lt;tt>array.length&lt;/tt>, its position will be zero, and its mark will be&#xD;&#xA;     * undefined.  Its {@link #array &lt;/code>backing array&lt;code>} will be the&#xD;&#xA;     * given array, and its {@link #arrayOffset &lt;/code>array offset&lt;code>} will&#xD;&#xA;     * be zero.  &lt;/p> &#xD;&#xA;     *&#xD;&#xA;     * @param  array&#xD;&#xA;     *         The array that will back this buffer&#xD;&#xA;     *&#xD;&#xA;     * @return  The new long buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="slice">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a new long buffer whose content is a shared subsequence of&#xD;&#xA;     * this buffer's content.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will start at this buffer's current&#xD;&#xA;     * position.  Changes to this buffer's content will be visible in the new&#xD;&#xA;     * buffer, and vice versa; the two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its capacity and its limit&#xD;&#xA;     * will be the number of longs remaining in this buffer, and its mark&#xD;&#xA;     * will be undefined.  The new buffer will be direct if, and only if, this&#xD;&#xA;     * buffer is direct, and it will be read-only if, and only if, this buffer&#xD;&#xA;     * is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The new long buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="duplicate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a new long buffer that shares this buffer's content.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will be that of this buffer.  Changes&#xD;&#xA;     * to this buffer's content will be visible in the new buffer, and vice&#xD;&#xA;     * versa; the two buffers' position, limit, and mark values will be&#xD;&#xA;     * independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's capacity, limit, position, and mark values will be&#xD;&#xA;     * identical to those of this buffer.  The new buffer will be direct if,&#xD;&#xA;     * and only if, this buffer is direct, and it will be read-only if, and&#xD;&#xA;     * only if, this buffer is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The new long buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asReadOnlyBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a new, read-only long buffer that shares this buffer's&#xD;&#xA;     * content.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will be that of this buffer.  Changes&#xD;&#xA;     * to this buffer's content will be visible in the new buffer; the new&#xD;&#xA;     * buffer itself, however, will be read-only and will not allow the shared&#xD;&#xA;     * content to be modified.  The two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's capacity, limit, position, and mark values will be&#xD;&#xA;     * identical to those of this buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> If this buffer is itself read-only then this method behaves in&#xD;&#xA;     * exactly the same way as the {@link #duplicate duplicate} method.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The new, read-only long buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Singleton get/put methods --</comments>
        <comments>/**&#xD;&#xA;     * Relative &lt;i>get&lt;/i> method.  Reads the long at this buffer's&#xD;&#xA;     * current position, and then increments the position. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The long at the buffer's current position&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If the buffer's current position is not smaller than its limit&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     * &#xD;&#xA;     * &lt;p> Writes the given long into this buffer at the current&#xD;&#xA;     * position, and then increments the position. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  l&#xD;&#xA;     *         The long to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If this buffer's current position is not smaller than its limit&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:Long"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>get&lt;/i> method.  Reads the long at the given&#xD;&#xA;     * index. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index from which the long will be read&#xD;&#xA;     *&#xD;&#xA;     * @return  The long at the given index&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     * &#xD;&#xA;     * &lt;p> Writes the given long into this buffer at the given&#xD;&#xA;     * index. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index at which the long will be written&#xD;&#xA;     *&#xD;&#xA;     * @param  l&#xD;&#xA;     *         The long value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Long"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Bulk get operations --</comments>
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>get&lt;/i> method.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers longs from this buffer into the given&#xD;&#xA;     * destination array.  If there are fewer longs remaining in the&#xD;&#xA;     * buffer than are required to satisfy the request, that is, if&#xD;&#xA;     * &lt;tt>length&lt;/tt>&amp;nbsp;&lt;tt>&amp;gt;&lt;/tt>&amp;nbsp;&lt;tt>remaining()&lt;/tt>, then no&#xD;&#xA;     * longs are transferred and a {@link BufferUnderflowException} is&#xD;&#xA;     * thrown.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Otherwise, this method copies &lt;tt>length&lt;/tt> longs from this&#xD;&#xA;     * buffer into the given array, starting at the current position of this&#xD;&#xA;     * buffer and at the given offset in the array.  The position of this&#xD;&#xA;     * buffer is then incremented by &lt;tt>length&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> In other words, an invocation of this method of the form&#xD;&#xA;     * &lt;tt>src.get(dst,&amp;nbsp;off,&amp;nbsp;len)&lt;/tt> has exactly the same effect as&#xD;&#xA;     * the loop&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     for (int i = off; i &lt; off + len; i++)&#xD;&#xA;     *         dst[i] = src.get(); &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * except that it first checks that there are sufficient longs in&#xD;&#xA;     * this buffer and it is potentially much more efficient. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  dst&#xD;&#xA;     *         The array into which longs are to be written&#xD;&#xA;     *&#xD;&#xA;     * @param  offset&#xD;&#xA;     *         The offset within the array of the first long to be&#xD;&#xA;     *         written; must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>dst.length&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @param  length&#xD;&#xA;     *         The maximum number of longs to be written to the given&#xD;&#xA;     *         array; must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>dst.length - offset&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than &lt;tt>length&lt;/tt> longs&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on the &lt;tt>offset&lt;/tt> and &lt;tt>length&lt;/tt>&#xD;&#xA;     *          parameters do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.26"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferUnderflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.2"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="end">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@init"/>
              </arraySelectors>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Long"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>get&lt;/i> method.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers longs from this buffer into the given&#xD;&#xA;     * destination array.  An invocation of this method of the form&#xD;&#xA;     * &lt;tt>src.get(a)&lt;/tt> behaves in exactly the same way as the invocation&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     src.get(a, 0, a.length) &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than &lt;tt>length&lt;/tt> longs&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Bulk put operations --</comments>
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers the longs remaining in the given source&#xD;&#xA;     * buffer into this buffer.  If there are more longs remaining in the&#xD;&#xA;     * source buffer than in this buffer, that is, if&#xD;&#xA;     * &lt;tt>src.remaining()&lt;/tt>&amp;nbsp;&lt;tt>&amp;gt;&lt;/tt>&amp;nbsp;&lt;tt>remaining()&lt;/tt>,&#xD;&#xA;     * then no longs are transferred and a {@link&#xD;&#xA;     * BufferOverflowException} is thrown.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Otherwise, this method copies&#xD;&#xA;     * &lt;i>n&lt;/i>&amp;nbsp;=&amp;nbsp;&lt;tt>src.remaining()&lt;/tt> longs from the given&#xD;&#xA;     * buffer into this buffer, starting at each buffer's current position.&#xD;&#xA;     * The positions of both buffers are then incremented by &lt;i>n&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> In other words, an invocation of this method of the form&#xD;&#xA;     * &lt;tt>dst.put(src)&lt;/tt> has exactly the same effect as the loop&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     while (src.hasRemaining())&#xD;&#xA;     *         dst.put(src.get()); &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * except that it first checks that there is sufficient space in this&#xD;&#xA;     * buffer and it is potentially much more efficient. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  src&#xD;&#xA;     *         The source buffer from which longs are to be read;&#xD;&#xA;     *         must not be this buffer&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *          for the remaining longs in the source buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalArgumentException&#xD;&#xA;     *          If the source buffer is this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferOverflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.1/@variable"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
            </arguments>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:Long"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers longs into this buffer from the given&#xD;&#xA;     * source array.  If there are more longs to be copied from the array&#xD;&#xA;     * than remain in this buffer, that is, if&#xD;&#xA;     * &lt;tt>length&lt;/tt>&amp;nbsp;&lt;tt>&amp;gt;&lt;/tt>&amp;nbsp;&lt;tt>remaining()&lt;/tt>, then no&#xD;&#xA;     * longs are transferred and a {@link BufferOverflowException} is&#xD;&#xA;     * thrown.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Otherwise, this method copies &lt;tt>length&lt;/tt> longs from the&#xD;&#xA;     * given array into this buffer, starting at the given offset in the array&#xD;&#xA;     * and at the current position of this buffer.  The position of this buffer&#xD;&#xA;     * is then incremented by &lt;tt>length&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> In other words, an invocation of this method of the form&#xD;&#xA;     * &lt;tt>dst.put(src,&amp;nbsp;off,&amp;nbsp;len)&lt;/tt> has exactly the same effect as&#xD;&#xA;     * the loop&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     for (int i = off; i &lt; off + len; i++)&#xD;&#xA;     *         dst.put(a[i]); &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * except that it first checks that there is sufficient space in this&#xD;&#xA;     * buffer and it is potentially much more efficient. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  src&#xD;&#xA;     *         The array from which longs are to be read&#xD;&#xA;     *&#xD;&#xA;     * @param  offset&#xD;&#xA;     *         The offset within the array of the first long to be read;&#xD;&#xA;     *         must be non-negative and no larger than &lt;tt>array.length&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @param  length&#xD;&#xA;     *         The number of longs to be read from the given array;&#xD;&#xA;     *         must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>array.length - offset&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on the &lt;tt>offset&lt;/tt> and &lt;tt>length&lt;/tt>&#xD;&#xA;     *          parameters do not hold&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.26"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferOverflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="end">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@init"/>
                </arraySelectors>
              </arguments>
            </next>
            <self xsi:type="literals:This"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:Long"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers the entire content of the given source&#xD;&#xA;     * long array into this buffer.  An invocation of this method of the&#xD;&#xA;     * form &lt;tt>dst.put(a)&lt;/tt> behaves in exactly the same way as the&#xD;&#xA;     * invocation&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     dst.put(a, 0, a.length) &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasArray">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Other stuff --</comments>
        <comments>/**&#xD;&#xA;     * Tells whether or not this buffer is backed by an accessible long&#xD;&#xA;     * array.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> If this method returns &lt;tt>true&lt;/tt> then the {@link #array() array}&#xD;&#xA;     * and {@link #arrayOffset() arrayOffset} methods may safely be invoked.&#xD;&#xA;     * &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this buffer&#xD;&#xA;     *          is backed by an array and is not read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="array">
      <typeReference xsi:type="types:Long"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the long array that backs this&#xD;&#xA;     * buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Modifications to this buffer's content will cause the returned&#xD;&#xA;     * array's content to be modified, and vice versa.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Invoke the {@link #hasArray hasArray} method before invoking this&#xD;&#xA;     * method in order to ensure that this buffer has an accessible backing&#xD;&#xA;     * array.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The array that backs this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is backed by an array but is read-only&#xD;&#xA;     *&#xD;&#xA;     * @throws  UnsupportedOperationException&#xD;&#xA;     *          If this buffer is not backed by an accessible array&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ReadOnlyBufferException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="arrayOffset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the offset within this buffer's backing array of the first&#xD;&#xA;     * element of the buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> If this buffer is backed by an array then buffer position &lt;i>p&lt;/i>&#xD;&#xA;     * corresponds to array index &lt;i>p&lt;/i>&amp;nbsp;+&amp;nbsp;&lt;tt>arrayOffset()&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Invoke the {@link #hasArray hasArray} method before invoking this&#xD;&#xA;     * method in order to ensure that this buffer has an accessible backing&#xD;&#xA;     * array.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The offset within this buffer's array&#xD;&#xA;     *          of the first element of the buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is backed by an array but is read-only&#xD;&#xA;     *&#xD;&#xA;     * @throws  UnsupportedOperationException&#xD;&#xA;     *          If this buffer is not backed by an accessible array&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ReadOnlyBufferException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="compact">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Compacts this buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The longs between the buffer's current position and its limit,&#xD;&#xA;     * if any, are copied to the beginning of the buffer.  That is, the&#xD;&#xA;     * long at index &lt;i>p&lt;/i>&amp;nbsp;=&amp;nbsp;&lt;tt>position()&lt;/tt> is copied&#xD;&#xA;     * to index zero, the long at index &lt;i>p&lt;/i>&amp;nbsp;+&amp;nbsp;1 is copied&#xD;&#xA;     * to index one, and so forth until the long at index&#xD;&#xA;     * &lt;tt>limit()&lt;/tt>&amp;nbsp;-&amp;nbsp;1 is copied to index&#xD;&#xA;     * &lt;i>n&lt;/i>&amp;nbsp;=&amp;nbsp;&lt;tt>limit()&lt;/tt>&amp;nbsp;-&amp;nbsp;&lt;tt>1&lt;/tt>&amp;nbsp;-&amp;nbsp;&lt;i>p&lt;/i>.&#xD;&#xA;     * The buffer's position is then set to &lt;i>n+1&lt;/i> and its limit is set to&#xD;&#xA;     * its capacity.  The mark, if defined, is discarded.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The buffer's position is set to the number of longs copied,&#xD;&#xA;     * rather than to zero, so that an invocation of this method can be&#xD;&#xA;     * followed immediately by an invocation of another relative &lt;i>put&lt;/i>&#xD;&#xA;     * method. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isDirect">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Tells whether or not this long buffer is direct. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this buffer is direct&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns a string summarizing the state of this buffer.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  A summary string&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sb">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Class.class.xmi#//@classifiers.0/@members.44"/>
              </next>
              <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:StringReference" value="[pos="/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.27"/>
            <arguments xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:StringReference" value=" lim="/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.27"/>
            <arguments xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:StringReference" value=" cap="/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.27"/>
            <arguments xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.6"/>
            </arguments>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:StringReference" value="]"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the current hash code of this buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The hash code of a long buffer depends only upon its remaining&#xD;&#xA;     * elements; that is, upon the elements from &lt;tt>position()&lt;/tt> up to, and&#xD;&#xA;     * including, the element at &lt;tt>limit()&lt;/tt>&amp;nbsp;-&amp;nbsp;&lt;tt>1&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Because buffer hash codes are content-dependent, it is inadvisable&#xD;&#xA;     * to use buffers as keys in hash maps or similar data structures unless it&#xD;&#xA;     * is known that their contents will not change.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The current hash code of this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="h">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="31"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </children>
              <children xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Int"/>
                <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.2/@init"/>
                </child>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.2/@init"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ob">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Tells whether or not this buffer is equal to another object.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Two long buffers are equal if, and only if,&#xD;&#xA;     *&#xD;&#xA;     * &lt;p>&lt;ol>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> They have the same element type,  &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> They have the same number of remaining elements, and&#xD;&#xA;     *   &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> The two sequences of remaining elements, considered&#xD;&#xA;     *   independently of their starting positions, are pointwise equal.&#xD;&#xA;     *   &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     * &lt;/ol>&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> A long buffer is not equal to any other type of object.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  ob  The object to which this buffer is to be compared&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this buffer is equal to the&#xD;&#xA;     *           given object&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="that">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v1">
              <typeReference xsi:type="types:Long"/>
              <initialValue xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@init"/>
                </next>
                <self xsi:type="literals:This"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v2">
              <typeReference xsi:type="types:Long"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.1/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@init/@additionalLocalVariables.0"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Continue">
                  <comments>// For float and double</comments>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@statement/@statements.0/@variable"/>
                    </expression>
                  </children>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@statement/@statements.1/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@statement/@statements.1/@variable"/>
                    </expression>
                  </children>
                </condition>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@statement/@statements.1/@variable"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.3/@variable"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
          <additionalLocalVariables name="j">
            <initialValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
                </next>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </initialValue>
          </additionalLocalVariables>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@init"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.4/@init/@additionalLocalVariables.0"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="that">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Compares this buffer to another.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Two long buffers are compared by comparing their sequences of&#xD;&#xA;     * remaining elements lexicographically, without regard to the starting&#xD;&#xA;     * position of each sequence within its corresponding buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> A long buffer is not comparable to any other type of object.&#xD;&#xA;     *&#xD;&#xA;     * @return  A negative integer, zero, or a positive integer as this buffer&#xD;&#xA;     *&#x9;&#x9;is less than, equal to, or greater than the given buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                <arguments xsi:type="references:SelfReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
                  </next>
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
                  </next>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v1">
              <typeReference xsi:type="types:Long"/>
              <initialValue xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@init"/>
                </next>
                <self xsi:type="literals:This"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v2">
              <typeReference xsi:type="types:Long"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@init/@additionalLocalVariables.0"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Continue"/>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@statement/@statements.1/@variable"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Continue">
              <comments>// For float and double</comments>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@statement/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@statement/@statements.0/@variable"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@statement/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@statement/@statements.1/@variable"/>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@statement/@statements.1/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Addition"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
          <additionalLocalVariables name="j">
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
              </next>
            </initialValue>
          </additionalLocalVariables>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.1/@init/@additionalLocalVariables.0"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
          </children>
          <additiveOperators xsi:type="operators:Subtraction"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="order">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ByteOrder.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Other char stuff --</comments>
        <comments>// -- Other byte stuff: Access to binary data --</comments>
        <comments>/**&#xD;&#xA;     * Retrieves this buffer's byte order.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The byte order of a long buffer created by allocation or by&#xD;&#xA;     * wrapping an existing &lt;tt>long&lt;/tt> array is the {@link&#xD;&#xA;     * ByteOrder#nativeOrder &lt;/code>native order&lt;code>} of the underlying&#xD;&#xA;     * hardware.  The byte order of a long buffer created as a &lt;a&#xD;&#xA;     * href=&quot;ByteBuffer.html#view&quot;>view&lt;/a> of a byte buffer is that of the&#xD;&#xA;     * byte buffer at the moment that the view is created.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer's byte order&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xD;&#xA; * A long buffer.&#xD;&#xA; *&#xD;&#xA; * &lt;p> This class defines four categories of operations upon&#xD;&#xA; * long buffers:&#xD;&#xA; *&#xD;&#xA; * &lt;ul>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Absolute and relative {@link #get() &lt;/code>&lt;i>get&lt;/i>&lt;code>} and&#xD;&#xA; *   {@link #put(long) &lt;/code>&lt;i>put&lt;/i>&lt;code>} methods that read and write&#xD;&#xA; *   single longs; &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Relative {@link #get(long[]) &lt;/code>&lt;i>bulk get&lt;/i>&lt;code>}&#xD;&#xA; *   methods that transfer contiguous sequences of longs from this buffer&#xD;&#xA; *   into an array; and&lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Relative {@link #put(long[]) &lt;/code>&lt;i>bulk put&lt;/i>&lt;code>}&#xD;&#xA; *   methods that transfer contiguous sequences of longs from a&#xD;&#xA; *   long array or some other long&#xD;&#xA; *   buffer into this buffer;&amp;#32;and &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Methods for {@link #compact &lt;/code>compacting&lt;code>}, {@link&#xD;&#xA; *   #duplicate &lt;/code>duplicating&lt;code>}, and {@link #slice&#xD;&#xA; *   &lt;/code>slicing&lt;code>} a long buffer.  &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; * &lt;/ul>&#xD;&#xA; *&#xD;&#xA; * &lt;p> Long buffers can be created either by {@link #allocate&#xD;&#xA; * &lt;/code>&lt;i>allocation&lt;/i>&lt;code>}, which allocates space for the buffer's&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * content, by {@link #wrap(long[]) &lt;/code>&lt;i>wrapping&lt;/i>&lt;code>} an existing&#xD;&#xA; * long array  into a buffer, or by creating a&#xD;&#xA; * &lt;a href=&quot;ByteBuffer.html#view&quot;>&lt;i>view&lt;/i>&lt;/a> of an existing byte buffer&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;*&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * &lt;p> Like a byte buffer, a long buffer is either &lt;a&#xD;&#xA; * href=&quot;ByteBuffer.html#direct&quot;>&lt;i>direct&lt;/i> or &lt;i>non-direct&lt;/i>&lt;/a>.  A&#xD;&#xA; * long buffer created via the &lt;tt>wrap&lt;/tt> methods of this class will&#xD;&#xA; * be non-direct.  A long buffer created as a view of a byte buffer will&#xD;&#xA; * be direct if, and only if, the byte buffer itself is direct.  Whether or not&#xD;&#xA; * a long buffer is direct may be determined by invoking the {@link&#xD;&#xA; * #isDirect isDirect} method.  &lt;/p>&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;*&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * &lt;p> Methods in this class that do not otherwise have a value to return are&#xD;&#xA; * specified to return the buffer upon which they are invoked.  This allows&#xD;&#xA; * method invocations to be chained.&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; *&#xD;&#xA; * @author Mark Reinhold&#xD;&#xA; * @author JSR-51 Expert Group&#xD;&#xA; * @version 1.56, 04/07/16&#xD;&#xA; * @since 1.4&#xD;&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../lang/Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Buffer.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
