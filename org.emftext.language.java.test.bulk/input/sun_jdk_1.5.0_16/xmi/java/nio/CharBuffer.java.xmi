<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="CharBuffer.java">
  <comments>/*&#xD;&#xA; * @(#)X-Buffer.java&#x9;1.56 04/07/16&#xD;&#xA; *&#xD;&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xD;&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xD;&#xA; */</comments>
  <comments>// -- This file was mechanically generated: Do not edit! -- //</comments>
  <namespaces>java</namespaces>
  <namespaces>nio</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="CharBuffer">
    <members xsi:type="members:Field" name="hb">
      <typeReference xsi:type="types:Char"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// These fields are declared here rather than in Heap-X-Buffer in order to</comments>
        <comments>// reduce the number of virtual method invocations needed to access these</comments>
        <comments>// values, which is especially costly when coding small buffers.</comments>
        <comments>//</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="offset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// Non-null only for heap buffers</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="isReadOnly">
      <typeReference xsi:type="types:Boolean"/>
    </members>
    <members xsi:type="members:Constructor" name="CharBuffer">
      <comments>// Valid only for heap buffers</comments>
      <comments>// Creates a new buffer with the given mark, position, limit, capacity,</comments>
      <comments>// backing array, and array offset</comments>
      <comments>//</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.3"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.4"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.5"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mark">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lim">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cap">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hb">
        <typeReference xsi:type="types:Char">
          <comments>// package-private</comments>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:Constructor" name="CharBuffer">
      <comments>// Creates a new buffer with the given mark, position, limit, and capacity</comments>
      <comments>//</comments>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.3"/>
          <arguments xsi:type="literals:NullLiteral"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <callTarget xsi:type="literals:This">
            <comments>// package-private</comments>
          </callTarget>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mark">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lim">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cap">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:ClassMethod" name="allocate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="capacity">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Allocates a new character buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its limit will be its&#xD;&#xA;     * capacity, and its mark will be undefined.  It will have a {@link #array&#xD;&#xA;     * &lt;/code>backing array&lt;code>}, and its {@link #arrayOffset &lt;/code>array&#xD;&#xA;     * offset&lt;code>} will be zero.&#xD;&#xA;     *&#xD;&#xA;     * @param  capacity&#xD;&#xA;     *         The new buffer's capacity, in characters&#xD;&#xA;     *&#xD;&#xA;     * @return  The new character buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalArgumentException&#xD;&#xA;     *          If the &lt;tt>capacity&lt;/tt> is a negative integer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="HeapCharBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="wrap">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Wraps a character array into a buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer will be backed by the given character array;&#xD;&#xA;     * that is, modifications to the buffer will cause the array to be modified&#xD;&#xA;     * and vice versa.  The new buffer's capacity will be&#xD;&#xA;     * &lt;tt>array.length&lt;/tt>, its position will be &lt;tt>offset&lt;/tt>, its limit&#xD;&#xA;     * will be &lt;tt>offset + length&lt;/tt>, and its mark will be undefined.  Its&#xD;&#xA;     * {@link #array &lt;/code>backing array&lt;code>} will be the given array, and&#xD;&#xA;     * its {@link #arrayOffset &lt;/code>array offset&lt;code>} will be zero.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  array&#xD;&#xA;     *         The array that will back the new buffer&#xD;&#xA;     *&#xD;&#xA;     * @param  offset&#xD;&#xA;     *         The offset of the subarray to be used; must be non-negative and&#xD;&#xA;     *         no larger than &lt;tt>array.length&lt;/tt>.  The new buffer's position&#xD;&#xA;     *         will be set to this value.&#xD;&#xA;     *&#xD;&#xA;     * @param  length&#xD;&#xA;     *         The length of the subarray to be used;&#xD;&#xA;     *         must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>array.length - offset&lt;/tt>.&#xD;&#xA;     *         The new buffer's limit will be set to &lt;tt>offset + length&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * @return  The new character buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on the &lt;tt>offset&lt;/tt> and &lt;tt>length&lt;/tt>&#xD;&#xA;     *          parameters do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="HeapCharBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.2"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="wrap">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="array">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Wraps a character array into a buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer will be backed by the given character array;&#xD;&#xA;     * that is, modifications to the buffer will cause the array to be modified&#xD;&#xA;     * and vice versa.  The new buffer's capacity and limit will be&#xD;&#xA;     * &lt;tt>array.length&lt;/tt>, its position will be zero, and its mark will be&#xD;&#xA;     * undefined.  Its {@link #array &lt;/code>backing array&lt;code>} will be the&#xD;&#xA;     * given array, and its {@link #arrayOffset &lt;/code>array offset&lt;code>} will&#xD;&#xA;     * be zero.  &lt;/p> &#xD;&#xA;     *&#xD;&#xA;     * @param  array&#xD;&#xA;     *         The array that will back this buffer&#xD;&#xA;     *&#xD;&#xA;     * @return  The new character buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="read">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="target">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../io/IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Attempts to read characters into the specified character buffer.&#xD;&#xA;     * The buffer is used as a repository of characters as-is: the only&#xD;&#xA;     * changes made are the results of a put operation. No flipping or&#xD;&#xA;     * rewinding of the buffer is performed.&#xD;&#xA;     *&#xD;&#xA;     * @param target the buffer to read characters into&#xD;&#xA;     * @return The number of characters added to the buffer, or &#xD;&#xA;     *         -1 if this source of characters is at its end&#xD;&#xA;     * @throws IOException if an I/O error occurs&#xD;&#xA;     * @throws NullPointerException if target is null&#xD;&#xA;     * @throws ReadOnlyBufferException if target is a read only buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="targetRemaining">
          <typeReference xsi:type="types:Int">
            <comments>// Determine the number of bytes n that can be transferred</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="remaining">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="limit">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Set source limit to prevent target overflow</comments>
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.10"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.3/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
              </next>
            </expression>
          </statement>
          <condition xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.3/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </condition>
        </statements>
        <finallyBlock>
          <comments>// restore real limit</comments>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.10"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.4/@variable"/>
            </expression>
          </statements>
        </finallyBlock>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.3/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="wrap">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Wraps a character sequence into a buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new, read-only buffer will be the content of the&#xD;&#xA;     * given character sequence.  The buffer's capacity will be&#xD;&#xA;     * &lt;tt>csq.length()&lt;/tt>, its position will be &lt;tt>start&lt;/tt>, its limit&#xD;&#xA;     * will be &lt;tt>end&lt;/tt>, and its mark will be undefined.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  csq&#xD;&#xA;     *         The character sequence from which the new character buffer is to&#xD;&#xA;     *         be created&#xD;&#xA;     *&#xD;&#xA;     * @param  start&#xD;&#xA;     *         The index of the first character to be used;&#xD;&#xA;     *         must be non-negative and no larger than &lt;tt>csq.length()&lt;/tt>.&#xD;&#xA;     *         The new buffer's position will be set to this value.&#xD;&#xA;     *&#xD;&#xA;     * @param  end&#xD;&#xA;     *         The index of the character following the last character to be&#xD;&#xA;     *         used; must be no smaller than &lt;tt>start&lt;/tt> and no larger&#xD;&#xA;     *         than &lt;tt>csq.length()&lt;/tt>.&#xD;&#xA;     *         The new buffer's limit will be set to this value.&#xD;&#xA;     *&#xD;&#xA;     * @return  The new character buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on the &lt;tt>start&lt;/tt> and &lt;tt>end&lt;/tt>&#xD;&#xA;     *          parameters do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="StringCharBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.2"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="wrap">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Wraps a string into a buffer.&#xD;&#xA;     * &#xD;&#xA;     * &lt;p> The content of the new, read-only buffer will be the content of the&#xD;&#xA;     * given string.  The new buffer's capacity and limit will be&#xD;&#xA;     * &lt;tt>csq.length()&lt;/tt>, its position will be zero, and its mark will be&#xD;&#xA;     * undefined.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  csq&#xD;&#xA;     *         The character sequence from which the new character buffer is to&#xD;&#xA;     *         be created&#xD;&#xA;     *&#xD;&#xA;     * @return  The new character buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.9">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:InterfaceMethod" href="../lang/CharSequence.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="slice">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a new character buffer whose content is a shared subsequence of&#xD;&#xA;     * this buffer's content.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will start at this buffer's current&#xD;&#xA;     * position.  Changes to this buffer's content will be visible in the new&#xD;&#xA;     * buffer, and vice versa; the two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's position will be zero, its capacity and its limit&#xD;&#xA;     * will be the number of characters remaining in this buffer, and its mark&#xD;&#xA;     * will be undefined.  The new buffer will be direct if, and only if, this&#xD;&#xA;     * buffer is direct, and it will be read-only if, and only if, this buffer&#xD;&#xA;     * is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The new character buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="duplicate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a new character buffer that shares this buffer's content.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will be that of this buffer.  Changes&#xD;&#xA;     * to this buffer's content will be visible in the new buffer, and vice&#xD;&#xA;     * versa; the two buffers' position, limit, and mark values will be&#xD;&#xA;     * independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's capacity, limit, position, and mark values will be&#xD;&#xA;     * identical to those of this buffer.  The new buffer will be direct if,&#xD;&#xA;     * and only if, this buffer is direct, and it will be read-only if, and&#xD;&#xA;     * only if, this buffer is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The new character buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="asReadOnlyBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a new, read-only character buffer that shares this buffer's&#xD;&#xA;     * content.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The content of the new buffer will be that of this buffer.  Changes&#xD;&#xA;     * to this buffer's content will be visible in the new buffer; the new&#xD;&#xA;     * buffer itself, however, will be read-only and will not allow the shared&#xD;&#xA;     * content to be modified.  The two buffers' position, limit, and mark&#xD;&#xA;     * values will be independent.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer's capacity, limit, position, and mark values will be&#xD;&#xA;     * identical to those of this buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> If this buffer is itself read-only then this method behaves in&#xD;&#xA;     * exactly the same way as the {@link #duplicate duplicate} method.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The new, read-only character buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Singleton get/put methods --</comments>
        <comments>/**&#xD;&#xA;     * Relative &lt;i>get&lt;/i> method.  Reads the character at this buffer's&#xD;&#xA;     * current position, and then increments the position. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The character at the buffer's current position&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If the buffer's current position is not smaller than its limit&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     * &#xD;&#xA;     * &lt;p> Writes the given character into this buffer at the current&#xD;&#xA;     * position, and then increments the position. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  c&#xD;&#xA;     *         The character to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If this buffer's current position is not smaller than its limit&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="get">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>get&lt;/i> method.  Reads the character at the given&#xD;&#xA;     * index. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index from which the character will be read&#xD;&#xA;     *&#xD;&#xA;     * @return  The character at the given index&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Absolute &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     * &#xD;&#xA;     * &lt;p> Writes the given character into this buffer at the given&#xD;&#xA;     * index. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index at which the character will be written&#xD;&#xA;     *&#xD;&#xA;     * @param  c&#xD;&#xA;     *         The character value to be written&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>index&lt;/tt> is negative&#xD;&#xA;     *          or not smaller than the buffer's limit&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Bulk get operations --</comments>
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>get&lt;/i> method.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers characters from this buffer into the given&#xD;&#xA;     * destination array.  If there are fewer characters remaining in the&#xD;&#xA;     * buffer than are required to satisfy the request, that is, if&#xD;&#xA;     * &lt;tt>length&lt;/tt>&amp;nbsp;&lt;tt>&amp;gt;&lt;/tt>&amp;nbsp;&lt;tt>remaining()&lt;/tt>, then no&#xD;&#xA;     * characters are transferred and a {@link BufferUnderflowException} is&#xD;&#xA;     * thrown.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Otherwise, this method copies &lt;tt>length&lt;/tt> characters from this&#xD;&#xA;     * buffer into the given array, starting at the current position of this&#xD;&#xA;     * buffer and at the given offset in the array.  The position of this&#xD;&#xA;     * buffer is then incremented by &lt;tt>length&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> In other words, an invocation of this method of the form&#xD;&#xA;     * &lt;tt>src.get(dst,&amp;nbsp;off,&amp;nbsp;len)&lt;/tt> has exactly the same effect as&#xD;&#xA;     * the loop&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     for (int i = off; i &lt; off + len; i++)&#xD;&#xA;     *         dst[i] = src.get(); &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * except that it first checks that there are sufficient characters in&#xD;&#xA;     * this buffer and it is potentially much more efficient. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  dst&#xD;&#xA;     *         The array into which characters are to be written&#xD;&#xA;     *&#xD;&#xA;     * @param  offset&#xD;&#xA;     *         The offset within the array of the first character to be&#xD;&#xA;     *         written; must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>dst.length&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @param  length&#xD;&#xA;     *         The maximum number of characters to be written to the given&#xD;&#xA;     *         array; must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>dst.length - offset&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than &lt;tt>length&lt;/tt> characters&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on the &lt;tt>offset&lt;/tt> and &lt;tt>length&lt;/tt>&#xD;&#xA;     *          parameters do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.26"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferUnderflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="end">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0">
              <arraySelectors>
                <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@init"/>
              </arraySelectors>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="get">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dst">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>get&lt;/i> method.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers characters from this buffer into the given&#xD;&#xA;     * destination array.  An invocation of this method of the form&#xD;&#xA;     * &lt;tt>src.get(a)&lt;/tt> behaves in exactly the same way as the invocation&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     src.get(a, 0, a.length) &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferUnderflowException&#xD;&#xA;     *          If there are fewer than &lt;tt>length&lt;/tt> characters&#xD;&#xA;     *          remaining in this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Bulk put operations --</comments>
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers the characters remaining in the given source&#xD;&#xA;     * buffer into this buffer.  If there are more characters remaining in the&#xD;&#xA;     * source buffer than in this buffer, that is, if&#xD;&#xA;     * &lt;tt>src.remaining()&lt;/tt>&amp;nbsp;&lt;tt>&amp;gt;&lt;/tt>&amp;nbsp;&lt;tt>remaining()&lt;/tt>,&#xD;&#xA;     * then no characters are transferred and a {@link&#xD;&#xA;     * BufferOverflowException} is thrown.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Otherwise, this method copies&#xD;&#xA;     * &lt;i>n&lt;/i>&amp;nbsp;=&amp;nbsp;&lt;tt>src.remaining()&lt;/tt> characters from the given&#xD;&#xA;     * buffer into this buffer, starting at each buffer's current position.&#xD;&#xA;     * The positions of both buffers are then incremented by &lt;i>n&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> In other words, an invocation of this method of the form&#xD;&#xA;     * &lt;tt>dst.put(src)&lt;/tt> has exactly the same effect as the loop&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     while (src.hasRemaining())&#xD;&#xA;     *         dst.put(src.get()); &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * except that it first checks that there is sufficient space in this&#xD;&#xA;     * buffer and it is potentially much more efficient. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  src&#xD;&#xA;     *         The source buffer from which characters are to be read;&#xD;&#xA;     *         must not be this buffer&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *          for the remaining characters in the source buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IllegalArgumentException&#xD;&#xA;     *          If the source buffer is this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
          <children xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferOverflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0">
              <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
            </arguments>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers characters into this buffer from the given&#xD;&#xA;     * source array.  If there are more characters to be copied from the array&#xD;&#xA;     * than remain in this buffer, that is, if&#xD;&#xA;     * &lt;tt>length&lt;/tt>&amp;nbsp;&lt;tt>&amp;gt;&lt;/tt>&amp;nbsp;&lt;tt>remaining()&lt;/tt>, then no&#xD;&#xA;     * characters are transferred and a {@link BufferOverflowException} is&#xD;&#xA;     * thrown.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Otherwise, this method copies &lt;tt>length&lt;/tt> characters from the&#xD;&#xA;     * given array into this buffer, starting at the given offset in the array&#xD;&#xA;     * and at the current position of this buffer.  The position of this buffer&#xD;&#xA;     * is then incremented by &lt;tt>length&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> In other words, an invocation of this method of the form&#xD;&#xA;     * &lt;tt>dst.put(src,&amp;nbsp;off,&amp;nbsp;len)&lt;/tt> has exactly the same effect as&#xD;&#xA;     * the loop&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     for (int i = off; i &lt; off + len; i++)&#xD;&#xA;     *         dst.put(a[i]); &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * except that it first checks that there is sufficient space in this&#xD;&#xA;     * buffer and it is potentially much more efficient. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  src&#xD;&#xA;     *         The array from which characters are to be read&#xD;&#xA;     *&#xD;&#xA;     * @param  offset&#xD;&#xA;     *         The offset within the array of the first character to be read;&#xD;&#xA;     *         must be non-negative and no larger than &lt;tt>array.length&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @param  length&#xD;&#xA;     *         The number of characters to be read from the given array;&#xD;&#xA;     *         must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>array.length - offset&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on the &lt;tt>offset&lt;/tt> and &lt;tt>length&lt;/tt>&#xD;&#xA;     *          parameters do not hold&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.26"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferOverflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
          <children xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
          </children>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="end">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.3/@init"/>
                </arraySelectors>
              </arguments>
            </next>
            <self xsi:type="literals:This"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers the entire content of the given source&#xD;&#xA;     * character array into this buffer.  An invocation of this method of the&#xD;&#xA;     * form &lt;tt>dst.put(a)&lt;/tt> behaves in exactly the same way as the&#xD;&#xA;     * invocation&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     dst.put(a, 0, a.length) &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.21">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers characters from the given string into this&#xD;&#xA;     * buffer.  If there are more characters to be copied from the string than&#xD;&#xA;     * remain in this buffer, that is, if&#xD;&#xA;     * &lt;tt>end&amp;nbsp;-&amp;nbsp;start&lt;/tt>&amp;nbsp;&lt;tt>&amp;gt;&lt;/tt>&amp;nbsp;&lt;tt>remaining()&lt;/tt>,&#xD;&#xA;     * then no characters are transferred and a {@link&#xD;&#xA;     * BufferOverflowException} is thrown.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Otherwise, this method copies&#xD;&#xA;     * &lt;i>n&lt;/i>&amp;nbsp;=&amp;nbsp;&lt;tt>end&lt;/tt>&amp;nbsp;-&amp;nbsp;&lt;tt>start&lt;/tt> characters&#xD;&#xA;     * from the given string into this buffer, starting at the given&#xD;&#xA;     * &lt;tt>start&lt;/tt> index and at the current position of this buffer.  The&#xD;&#xA;     * position of this buffer is then incremented by &lt;i>n&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> In other words, an invocation of this method of the form&#xD;&#xA;     * &lt;tt>dst.put(src,&amp;nbsp;start,&amp;nbsp;end)&lt;/tt> has exactly the same effect&#xD;&#xA;     * as the loop&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     for (int i = start; i &lt; end; i++)&#xD;&#xA;     *         dst.put(src.charAt(i)); &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * except that it first checks that there is sufficient space in this&#xD;&#xA;     * buffer and it is potentially much more efficient. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  src&#xD;&#xA;     *         The string from which characters are to be read&#xD;&#xA;     *&#xD;&#xA;     * @param  start&#xD;&#xA;     *         The offset within the string of the first character to be read;&#xD;&#xA;     *         must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>string.length()&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @param  end&#xD;&#xA;     *         The offset within the string of the last character to be read,&#xD;&#xA;     *         plus one; must be non-negative and no larger than&#xD;&#xA;     *         &lt;tt>string.length()&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on the &lt;tt>start&lt;/tt> and &lt;tt>end&lt;/tt>&#xD;&#xA;     *          parameters do not hold&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.26"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.23"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.1/@init"/>
                </next>
              </arguments>
            </next>
            <self xsi:type="literals:This"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.1/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="put">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="src">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Relative bulk &lt;i>put&lt;/i> method&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> This method transfers the entire content of the given source string&#xD;&#xA;     * into this buffer.  An invocation of this method of the form&#xD;&#xA;     * &lt;tt>dst.put(s)&lt;/tt> behaves in exactly the same way as the invocation&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     dst.put(s, 0, s.length()) &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasArray">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Other stuff --</comments>
        <comments>/**&#xD;&#xA;     * Tells whether or not this buffer is backed by an accessible character&#xD;&#xA;     * array.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> If this method returns &lt;tt>true&lt;/tt> then the {@link #array() array}&#xD;&#xA;     * and {@link #arrayOffset() arrayOffset} methods may safely be invoked.&#xD;&#xA;     * &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this buffer&#xD;&#xA;     *          is backed by an array and is not read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="array">
      <typeReference xsi:type="types:Char"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the character array that backs this&#xD;&#xA;     * buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Modifications to this buffer's content will cause the returned&#xD;&#xA;     * array's content to be modified, and vice versa.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Invoke the {@link #hasArray hasArray} method before invoking this&#xD;&#xA;     * method in order to ensure that this buffer has an accessible backing&#xD;&#xA;     * array.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The array that backs this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is backed by an array but is read-only&#xD;&#xA;     *&#xD;&#xA;     * @throws  UnsupportedOperationException&#xD;&#xA;     *          If this buffer is not backed by an accessible array&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ReadOnlyBufferException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="arrayOffset">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the offset within this buffer's backing array of the first&#xD;&#xA;     * element of the buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> If this buffer is backed by an array then buffer position &lt;i>p&lt;/i>&#xD;&#xA;     * corresponds to array index &lt;i>p&lt;/i>&amp;nbsp;+&amp;nbsp;&lt;tt>arrayOffset()&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Invoke the {@link #hasArray hasArray} method before invoking this&#xD;&#xA;     * method in order to ensure that this buffer has an accessible backing&#xD;&#xA;     * array.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The offset within this buffer's array&#xD;&#xA;     *          of the first element of the buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is backed by an array but is read-only&#xD;&#xA;     *&#xD;&#xA;     * @throws  UnsupportedOperationException&#xD;&#xA;     *          If this buffer is not backed by an accessible array&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="ReadOnlyBufferException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="compact">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Compacts this buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The characters between the buffer's current position and its limit,&#xD;&#xA;     * if any, are copied to the beginning of the buffer.  That is, the&#xD;&#xA;     * character at index &lt;i>p&lt;/i>&amp;nbsp;=&amp;nbsp;&lt;tt>position()&lt;/tt> is copied&#xD;&#xA;     * to index zero, the character at index &lt;i>p&lt;/i>&amp;nbsp;+&amp;nbsp;1 is copied&#xD;&#xA;     * to index one, and so forth until the character at index&#xD;&#xA;     * &lt;tt>limit()&lt;/tt>&amp;nbsp;-&amp;nbsp;1 is copied to index&#xD;&#xA;     * &lt;i>n&lt;/i>&amp;nbsp;=&amp;nbsp;&lt;tt>limit()&lt;/tt>&amp;nbsp;-&amp;nbsp;&lt;tt>1&lt;/tt>&amp;nbsp;-&amp;nbsp;&lt;i>p&lt;/i>.&#xD;&#xA;     * The buffer's position is then set to &lt;i>n+1&lt;/i> and its limit is set to&#xD;&#xA;     * its capacity.  The mark, if defined, is discarded.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The buffer's position is set to the number of characters copied,&#xD;&#xA;     * rather than to zero, so that an invocation of this method can be&#xD;&#xA;     * followed immediately by an invocation of another relative &lt;i>put&lt;/i>&#xD;&#xA;     * method. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isDirect">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Tells whether or not this character buffer is direct. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this buffer is direct&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Returns the current hash code of this buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The hash code of a char buffer depends only upon its remaining&#xD;&#xA;     * elements; that is, upon the elements from &lt;tt>position()&lt;/tt> up to, and&#xD;&#xA;     * including, the element at &lt;tt>limit()&lt;/tt>&amp;nbsp;-&amp;nbsp;&lt;tt>1&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Because buffer hash codes are content-dependent, it is inadvisable&#xD;&#xA;     * to use buffers as keys in hash maps or similar data structures unless it&#xD;&#xA;     * is known that their contents will not change.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The current hash code of this buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="h">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="31"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </children>
              <children xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Int"/>
                <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.2/@init"/>
                </child>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.2/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.2/@init"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ob">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Tells whether or not this buffer is equal to another object.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Two char buffers are equal if, and only if,&#xD;&#xA;     *&#xD;&#xA;     * &lt;p>&lt;ol>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> They have the same element type,  &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> They have the same number of remaining elements, and&#xD;&#xA;     *   &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     *   &lt;li>&lt;p> The two sequences of remaining elements, considered&#xD;&#xA;     *   independently of their starting positions, are pointwise equal.&#xD;&#xA;     *   &lt;/p>&lt;/li>&#xD;&#xA;     *&#xD;&#xA;     * &lt;/ol>&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> A char buffer is not equal to any other type of object.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  ob  The object to which this buffer is to be compared&#xD;&#xA;     *&#xD;&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this buffer is equal to the&#xD;&#xA;     *           given object&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="that">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:BooleanLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v1">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@init"/>
                </next>
                <self xsi:type="literals:This"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v2">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.1/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@init/@additionalLocalVariables.0"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Continue">
                  <comments>// For float and double</comments>
                </statement>
                <condition xsi:type="expressions:ConditionalAndExpression">
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@statement/@statements.0/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@statement/@statements.0/@variable"/>
                    </expression>
                  </children>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:EqualityExpression">
                      <equalityOperators xsi:type="operators:NotEqual"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@statement/@statements.1/@variable"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@statement/@statements.1/@variable"/>
                    </expression>
                  </children>
                </condition>
              </statements>
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="literals:BooleanLiteral"/>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@statement/@statements.1/@variable"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.3/@variable"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
          <additionalLocalVariables name="j">
            <initialValue xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.1/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
                </next>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </initialValue>
          </additionalLocalVariables>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@init"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.4/@init/@additionalLocalVariables.0"/>
          <operator xsi:type="operators:MinusMinus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="that">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Compares this buffer to another.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Two char buffers are compared by comparing their sequences of&#xD;&#xA;     * remaining elements lexicographically, without regard to the starting&#xD;&#xA;     * position of each sequence within its corresponding buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> A char buffer is not comparable to any other type of object.&#xD;&#xA;     *&#xD;&#xA;     * @return  A negative integer, zero, or a positive integer as this buffer&#xD;&#xA;     *&#x9;&#x9;is less than, equal to, or greater than the given buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:SelfReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
              </next>
              <self xsi:type="literals:This"/>
            </children>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Math.class.xmi#//@classifiers.0/@members.37"/>
                <arguments xsi:type="references:SelfReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
                  </next>
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
                  </next>
                </arguments>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Math.class.xmi#//@classifiers.0"/>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v1">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@init"/>
                </next>
                <self xsi:type="literals:This"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="v2">
              <typeReference xsi:type="types:Char"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@init/@additionalLocalVariables.0"/>
                </next>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Continue"/>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.1/@variable"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Continue">
              <comments>// For float and double</comments>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.0/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.0/@variable"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.1/@variable"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.1/@variable"/>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@statement/@statements.1/@variable"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Addition"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
            </next>
            <self xsi:type="literals:This"/>
          </initialValue>
          <additionalLocalVariables name="j">
            <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
              </next>
            </initialValue>
          </additionalLocalVariables>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@init/@additionalLocalVariables.0"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
            <self xsi:type="literals:This"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
            </next>
          </children>
          <additiveOperators xsi:type="operators:Subtraction"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Other char stuff --</comments>
        <comments>/**&#xD;&#xA;     * Returns a string containing the characters in this buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The first character of the resulting string will be the character at&#xD;&#xA;     * this buffer's position, while the last character will be the character&#xD;&#xA;     * at index &lt;tt>limit()&lt;/tt>&amp;nbsp;-&amp;nbsp;1.  Invoking this method does not&#xD;&#xA;     * change the buffer's position. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The specified string&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.34">
          <arguments xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
          </arguments>
          <arguments xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.9"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="length">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// package-private</comments>
        <comments>// --- Methods to support CharSequence ---</comments>
        <comments>/**&#xD;&#xA;     * Returns the length of this character buffer.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> When viewed as a character sequence, the length of a character&#xD;&#xA;     * buffer is simply the number of characters between the position&#xD;&#xA;     * (inclusive) and the limit (exclusive); that is, it is equivalent to&#xD;&#xA;     * &lt;tt>remaining()&lt;/tt>. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  The length of this character buffer&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.16"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="charAt">
      <typeReference xsi:type="types:Char"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="index">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Reads the character at the given index relative to the current&#xD;&#xA;     * position. &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  index&#xD;&#xA;     *         The index of the character to be read, relative to the position; &#xD;&#xA;     *         must be non-negative and smaller than &lt;tt>remaining()&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @return  The character at index&#xD;&#xA;     *          &lt;tt>position()&lt;/tt>&amp;nbsp;+&amp;nbsp;index&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on &lt;tt>index&lt;/tt> do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.7"/>
            </children>
            <children xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Buffer.class.xmi#//@classifiers.0/@members.24"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
              <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="subSequence">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Creates a new character buffer that represents the specified subsequence&#xD;&#xA;     * of this buffer, relative to the current position.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The new buffer will share this buffer's content; that is, if the&#xD;&#xA;     * content of this buffer is mutable then modifications to one buffer will&#xD;&#xA;     * cause the other to be modified.  The new buffer's capacity will be that&#xD;&#xA;     * of this buffer, its position will be&#xD;&#xA;     * &lt;tt>position()&lt;/tt>&amp;nbsp;+&amp;nbsp;&lt;tt>start&lt;/tt>, and its limit will be&#xD;&#xA;     * &lt;tt>position()&lt;/tt>&amp;nbsp;+&amp;nbsp;&lt;tt>end&lt;/tt>.  The new buffer will be&#xD;&#xA;     * direct if, and only if, this buffer is direct, and it will be read-only&#xD;&#xA;     * if, and only if, this buffer is read-only.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @param  start&#xD;&#xA;     *         The index, relative to the current position, of the first&#xD;&#xA;     *         character in the subsequence; must be non-negative and no larger &#xD;&#xA;     *         than &lt;tt>remaining()&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @param  end&#xD;&#xA;     *         The index, relative to the current position, of the character&#xD;&#xA;     *         following the last character in the subsequence; must be no&#xD;&#xA;     *         smaller than &lt;tt>start&lt;/tt> and no larger than&#xD;&#xA;     *         &lt;tt>remaining()&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @return  The new character buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If the preconditions on &lt;tt>start&lt;/tt> and &lt;tt>end&lt;/tt>&#xD;&#xA;     *          do not hold&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// --- Methods to support Appendable ---</comments>
        <comments>/**&#xD;&#xA;     * Appends the specified character sequence  to this&#xD;&#xA;     * buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     * &#xD;&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>dst.append(csq)&lt;/tt>&#xD;&#xA;     * behaves in exactly the same way as the invocation&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     dst.put(csq.toString()) &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> Depending on the specification of &lt;tt>toString&lt;/tt> for the&#xD;&#xA;     * character sequence &lt;tt>csq&lt;/tt>, the entire sequence may not be&#xD;&#xA;     * appended.  For instance, invoking the {@link CharBuffer#toString()&#xD;&#xA;     * toString} method of a character buffer will return a subsequence whose&#xD;&#xA;     * content depends upon the buffer's position and limit.&#xD;&#xA;     *&#xD;&#xA;     * @param  csq&#xD;&#xA;     *         The character sequence to append.  If &lt;tt>csq&lt;/tt> is&#xD;&#xA;     *         &lt;tt>null&lt;/tt>, then the four characters &lt;tt>&quot;null&quot;&lt;/tt> are&#xD;&#xA;     *         appended to this character buffer.&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     *&#xD;&#xA;     * @since  1.5&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
            <arguments xsi:type="references:StringReference" value="null"/>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Return">
          <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../lang/CharSequence.class.xmi#//@classifiers.0/@members.3"/>
              </next>
            </arguments>
          </returnValue>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Appends a subsequence of the  specified character sequence  to this&#xD;&#xA;     * buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     * &#xD;&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>dst.append(csq, start,&#xD;&#xA;     * end)&lt;/tt> when &lt;tt>csq&lt;/tt> is not &lt;tt>null&lt;/tt>, behaves in exactly the&#xD;&#xA;     * same way as the invocation&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     dst.put(csq.subSequence(start, end).toString()) &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * @param  csq&#xD;&#xA;     *         The character sequence from which a subsequence will be&#xD;&#xA;     *         appended.  If &lt;tt>csq&lt;/tt> is &lt;tt>null&lt;/tt>, then characters&#xD;&#xA;     *         will be appended as if &lt;tt>csq&lt;/tt> contained the four&#xD;&#xA;     *         characters &lt;tt>&quot;null&quot;&lt;/tt>.&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  IndexOutOfBoundsException&#xD;&#xA;     *          If &lt;tt>start&lt;/tt> or &lt;tt>end&lt;/tt> are negative, &lt;tt>start&lt;/tt>&#xD;&#xA;     *          is greater than &lt;tt>end&lt;/tt>, or &lt;tt>end&lt;/tt> is greater than&#xD;&#xA;     *          &lt;tt>csq.length()&lt;/tt>&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     *&#xD;&#xA;     * @since  1.5&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalExpression">
              <child xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
                <children xsi:type="literals:NullLiteral"/>
              </child>
              <expressionIf xsi:type="references:StringReference" value="null"/>
              <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../lang/CharSequence.class.xmi#//@classifiers.0/@members.3"/>
              </next>
              <target xsi:type="members:InterfaceMethod" href="../lang/CharSequence.class.xmi#//@classifiers.0/@members.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.2"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xD;&#xA;     * Appends the specified character  to this&#xD;&#xA;     * buffer&amp;nbsp;&amp;nbsp;&lt;i>(optional operation)&lt;/i>.&#xD;&#xA;     * &#xD;&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>dst.append(c)&lt;/tt>&#xD;&#xA;     * behaves in exactly the same way as the invocation&#xD;&#xA;     *&#xD;&#xA;     * &lt;pre>&#xD;&#xA;     *     dst.put(c) &lt;/pre>&#xD;&#xA;     *&#xD;&#xA;     * @param  c&#xD;&#xA;     *         The 16-bit character to append&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  BufferOverflowException&#xD;&#xA;     *          If there is insufficient space in this buffer&#xD;&#xA;     *&#xD;&#xA;     * @throws  ReadOnlyBufferException&#xD;&#xA;     *          If this buffer is read-only&#xD;&#xA;     *&#xD;&#xA;     * @since  1.5&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.15">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="order">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ByteOrder.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// -- Other byte stuff: Access to binary data --</comments>
        <comments>/**&#xD;&#xA;     * Retrieves this buffer's byte order.&#xD;&#xA;     *&#xD;&#xA;     * &lt;p> The byte order of a character buffer created by allocation or by&#xD;&#xA;     * wrapping an existing &lt;tt>char&lt;/tt> array is the {@link&#xD;&#xA;     * ByteOrder#nativeOrder &lt;/code>native order&lt;code>} of the underlying&#xD;&#xA;     * hardware.  The byte order of a character buffer created as a &lt;a&#xD;&#xA;     * href=&quot;ByteBuffer.html#view&quot;>view&lt;/a> of a byte buffer is that of the&#xD;&#xA;     * byte buffer at the moment that the view is created.  &lt;/p>&#xD;&#xA;     *&#xD;&#xA;     * @return  This buffer's byte order&#xD;&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xD;&#xA; * A character buffer.&#xD;&#xA; *&#xD;&#xA; * &lt;p> This class defines four categories of operations upon&#xD;&#xA; * character buffers:&#xD;&#xA; *&#xD;&#xA; * &lt;ul>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Absolute and relative {@link #get() &lt;/code>&lt;i>get&lt;/i>&lt;code>} and&#xD;&#xA; *   {@link #put(char) &lt;/code>&lt;i>put&lt;/i>&lt;code>} methods that read and write&#xD;&#xA; *   single characters; &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Relative {@link #get(char[]) &lt;/code>&lt;i>bulk get&lt;/i>&lt;code>}&#xD;&#xA; *   methods that transfer contiguous sequences of characters from this buffer&#xD;&#xA; *   into an array; and&lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Relative {@link #put(char[]) &lt;/code>&lt;i>bulk put&lt;/i>&lt;code>}&#xD;&#xA; *   methods that transfer contiguous sequences of characters from a&#xD;&#xA; *   character array,&amp;#32;a&amp;#32;string, or some other character&#xD;&#xA; *   buffer into this buffer;&amp;#32;and &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; *   &lt;li>&lt;p> Methods for {@link #compact &lt;/code>compacting&lt;code>}, {@link&#xD;&#xA; *   #duplicate &lt;/code>duplicating&lt;code>}, and {@link #slice&#xD;&#xA; *   &lt;/code>slicing&lt;code>} a character buffer.  &lt;/p>&lt;/li>&#xD;&#xA; *&#xD;&#xA; * &lt;/ul>&#xD;&#xA; *&#xD;&#xA; * &lt;p> Character buffers can be created either by {@link #allocate&#xD;&#xA; * &lt;/code>&lt;i>allocation&lt;/i>&lt;code>}, which allocates space for the buffer's&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * content, by {@link #wrap(char[]) &lt;/code>&lt;i>wrapping&lt;/i>&lt;code>} an existing&#xD;&#xA; * character array or&amp;#32;string into a buffer, or by creating a&#xD;&#xA; * &lt;a href=&quot;ByteBuffer.html#view&quot;>&lt;i>view&lt;/i>&lt;/a> of an existing byte buffer&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;*&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * &lt;p> Like a byte buffer, a character buffer is either &lt;a&#xD;&#xA; * href=&quot;ByteBuffer.html#direct&quot;>&lt;i>direct&lt;/i> or &lt;i>non-direct&lt;/i>&lt;/a>.  A&#xD;&#xA; * character buffer created via the &lt;tt>wrap&lt;/tt> methods of this class will&#xD;&#xA; * be non-direct.  A character buffer created as a view of a byte buffer will&#xD;&#xA; * be direct if, and only if, the byte buffer itself is direct.  Whether or not&#xD;&#xA; * a character buffer is direct may be determined by invoking the {@link&#xD;&#xA; * #isDirect isDirect} method.  &lt;/p>&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;*&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * &lt;p> This class implements the {@link CharSequence} interface so that&#xD;&#xA; * character buffers may be used wherever character sequences are accepted, for&#xD;&#xA; * example in the regular-expression package &lt;tt>{@link java.util.regex}&lt;/tt>.&#xD;&#xA; * &lt;/p>&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * &lt;p> Methods in this class that do not otherwise have a value to return are&#xD;&#xA; * specified to return the buffer upon which they are invoked.  This allows&#xD;&#xA; * method invocations to be chained.&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; * The sequence of statements&#xD;&#xA; *&#xD;&#xA; * &lt;blockquote>&lt;pre>&#xD;&#xA; * cb.put(&quot;text/&quot;);&#xD;&#xA; * cb.put(subtype);&#xD;&#xA; * cb.put(&quot;; charset=&quot;);&#xD;&#xA; * cb.put(enc);&lt;/pre>&lt;/blockquote>&#xD;&#xA; *&#xD;&#xA; * can, for example, be replaced by the single statement&#xD;&#xA; *&#xD;&#xA; * &lt;blockquote>&lt;pre>&#xD;&#xA; * cb.put(&quot;text/&quot;).put(subtype).put(&quot;; charset=&quot;).put(enc);&lt;/pre>&lt;/blockquote>&#xD;&#xA; *&#xD;&#xA;&#xD;&#xA; *&#xD;&#xA; *&#xD;&#xA; * @author Mark Reinhold&#xD;&#xA; * @author JSR-51 Expert Group&#xD;&#xA; * @version 1.56, 04/07/16&#xD;&#xA; * @since 1.4&#xD;&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../lang/Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../lang/Appendable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../lang/Readable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Buffer.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
