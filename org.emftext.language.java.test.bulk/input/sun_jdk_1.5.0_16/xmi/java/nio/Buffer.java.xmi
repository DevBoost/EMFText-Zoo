<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="Buffer.java">
  <comments>/*&#xA; * @(#)Buffer.java&#x9;1.35 06/08/11&#xA; *&#xA; * Copyright 2006 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>nio</namespaces>
  <classifiers xsi:type="classifiers:Class" name="Buffer">
    <members xsi:type="members:Field" name="mark">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="position">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="limit">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="capacity">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="address">
      <typeReference xsi:type="types:Long">
        <comments>// Used only by direct buffers</comments>
        <comments>// NOTE: hoisted here for speed in JNI GetDirectBufferAddress</comments>
      </typeReference>
    </members>
    <members xsi:type="members:Constructor" name="Buffer">
      <comments>// Creates a new buffer with the given mark, position, limit, and capacity,</comments>
      <comments>// after checking invariants.</comments>
      <comments>//</comments>
      <statements xsi:type="statements:Condition">
        <comments>// package-private</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.3"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.3"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.10">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.2"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.8">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </throwable>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.1"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mark">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="lim">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cap">
        <typeReference xsi:type="types:Int"/>
      </parameters>
    </members>
    <members xsi:type="members:ClassMethod" name="capacity">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns this buffer's capacity. &lt;/p>&#xA;     *&#xA;     * @return  The capacity of this buffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="position">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns this buffer's position. &lt;/p>&#xA;     *&#xA;     * @return  The position of this buffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="position">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newPosition">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets this buffer's position.  If the mark is defined and larger than the&#xA;     * new position then it is discarded. &lt;/p>&#xA;     *&#xA;     * @param  newPosition&#xA;     *         The new position value; must be non-negative&#xA;     *         and no larger than the current limit&#xA;     *&#xA;     * @return  This buffer&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the preconditions on &lt;tt>newPosition&lt;/tt> do not hold&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="limit">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns this buffer's limit. &lt;/p>&#xA;     *&#xA;     * @return  The limit of this buffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="limit">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newLimit">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets this buffer's limit.  If the position is larger than the new limit&#xA;     * then it is set to the new limit.  If the mark is defined and larger than&#xA;     * the new limit then it is discarded. &lt;/p>&#xA;     *&#xA;     * @param  newLimit&#xA;     *         The new limit value; must be non-negative&#xA;     *         and no larger than this buffer's capacity&#xA;     *&#xA;     * @return  This buffer&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the preconditions on &lt;tt>newLimit&lt;/tt> do not hold&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:UnaryExpression">
              <operators xsi:type="operators:Subtraction"/>
              <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="mark">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets this buffer's mark at its position. &lt;/p>&#xA;     *&#xA;     * @return  This buffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="reset">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Resets this buffer's position to the previously-marked position.&#xA;     *&#xA;     * &lt;p> Invoking this method neither changes nor discards the mark's&#xA;     * value. &lt;/p>&#xA;     *&#xA;     * @return  This buffer&#xA;     *&#xA;     * @throws  InvalidMarkException&#xA;     *          If the mark has not been set&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="m">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InvalidMarkException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@statements.0/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clear">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Clears this buffer.  The position is set to zero, the limit is set to&#xA;     * the capacity, and the mark is discarded.&#xA;     *&#xA;     * &lt;p> Invoke this method before using a sequence of channel-read or&#xA;     * &lt;i>put&lt;/i> operations to fill this buffer.  For example:&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * buf.clear();     // Prepare buffer for reading&#xA;     * in.read(buf);    // Read data&lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * &lt;p> This method does not actually erase the data in the buffer, but it&#xA;     * is named as if it did because it will most often be used in situations&#xA;     * in which that might as well be the case. &lt;/p>&#xA;     *&#xA;     * @return  This buffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="flip">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Flips this buffer.  The limit is set to the current position and then&#xA;     * the position is set to zero.  If the mark is defined then it is&#xA;     * discarded.&#xA;     *&#xA;     * &lt;p> After a sequence of channel-read or &lt;i>put&lt;/i> operations, invoke&#xA;     * this method to prepare for a sequence of channel-write or relative&#xA;     * &lt;i>get&lt;/i> operations.  For example:&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * buf.put(magic);    // Prepend header&#xA;     * in.read(buf);      // Read data into rest of buffer&#xA;     * buf.flip();        // Flip buffer&#xA;     * out.write(buf);    // Write header + data to channel&lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * &lt;p> This method is often used in conjunction with the {@link&#xA;     * java.nio.ByteBuffer#compact compact} method when transferring data from&#xA;     * one place to another.  &lt;/p>&#xA;     *&#xA;     * @return  This buffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="rewind">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Rewinds this buffer.  The position is set to zero and the mark is&#xA;     * discarded.&#xA;     *&#xA;     * &lt;p> Invoke this method before a sequence of channel-write or &lt;i>get&lt;/i>&#xA;     * operations, assuming that the limit has already been set&#xA;     * appropriately.  For example:&#xA;     *&#xA;     * &lt;blockquote>&lt;pre>&#xA;     * out.write(buf);    // Write remaining data&#xA;     * buf.rewind();      // Rewind buffer&#xA;     * buf.get(array);    // Copy data into array&lt;/pre>&lt;/blockquote>&#xA;     *&#xA;     * @return  This buffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="remaining">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the number of elements between the current position and the&#xA;     * limit. &lt;/p>&#xA;     *&#xA;     * @return  The number of elements remaining in this buffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <additiveOperators xsi:type="operators:Subtraction"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hasRemaining">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tells whether there are any elements between the current position and&#xA;     * the limit. &lt;/p>&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, there is at least one element&#xA;     *          remaining in this buffer&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isReadOnly">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tells whether or not this buffer is read-only. &lt;/p>&#xA;     *&#xA;     * @return  &lt;tt>true&lt;/tt> if, and only if, this buffer is read-only&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="nextGetIndex">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>// -- Package-private methods for bounds checking, etc. --</comments>
        <comments>/**&#xA;     * Checks the current position against the limit, throwing a {@link&#xA;     * BufferUnderflowException} if it is not smaller than the limit, and then&#xA;     * increments the position. &lt;/p>&#xA;     *&#xA;     * @return  The current position value, before it is incremented&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// package-private</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferUnderflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <operator xsi:type="operators:PlusPlus"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="nextGetIndex">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nb">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <comments>// package-private</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferUnderflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="nextPutIndex">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Checks the current position against the limit, throwing a {@link&#xA;     * BufferOverflowException} if it is not smaller than the limit, and then&#xA;     * increments the position. &lt;/p>&#xA;     *&#xA;     * @return  The current position value, before it is incremented&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// package-private</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferOverflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <operator xsi:type="operators:PlusPlus"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="nextPutIndex">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nb">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <comments>// package-private</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferOverflowException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:AssignmentPlus"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkIndex">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Checks the given index against the limit, throwing an {@link&#xA;     * IndexOutOfBoundsException} if it is not smaller than the limit&#xA;     * or is smaller than zero.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <comments>// package-private</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkIndex">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nb">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <comments>// package-private</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="markValue">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <comments>// package-private</comments>
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkBounds">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="size">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <comments>// package-private</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InclusiveOrExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1"/>
                  <additiveOperators xsi:type="operators:Addition"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.2"/>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </expression>
                  </children>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </expression>
              </children>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A container for data of a specific primitive type.&#xA; *&#xA; * &lt;p> A buffer is a linear, finite sequence of elements of a specific&#xA; * primitive type.  Aside from its content, the essential properties of a&#xA; * buffer are its capacity, limit, and position: &lt;/p>&#xA; *&#xA; * &lt;blockquote>&#xA; *&#xA; *   &lt;p> A buffer's &lt;i>capacity&lt;/i> is the number of elements it contains.  The&#xA; *   capacity of a buffer is never negative and never changes.  &lt;/p>&#xA; *&#xA; *   &lt;p> A buffer's &lt;i>limit&lt;/i> is the index of the first element that should&#xA; *   not be read or written.  A buffer's limit is never negative and is never&#xA; *   greater than its capacity.  &lt;/p>&#xA; *&#xA; *   &lt;p> A buffer's &lt;i>position&lt;/i> is the index of the next element to be&#xA; *   read or written.  A buffer's position is never negative and is never&#xA; *   greater than its limit.  &lt;/p>&#xA; *&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p> There is one subclass of this class for each non-boolean primitive type.&#xA; *&#xA; * &#xA; * &lt;h4> Transferring data &lt;/h4>&#xA; *&#xA; * &lt;p> Each subclass of this class defines two categories of &lt;i>get&lt;/i> and&#xA; * &lt;i>put&lt;/i> operations: &lt;/p>&#xA; *&#xA; * &lt;blockquote>&#xA; *&#xA; *   &lt;p> &lt;i>Relative&lt;/i> operations read or write one or more elements starting&#xA; *   at the current position and then increment the position by the number of&#xA; *   elements transferred.  If the requested transfer exceeds the limit then a&#xA; *   relative &lt;i>get&lt;/i> operation throws a {@link BufferUnderflowException}&#xA; *   and a relative &lt;i>put&lt;/i> operation throws a {@link&#xA; *   BufferOverflowException}; in either case, no data is transferred.  &lt;/p>&#xA; *&#xA; *   &lt;p> &lt;i>Absolute&lt;/i> operations take an explicit element index and do not&#xA; *   affect the position.  Absolute &lt;i>get&lt;/i> and &lt;i>put&lt;/i> operations throw&#xA; *   an {@link IndexOutOfBoundsException} if the index argument exceeds the&#xA; *   limit.  &lt;/p>&#xA; *&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p> Data may also, of course, be transferred in to or out of a buffer by the&#xA; * I/O operations of an appropriate channel, which are always relative to the&#xA; * current position.&#xA; *&#xA; *&#xA; * &lt;h4> Marking and resetting &lt;/h4>&#xA; *&#xA; * &lt;p> A buffer's &lt;i>mark&lt;/i> is the index to which its position will be reset&#xA; * when the {@link #reset reset} method is invoked.  The mark is not always&#xA; * defined, but when it is defined it is never negative and is never greater&#xA; * than the position.  If the mark is defined then it is discarded when the&#xA; * position or the limit is adjusted to a value smaller than the mark.  If the&#xA; * mark is not defined then invoking the {@link #reset reset} method causes an&#xA; * {@link InvalidMarkException} to be thrown.&#xA; *&#xA; *&#xA; * &lt;h4> Invariants &lt;/h4>&#xA; *&#xA; * &lt;p> The following invariant holds for the mark, position, limit, and&#xA; * capacity values:&#xA; *&#xA; * &lt;blockquote>&#xA; *     &lt;tt>0&lt;/tt> &lt;tt>&amp;lt;=&lt;/tt>&#xA; *     &lt;i>mark&lt;/i> &lt;tt>&amp;lt;=&lt;/tt>&#xA; *     &lt;i>position&lt;/i> &lt;tt>&amp;lt;=&lt;/tt>&#xA; *     &lt;i>limit&lt;/i> &lt;tt>&amp;lt;=&lt;/tt>&#xA; *     &lt;i>capacity&lt;/i>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p> A newly-created buffer always has a position of zero and a mark that is&#xA; * undefined.  The initial limit may be zero, or it may be some other value&#xA; * that depends upon the type of the buffer and the manner in which it is&#xA; * constructed.  The initial content of a buffer is, in general,&#xA; * undefined.&#xA; *&#xA; *&#xA; * &lt;h4> Clearing, flipping, and rewinding &lt;/h4>&#xA; *&#xA; * &lt;p> In addition to methods for accessing the position, limit, and capacity&#xA; * values and for marking and resetting, this class also defines the following&#xA; * operations upon buffers:&#xA; *&#xA; * &lt;ul>&#xA; *&#xA; *   &lt;li>&lt;p> {@link #clear} makes a buffer ready for a new sequence of&#xA; *   channel-read or relative &lt;i>put&lt;/i> operations: It sets the limit to the&#xA; *   capacity and the position to zero.  &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> {@link #flip} makes a buffer ready for a new sequence of&#xA; *   channel-write or relative &lt;i>get&lt;/i> operations: It sets the limit to the&#xA; *   current position and then sets the position to zero.  &lt;/p>&lt;/li>&#xA; *&#xA; *   &lt;li>&lt;p> {@link #rewind} makes a buffer ready for re-reading the data that&#xA; *   it already contains: It leaves the limit unchanged and sets the position&#xA; *   to zero.  &lt;/p>&lt;/li>&#xA; *&#xA; * &lt;/ul>&#xA; *&#xA; *&#xA; * &lt;h4> Read-only buffers &lt;/h4>&#xA; *&#xA; * &lt;p> Every buffer is readable, but not every buffer is writable.  The&#xA; * mutation methods of each buffer class are specified as &lt;i>optional&#xA; * operations&lt;/i> that will throw a {@link ReadOnlyBufferException} when&#xA; * invoked upon a read-only buffer.  A read-only buffer does not allow its&#xA; * content to be changed, but its mark, position, and limit values are mutable.&#xA; * Whether or not a buffer is read-only may be determined by invoking its&#xA; * {@link #isReadOnly isReadOnly} method.&#xA; *&#xA; *&#xA; * &lt;h4> Thread safety &lt;/h4>&#xA; *&#xA; * &lt;p> Buffers are not safe for use by multiple concurrent threads.  If a&#xA; * buffer is to be used by more than one thread then access to the buffer&#xA; * should be controlled by appropriate synchronization.&#xA; *&#xA; *&#xA; * &lt;h4> Invocation chaining &lt;/h4>&#xA; *&#xA; * &lt;p> Methods in this class that do not otherwise have a value to return are&#xA; * specified to return the buffer upon which they are invoked.  This allows&#xA; * method invocations to be chained; for example, the sequence of statements&#xA; *&#xA; * &lt;blockquote>&lt;pre>&#xA; * b.flip();&#xA; * b.position(23);&#xA; * b.limit(42);&lt;/pre>&lt;/blockquote>&#xA; *&#xA; * can be replaced by the single, more compact statement&#xA; *&#xA; * &lt;blockquote>&lt;pre>&#xA; * b.flip().position(23).limit(42);&lt;/pre>&lt;/blockquote>&#xA; *&#xA; *&#xA; * @author Mark Reinhold&#xA; * @author JSR-51 Expert Group&#xA; * @version 1.35, 06/08/11&#xA; * @since 1.4&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
