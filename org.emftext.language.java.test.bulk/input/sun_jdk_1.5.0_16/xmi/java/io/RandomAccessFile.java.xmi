<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="RandomAccessFile.java">
  <comments>/*&#xA; * @(#)RandomAccessFile.java&#x9;1.78 04/05/13&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>io</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>channels</namespaces>
    <classifier xsi:type="classifiers:Class" href="../nio/channels/FileChannel.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>nio</namespaces>
    <namespaces>ch</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/nio/ch/FileChannelImpl.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="RandomAccessFile">
    <members xsi:type="members:Field" name="fd">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileDescriptor.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="channel">
      <initialValue xsi:type="literals:NullLiteral"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../nio/channels/FileChannel.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="rw">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="O_RDONLY">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="O_RDWR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="O_SYNC">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="O_DSYNC">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="RandomAccessFile">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </child>
            <expressionIf xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="File.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
            </expressionIf>
            <expressionElse xsi:type="literals:NullLiteral"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.1"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a random access file stream to read from, and optionally &#xA;     * to write to, a file with the specified name. A new &#xA;     * {@link FileDescriptor} object is created to represent the &#xA;     * connection to the file.&#xA;     * &#xA;     * &lt;p> The &lt;tt>mode&lt;/tt> argument specifies the access mode with which the&#xA;     * file is to be opened.  The permitted values and their meanings are as&#xA;     * specified for the &lt;a&#xA;     * href=&quot;#mode&quot;>&lt;tt>RandomAccessFile(File,String)&lt;/tt>&lt;/a> constructor.&#xA;     *&#xA;     * &lt;p>&#xA;     * If there is a security manager, its &lt;code>checkRead&lt;/code> method&#xA;     * is called with the &lt;code>name&lt;/code> argument&#xA;     * as its argument to see if read access to the file is allowed.&#xA;     * If the mode allows writing, the security manager's&#xA;     * &lt;code>checkWrite&lt;/code> method&#xA;     * is also called with the &lt;code>name&lt;/code> argument&#xA;     * as its argument to see if write access to the file is allowed.&#xA;     *&#xA;     * @param      name   the system-dependent filename&#xA;     * @param      mode   the access &lt;a href=&quot;#mode&quot;>mode&lt;/a>&#xA;     * @exception  IllegalArgumentException  if the mode argument is not equal&#xA;     *               to one of &lt;tt>&quot;r&quot;&lt;/tt>, &lt;tt>&quot;rw&quot;&lt;/tt>, &lt;tt>&quot;rws&quot;&lt;/tt>, or&#xA;     *               &lt;tt>&quot;rwd&quot;&lt;/tt>&#xA;     * @exception FileNotFoundException&#xA;     *            if the mode is &lt;tt>&quot;r&quot;&lt;/tt> but the given string does not&#xA;     *            denote an existing regular file, or if the mode begins with&#xA;     *            &lt;tt>&quot;rw&quot;&lt;/tt> but the given string does not denote an&#xA;     *            existing, writable regular file and a new regular file of&#xA;     *            that name cannot be created, or if some other error occurs&#xA;     *            while opening or creating the file&#xA;     * @exception  SecurityException         if a security manager exists and its&#xA;     *               &lt;code>checkRead&lt;/code> method denies read access to the file&#xA;     *               or the mode is &quot;rw&quot; and the security manager's&#xA;     *               &lt;code>checkWrite&lt;/code> method denies write access to the file&#xA;     * @see        java.lang.SecurityException&#xA;     * @see        java.lang.SecurityManager#checkRead(java.lang.String)&#xA;     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)&#xA;     * @revised 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="RandomAccessFile">
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="name">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalExpression">
              <child xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:NotEqual"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
                <children xsi:type="literals:NullLiteral"/>
              </child>
              <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="File.class.xmi#//@classifiers.0/@members.22"/>
                </next>
              </expressionIf>
              <expressionElse xsi:type="literals:NullLiteral"/>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="imode">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          </expression>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
            <arguments xsi:type="references:StringReference" value="r"/>
          </next>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </expression>
            </statements>
            <statements xsi:type="statements:Condition">
              <statement xsi:type="statements:Block">
                <statements xsi:type="statements:Condition">
                  <statement xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="expressions:AssignmentExpression">
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
                      <assignmentOperator xsi:type="operators:AssignmentOr"/>
                      <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                    </expression>
                  </statement>
                  <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.1">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                      <arguments xsi:type="references:StringReference" value="rws"/>
                    </next>
                  </condition>
                  <elseStatement xsi:type="statements:Condition">
                    <statement xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
                        <assignmentOperator xsi:type="operators:AssignmentOr"/>
                        <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
                      </expression>
                    </statement>
                    <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.1">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                        <arguments xsi:type="references:StringReference" value="rwd"/>
                      </next>
                    </condition>
                    <elseStatement xsi:type="statements:ExpressionStatement">
                      <expression xsi:type="expressions:AssignmentExpression">
                        <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
                        <assignmentOperator xsi:type="operators:Assignment"/>
                        <value xsi:type="expressions:UnaryExpression">
                          <operators xsi:type="operators:Subtraction"/>
                          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                        </value>
                      </expression>
                    </elseStatement>
                  </elseStatement>
                </statements>
              </statement>
              <condition xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.1">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </condition>
            </statements>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.42"/>
              <arguments xsi:type="references:StringReference" value="rw"/>
            </next>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="Illegal mode &quot;"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.1"/>
              <children xsi:type="references:StringReference" value="&quot; must be one of "/>
              <children xsi:type="references:StringReference" value="&quot;r&quot;, &quot;rw&quot;, &quot;rws&quot;,"/>
              <children xsi:type="references:StringReference" value=" or &quot;rwd&quot;"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.4/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.4/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.35"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.4/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="FileDescriptor.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@variable"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="file">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="File.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mode">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a random access file stream to read from, and optionally to&#xA;     * write to, the file specified by the {@link File} argument.  A new {@link&#xA;     * FileDescriptor} object is created to represent this file connection.&#xA;     *&#xA;     * &lt;a name=&quot;mode&quot;>&lt;p> The &lt;tt>mode&lt;/tt> argument specifies the access mode&#xA;     * in which the file is to be opened.  The permitted values and their&#xA;     * meanings are:&#xA;     *&#xA;     * &lt;blockquote>&lt;table summary=&quot;Access mode permitted values and meanings&quot;>&#xA;     * &lt;tr>&lt;th>&lt;p align=&quot;left&quot;>Value&lt;/p>&lt;/th>&lt;th>&lt;p align=&quot;left&quot;>Meaning&lt;/p>&lt;/th>&lt;/tr>&#xA;     * &lt;tr>&lt;td valign=&quot;top&quot;>&lt;tt>&quot;r&quot;&lt;/tt>&lt;/td>&#xA;     *     &lt;td> Open for reading only.  Invoking any of the &lt;tt>write&lt;/tt>&#xA;     *     methods of the resulting object will cause an {@link&#xA;     *     java.io.IOException} to be thrown. &lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td valign=&quot;top&quot;>&lt;tt>&quot;rw&quot;&lt;/tt>&lt;/td>&#xA;     *     &lt;td> Open for reading and writing.  If the file does not already&#xA;     *     exist then an attempt will be made to create it. &lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td valign=&quot;top&quot;>&lt;tt>&quot;rws&quot;&lt;/tt>&lt;/td>&#xA;     *     &lt;td> Open for reading and writing, as with &lt;tt>&quot;rw&quot;&lt;/tt>, and also&#xA;     *     require that every update to the file's content or metadata be&#xA;     *     written synchronously to the underlying storage device.  &lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td valign=&quot;top&quot;>&lt;tt>&quot;rwd&quot;&amp;nbsp;&amp;nbsp;&lt;/tt>&lt;/td>&#xA;     *     &lt;td> Open for reading and writing, as with &lt;tt>&quot;rw&quot;&lt;/tt>, and also&#xA;     *     require that every update to the file's content be written&#xA;     *     synchronously to the underlying storage device. &lt;/td>&lt;/tr>&#xA;     * &lt;/table>&lt;/blockquote>&#xA;     *&#xA;     * The &lt;tt>&quot;rws&quot;&lt;/tt> and &lt;tt>&quot;rwd&quot;&lt;/tt> modes work much like the {@link&#xA;     * java.nio.channels.FileChannel#force(boolean) force(boolean)} method of&#xA;     * the {@link java.nio.channels.FileChannel} class, passing arguments of&#xA;     * &lt;tt>true&lt;/tt> and &lt;tt>false&lt;/tt>, respectively, except that they always&#xA;     * apply to every I/O operation and are therefore often more efficient.  If&#xA;     * the file resides on a local storage device then when an invocation of a&#xA;     * method of this class returns it is guaranteed that all changes made to&#xA;     * the file by that invocation will have been written to that device.  This&#xA;     * is useful for ensuring that critical information is not lost in the&#xA;     * event of a system crash.  If the file does not reside on a local device&#xA;     * then no such guarantee is made.&#xA;     *&#xA;     * &lt;p> The &lt;tt>&quot;rwd&quot;&lt;/tt> mode can be used to reduce the number of I/O&#xA;     * operations performed.  Using &lt;tt>&quot;rwd&quot;&lt;/tt> only requires updates to the&#xA;     * file's content to be written to storage; using &lt;tt>&quot;rws&quot;&lt;/tt> requires&#xA;     * updates to both the file's content and its metadata to be written, which&#xA;     * generally requires at least one more low-level I/O operation.&#xA;     *&#xA;     * &lt;p> If there is a security manager, its &lt;code>checkRead&lt;/code> method is&#xA;     * called with the pathname of the &lt;code>file&lt;/code> argument as its&#xA;     * argument to see if read access to the file is allowed.  If the mode&#xA;     * allows writing, the security manager's &lt;code>checkWrite&lt;/code> method is&#xA;     * also called with the path argument to see if write access to the file is&#xA;     * allowed.&#xA;     *&#xA;     * @param      file   the file object&#xA;     * @param      mode   the access mode, as described&#xA;     *                    &lt;a href=&quot;#mode&quot;>above&lt;/a>&#xA;     * @exception  IllegalArgumentException  if the mode argument is not equal&#xA;     *               to one of &lt;tt>&quot;r&quot;&lt;/tt>, &lt;tt>&quot;rw&quot;&lt;/tt>, &lt;tt>&quot;rws&quot;&lt;/tt>, or&#xA;     *               &lt;tt>&quot;rwd&quot;&lt;/tt>&#xA;     * @exception FileNotFoundException&#xA;     *            if the mode is &lt;tt>&quot;r&quot;&lt;/tt> but the given file object does&#xA;     *            not denote an existing regular file, or if the mode begins&#xA;     *            with &lt;tt>&quot;rw&quot;&lt;/tt> but the given file object does not denote&#xA;     *            an existing, writable regular file and a new regular file of&#xA;     *            that name cannot be created, or if some other error occurs&#xA;     *            while opening or creating the file&#xA;     * @exception  SecurityException         if a security manager exists and its&#xA;     *               &lt;code>checkRead&lt;/code> method denies read access to the file&#xA;     *               or the mode is &quot;rw&quot; and the security manager's&#xA;     *               &lt;code>checkWrite&lt;/code> method denies write access to the file&#xA;     * @see        java.lang.SecurityManager#checkRead(java.lang.String)&#xA;     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)&#xA;     * @see        java.nio.channels.FileChannel#force(boolean)&#xA;     * @revised 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getFD">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileDescriptor.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the opaque file descriptor object associated with this&#xA;     * stream. &lt;/p>&#xA;     *&#xA;     * @return     the file descriptor object associated with this stream.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     * @see        java.io.FileDescriptor&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getChannel">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../nio/channels/FileChannel.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}&#xA;     * object associated with this file.&#xA;     *&#xA;     * &lt;p> The {@link java.nio.channels.FileChannel#position()&#xA;     * &lt;/code>position&lt;code>} of the returned channel will always be equal to&#xA;     * this object's file-pointer offset as returned by the {@link&#xA;     * #getFilePointer getFilePointer} method.  Changing this object's&#xA;     * file-pointer offset, whether explicitly or by reading or writing bytes,&#xA;     * will change the position of the channel, and vice versa.  Changing the&#xA;     * file's length via this object will change the length seen via the file&#xA;     * channel, and vice versa.&#xA;     *&#xA;     * @return  the file channel associated with this file&#xA;     *&#xA;     * @since 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../sun/nio/ch/FileChannelImpl.class.xmi#//@classifiers.0/@members.24"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
                  <arguments xsi:type="literals:BooleanLiteral" value="true"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../../sun/nio/ch/FileChannelImpl.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="open">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="mode">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Opens a file and returns the file descriptor.  The file is&#xA;     * opened in read-write mode if the O_RDWR bit in &lt;code>mode&lt;/code>&#xA;     * is true, else the file is opened as read-only.&#xA;     * If the &lt;code>name&lt;/code> refers to a directory, an IOException&#xA;     * is thrown.&#xA;     *&#xA;     * @param name the name of the file&#xA;     * @param mode the mode flags, a combination of the O_ constants&#xA;     *             defined above&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="read">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// 'Read' primitives</comments>
        <comments>/**&#xA;     * Reads a byte of data from this file. The byte is returned as an &#xA;     * integer in the range 0 to 255 (&lt;code>0x00-0x0ff&lt;/code>). This &#xA;     * method blocks if no input is yet available. &#xA;     * &lt;p>&#xA;     * Although &lt;code>RandomAccessFile&lt;/code> is not a subclass of &#xA;     * &lt;code>InputStream&lt;/code>, this method behaves in exactly the same &#xA;     * way as the {@link InputStream#read()} method of &#xA;     * &lt;code>InputStream&lt;/code>.&#xA;     *&#xA;     * @return     the next byte of data, or &lt;code>-1&lt;/code> if the end of the&#xA;     *             file has been reached.&#xA;     * @exception  IOException  if an I/O error occurs. Not thrown if  &#xA;     *                          end-of-file has been reached.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readBytes">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Reads a sub array as a sequence of bytes. &#xA;     * @param b the buffer into which the data is read.&#xA;     * @param off the start offset of the data.&#xA;     * @param len the number of bytes to read.&#xA;     * @exception IOException If an I/O error has occurred.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:ClassMethod" name="read">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads up to &lt;code>len&lt;/code> bytes of data from this file into an &#xA;     * array of bytes. This method blocks until at least one byte of input &#xA;     * is available. &#xA;     * &lt;p>&#xA;     * Although &lt;code>RandomAccessFile&lt;/code> is not a subclass of &#xA;     * &lt;code>InputStream&lt;/code>, this method behaves in exactly the &#xA;     * same way as the {@link InputStream#read(byte[], int, int)} method of &#xA;     * &lt;code>InputStream&lt;/code>.&#xA;     *&#xA;     * @param      b     the buffer into which the data is read.&#xA;     * @param      off   the start offset of the data.&#xA;     * @param      len   the maximum number of bytes read.&#xA;     * @return     the total number of bytes read into the buffer, or&#xA;     *             &lt;code>-1&lt;/code> if there is no more data because the end of&#xA;     *             the file has been reached.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="read">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads up to &lt;code>b.length&lt;/code> bytes of data from this file &#xA;     * into an array of bytes. This method blocks until at least one byte &#xA;     * of input is available. &#xA;     * &lt;p>&#xA;     * Although &lt;code>RandomAccessFile&lt;/code> is not a subclass of &#xA;     * &lt;code>InputStream&lt;/code>, this method behaves in exactly the &#xA;     * same way as the {@link InputStream#read(byte[])} method of &#xA;     * &lt;code>InputStream&lt;/code>.&#xA;     *&#xA;     * @param      b   the buffer into which the data is read.&#xA;     * @return     the total number of bytes read into the buffer, or&#xA;     *             &lt;code>-1&lt;/code> if there is no more data because the end of&#xA;     *             this file has been reached.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readFully">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads &lt;code>b.length&lt;/code> bytes from this file into the byte &#xA;     * array, starting at the current file pointer. This method reads &#xA;     * repeatedly from the file until the requested number of bytes are &#xA;     * read. This method blocks until the requested number of bytes are &#xA;     * read, the end of the stream is detected, or an exception is thrown. &#xA;     *&#xA;     * @param      b   the buffer into which the data is read.&#xA;     * @exception  EOFException  if this file reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.       &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.17">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readFully">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads exactly &lt;code>len&lt;/code> bytes from this file into the byte &#xA;     * array, starting at the current file pointer. This method reads &#xA;     * repeatedly from the file until the requested number of bytes are &#xA;     * read. This method blocks until the requested number of bytes are &#xA;     * read, the end of the stream is detected, or an exception is thrown. &#xA;     *&#xA;     * @param      b     the buffer into which the data is read.&#xA;     * @param      off   the start offset of the data.&#xA;     * @param      len   the number of bytes to read.&#xA;     * @exception  EOFException  if this file reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:DoWhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="count">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="references:SelfReference">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.1"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.2"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                  </arguments>
                </next>
                <self xsi:type="literals:This"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="EOFException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </throwable>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.1/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:AssignmentPlus"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.1/@statement/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="skipBytes">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Attempts to skip over &lt;code>n&lt;/code> bytes of input discarding the &#xA;     * skipped bytes. &#xA;     * &lt;p>&#xA;     * &#xA;     * This method may skip over some smaller number of bytes, possibly zero. &#xA;     * This may result from any of a number of conditions; reaching end of &#xA;     * file before &lt;code>n&lt;/code> bytes have been skipped is only one &#xA;     * possibility. This method never throws an &lt;code>EOFException&lt;/code>. &#xA;     * The actual number of bytes skipped is returned.  If &lt;code>n&lt;/code> &#xA;     * is negative, no bytes are skipped.&#xA;     *&#xA;     * @param      n   the number of bytes to be skipped.&#xA;     * @return     the actual number of bytes skipped.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="pos">
          <typeReference xsi:type="types:Long"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Long"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="newpos">
          <typeReference xsi:type="types:Long"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.23"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.25"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.2/@variable"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.2/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.2/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:GreaterThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.2/@variable"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>/* return the actual number of bytes skipped */</comments>
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Int"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// 'Write' primitives</comments>
        <comments>/**&#xA;     * Writes the specified byte to this file. The write starts at &#xA;     * the current file pointer.&#xA;     *&#xA;     * @param      b   the &lt;code>byte&lt;/code> to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="writeBytes">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Writes a sub array as a sequence of bytes. &#xA;     * @param b the data to be written&#xA;&#xA;     * @param off the start offset in the data&#xA;     * @param len the number of bytes that are written&#xA;     * @exception IOException If an I/O error has occurred.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes &lt;code>b.length&lt;/code> bytes from the specified byte array &#xA;     * to this file, starting at the current file pointer. &#xA;     *&#xA;     * @param      b   the data.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes &lt;code>len&lt;/code> bytes from the specified byte array &#xA;     * starting at offset &lt;code>off&lt;/code> to this file. &#xA;     *&#xA;     * @param      b     the data.&#xA;     * @param      off   the start offset in the data.&#xA;     * @param      len   the number of bytes to write.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.2"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFilePointer">
      <typeReference xsi:type="types:Long"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// 'Random access' stuff</comments>
        <comments>/**&#xA;     * Returns the current offset in this file. &#xA;     *&#xA;     * @return     the offset from the beginning of the file, in bytes,&#xA;     *             at which the next read or write occurs.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="seek">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pos">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the file-pointer offset, measured from the beginning of this &#xA;     * file, at which the next read or write occurs.  The offset may be &#xA;     * set beyond the end of the file. Setting the offset beyond the end &#xA;     * of the file does not change the file length.  The file length will &#xA;     * change only by writing after the offset has been set beyond the end &#xA;     * of the file. &#xA;     *&#xA;     * @param      pos   the offset position, measured in bytes from the &#xA;     *                   beginning of the file, at which to set the file &#xA;     *                   pointer.&#xA;     * @exception  IOException  if &lt;code>pos&lt;/code> is less than &#xA;     *                          &lt;code>0&lt;/code> or if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="length">
      <typeReference xsi:type="types:Long"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the length of this file.&#xA;     *&#xA;     * @return     the length of this file, measured in bytes.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setLength">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="newLength">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the length of this file.&#xA;     *&#xA;     * &lt;p> If the present length of the file as returned by the&#xA;     * &lt;code>length&lt;/code> method is greater than the &lt;code>newLength&lt;/code>&#xA;     * argument then the file will be truncated.  In this case, if the file&#xA;     * offset as returned by the &lt;code>getFilePointer&lt;/code> method is greater&#xA;     * than &lt;code>newLength&lt;/code> then after this method returns the offset&#xA;     * will be equal to &lt;code>newLength&lt;/code>.&#xA;     *&#xA;     * &lt;p> If the present length of the file as returned by the&#xA;     * &lt;code>length&lt;/code> method is smaller than the &lt;code>newLength&lt;/code>&#xA;     * argument then the file will be extended.  In this case, the contents of&#xA;     * the extended portion of the file are not defined.&#xA;     *&#xA;     * @param      newLength    The desired length of the file&#xA;     * @exception  IOException  If an I/O error occurs&#xA;     * @since      1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:ClassMethod" name="close">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Closes this random access file stream and releases any system &#xA;     * resources associated with the stream. A closed random access &#xA;     * file cannot perform input or output operations and cannot be &#xA;     * reopened.&#xA;     *&#xA;     * &lt;p> If this file has an associated channel then the channel is closed&#xA;     * as well.&#xA;     *&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     *&#xA;     * @revised 1.4&#xA;     * @spec JSR-51&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../nio/channels/spi/AbstractInterruptibleChannel.class.xmi#//@classifiers.0/@members.5"/>
            </next>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.52"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readBoolean">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>//</comments>
        <comments>//  Some &quot;reading/writing Java data types&quot; methods stolen from</comments>
        <comments>//  DataInputStream and DataOutputStream.</comments>
        <comments>//</comments>
        <comments>/**&#xA;     * Reads a &lt;code>boolean&lt;/code> from this file. This method reads a &#xA;     * single byte from the file, starting at the current file pointer. &#xA;     * A value of &lt;code>0&lt;/code> represents &#xA;     * &lt;code>false&lt;/code>. Any other value represents &lt;code>true&lt;/code>. &#xA;     * This method blocks until the byte is read, the end of the stream &#xA;     * is detected, or an exception is thrown. &#xA;     *&#xA;     * @return     the &lt;code>boolean&lt;/code> value read.&#xA;     * @exception  EOFException  if this file has reached the end.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="EOFException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readByte">
      <typeReference xsi:type="types:Byte"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a signed eight-bit value from this file. This method reads a &#xA;     * byte from the file, starting from the current file pointer. &#xA;     * If the byte read is &lt;code>b&lt;/code>, where &#xA;     * &lt;code>0&amp;nbsp;&amp;lt;=&amp;nbsp;b&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code>, &#xA;     * then the result is:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *     (byte)(b)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p>&#xA;     * This method blocks until the byte is read, the end of the stream &#xA;     * is detected, or an exception is thrown. &#xA;     *&#xA;     * @return     the next byte of this file as a signed eight-bit&#xA;     *             &lt;code>byte&lt;/code>.&#xA;     * @exception  EOFException  if this file has reached the end.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="EOFException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Byte"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.0/@variable"/>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readUnsignedByte">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads an unsigned eight-bit number from this file. This method reads &#xA;     * a byte from this file, starting at the current file pointer, &#xA;     * and returns that byte. &#xA;     * &lt;p>&#xA;     * This method blocks until the byte is read, the end of the stream &#xA;     * is detected, or an exception is thrown. &#xA;     *&#xA;     * @return     the next byte of this file, interpreted as an unsigned&#xA;     *             eight-bit number.&#xA;     * @exception  EOFException  if this file has reached the end.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="EOFException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readShort">
      <typeReference xsi:type="types:Short"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a signed 16-bit number from this file. The method reads two &#xA;     * bytes from this file, starting at the current file pointer. &#xA;     * If the two bytes read, in order, are &#xA;     * &lt;code>b1&lt;/code> and &lt;code>b2&lt;/code>, where each of the two values is &#xA;     * between &lt;code>0&lt;/code> and &lt;code>255&lt;/code>, inclusive, then the &#xA;     * result is equal to:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *     (short)((b1 &amp;lt;&amp;lt; 8) | b2)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p>&#xA;     * This method blocks until the two bytes are read, the end of the &#xA;     * stream is detected, or an exception is thrown. &#xA;     *&#xA;     * @return     the next two bytes of this file, interpreted as a signed&#xA;     *             16-bit number.&#xA;     * @exception  EOFException  if this file reaches the end before reading&#xA;     *               two bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch1">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch2">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="EOFException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InclusiveOrExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.1/@variable"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Short"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.1/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </expression>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readUnsignedShort">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads an unsigned 16-bit number from this file. This method reads &#xA;     * two bytes from the file, starting at the current file pointer. &#xA;     * If the bytes read, in order, are &#xA;     * &lt;code>b1&lt;/code> and &lt;code>b2&lt;/code>, where &#xA;     * &lt;code>0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code>, &#xA;     * then the result is equal to:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *     (b1 &amp;lt;&amp;lt; 8) | b2&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p>&#xA;     * This method blocks until the two bytes are read, the end of the &#xA;     * stream is detected, or an exception is thrown. &#xA;     *&#xA;     * @return     the next two bytes of this file, interpreted as an unsigned&#xA;     *             16-bit integer.&#xA;     * @exception  EOFException  if this file reaches the end before reading&#xA;     *               two bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch1">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch2">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="EOFException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InclusiveOrExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@variable"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ShiftExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
              <shiftOperators xsi:type="operators:LeftShift"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ShiftExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.1/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <shiftOperators xsi:type="operators:LeftShift"/>
            </expression>
          </children>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readChar">
      <typeReference xsi:type="types:Char"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a Unicode character from this file. This method reads two&#xA;     * bytes from the file, starting at the current file pointer. &#xA;     * If the bytes read, in order, are &#xA;     * &lt;code>b1&lt;/code> and &lt;code>b2&lt;/code>, where &#xA;     * &lt;code>0&amp;nbsp;&amp;lt;=&amp;nbsp;b1,&amp;nbsp;b2&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code>, &#xA;     * then the result is equal to:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *     (char)((b1 &amp;lt;&amp;lt; 8) | b2)&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p>&#xA;     * This method blocks until the two bytes are read, the end of the &#xA;     * stream is detected, or an exception is thrown. &#xA;     *&#xA;     * @return     the next two bytes of this file as a Unicode character.&#xA;     * @exception  EOFException  if this file reaches the end before reading&#xA;     *               two bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch1">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch2">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="EOFException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InclusiveOrExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.1/@variable"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:Char"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.1/@variable"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <shiftOperators xsi:type="operators:LeftShift"/>
                </expression>
              </children>
              <additiveOperators xsi:type="operators:Addition"/>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readInt">
      <typeReference xsi:type="types:Int"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a signed 32-bit integer from this file. This method reads 4 &#xA;     * bytes from the file, starting at the current file pointer. &#xA;     * If the bytes read, in order, are &lt;code>b1&lt;/code>,&#xA;     * &lt;code>b2&lt;/code>, &lt;code>b3&lt;/code>, and &lt;code>b4&lt;/code>, where &#xA;     * &lt;code>0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2, b3, b4&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code>, &#xA;     * then the result is equal to:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *     (b1 &amp;lt;&amp;lt; 24) | (b2 &amp;lt;&amp;lt; 16) + (b3 &amp;lt;&amp;lt; 8) + b4&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p>&#xA;     * This method blocks until the four bytes are read, the end of the &#xA;     * stream is detected, or an exception is thrown. &#xA;     *&#xA;     * @return     the next four bytes of this file, interpreted as an&#xA;     *             &lt;code>int&lt;/code>.&#xA;     * @exception  EOFException  if this file reaches the end before reading&#xA;     *               four bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch1">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch2">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch3">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ch4">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="EOFException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InclusiveOrExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@variable"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.3/@variable"/>
            </expression>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:AdditiveExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="24"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.1/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.2/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.3/@variable"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <shiftOperators xsi:type="operators:LeftShift"/>
              </expression>
            </children>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readLong">
      <typeReference xsi:type="types:Long"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a signed 64-bit integer from this file. This method reads eight&#xA;     * bytes from the file, starting at the current file pointer. &#xA;     * If the bytes read, in order, are &#xA;     * &lt;code>b1&lt;/code>, &lt;code>b2&lt;/code>, &lt;code>b3&lt;/code>, &#xA;     * &lt;code>b4&lt;/code>, &lt;code>b5&lt;/code>, &lt;code>b6&lt;/code>, &#xA;     * &lt;code>b7&lt;/code>, and &lt;code>b8,&lt;/code> where:&#xA;     * &lt;blockquote>&lt;pre>&#xA;     *     0 &amp;lt;= b1, b2, b3, b4, b5, b6, b7, b8 &amp;lt;=255,&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p>&#xA;     * then the result is equal to:&#xA;     * &lt;p>&lt;blockquote>&lt;pre>&#xA;     *     ((long)b1 &amp;lt;&amp;lt; 56) + ((long)b2 &amp;lt;&amp;lt; 48)&#xA;     *     + ((long)b3 &amp;lt;&amp;lt; 40) + ((long)b4 &amp;lt;&amp;lt; 32)&#xA;     *     + ((long)b5 &amp;lt;&amp;lt; 24) + ((long)b6 &amp;lt;&amp;lt; 16)&#xA;     *     + ((long)b7 &amp;lt;&amp;lt; 8) + b8&#xA;     * &lt;/pre>&lt;/blockquote>&#xA;     * &lt;p>&#xA;     * This method blocks until the eight bytes are read, the end of the &#xA;     * stream is detected, or an exception is thrown. &#xA;     *&#xA;     * @return     the next eight bytes of this file, interpreted as a&#xA;     *             &lt;code>long&lt;/code>.&#xA;     * @exception  EOFException  if this file reaches the end before reading&#xA;     *               eight bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ShiftExpression">
              <children xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Long"/>
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.34"/>
                </child>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="32"/>
              <shiftOperators xsi:type="operators:LeftShift"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AndExpression">
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.34"/>
              <children xsi:type="literals:HexLongLiteral" hexValue="4294967295"/>
            </expression>
          </children>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readFloat">
      <typeReference xsi:type="types:Float"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a &lt;code>float&lt;/code> from this file. This method reads an &#xA;     * &lt;code>int&lt;/code> value, starting at the current file pointer, &#xA;     * as if by the &lt;code>readInt&lt;/code> method &#xA;     * and then converts that &lt;code>int&lt;/code> to a &lt;code>float&lt;/code> &#xA;     * using the &lt;code>intBitsToFloat&lt;/code> method in class &#xA;     * &lt;code>Float&lt;/code>. &#xA;     * &lt;p>&#xA;     * This method blocks until the four bytes are read, the end of the &#xA;     * stream is detected, or an exception is thrown. &#xA;     *&#xA;     * @return     the next four bytes of this file, interpreted as a&#xA;     *             &lt;code>float&lt;/code>.&#xA;     * @exception  EOFException  if this file reaches the end before reading&#xA;     *             four bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     * @see        java.io.RandomAccessFile#readInt()&#xA;     * @see        java.lang.Float#intBitsToFloat(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Float.class.xmi#//@classifiers.0/@members.32"/>
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.34"/>
          </next>
          <target xsi:type="classifiers:Class" href="../lang/Float.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readDouble">
      <typeReference xsi:type="types:Double"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads a &lt;code>double&lt;/code> from this file. This method reads a &#xA;     * &lt;code>long&lt;/code> value, starting at the current file pointer, &#xA;     * as if by the &lt;code>readLong&lt;/code> method &#xA;     * and then converts that &lt;code>long&lt;/code> to a &lt;code>double&lt;/code> &#xA;     * using the &lt;code>longBitsToDouble&lt;/code> method in &#xA;     * class &lt;code>Double&lt;/code>.&#xA;     * &lt;p>&#xA;     * This method blocks until the eight bytes are read, the end of the &#xA;     * stream is detected, or an exception is thrown. &#xA;     *&#xA;     * @return     the next eight bytes of this file, interpreted as a&#xA;     *             &lt;code>double&lt;/code>.&#xA;     * @exception  EOFException  if this file reaches the end before reading&#xA;     *             eight bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     * @see        java.io.RandomAccessFile#readLong()&#xA;     * @see        java.lang.Double#longBitsToDouble(long)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/Double.class.xmi#//@classifiers.0/@members.31"/>
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.35"/>
          </next>
          <target xsi:type="classifiers:Class" href="../lang/Double.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readLine">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads the next line of text from this file.  This method successively&#xA;     * reads bytes from the file, starting at the current file pointer, &#xA;     * until it reaches a line terminator or the end&#xA;     * of the file.  Each byte is converted into a character by taking the&#xA;     * byte's value for the lower eight bits of the character and setting the&#xA;     * high eight bits of the character to zero.  This method does not,&#xA;     * therefore, support the full Unicode character set.&#xA;     *&#xA;     * &lt;p> A line of text is terminated by a carriage-return character&#xA;     * (&lt;code>'&amp;#92;r'&lt;/code>), a newline character (&lt;code>'&amp;#92;n'&lt;/code>), a&#xA;     * carriage-return character immediately followed by a newline character,&#xA;     * or the end of the file.  Line-terminating characters are discarded and&#xA;     * are not included as part of the string returned.&#xA;     *&#xA;     * &lt;p> This method blocks until a newline character is read, a carriage&#xA;     * return and the byte following it are read (to see if it is a newline),&#xA;     * the end of the file is reached, or an exception is thrown.&#xA;     *&#xA;     * @return     the next line of text from this file, or null if end&#xA;     *             of file is encountered before even one byte is read.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="input">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/StringBuffer.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="eol">
          <typeReference xsi:type="types:Boolean"/>
          <initialValue xsi:type="literals:BooleanLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:WhileLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.2/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:BooleanLiteral" value="true"/>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="literals:CharacterLiteral" value="10"/>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.2/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="literals:BooleanLiteral" value="true"/>
                </expression>
              </statements>
              <statements xsi:type="statements:LocalVariableStatement">
                <variable name="cur">
                  <typeReference xsi:type="types:Long"/>
                  <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.23"/>
                </variable>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.3/@statement/@statements.0/@cases.2/@statements.1/@variable"/>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="expressions:NestedExpression">
                    <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
                  </children>
                  <children xsi:type="literals:CharacterLiteral" value="10"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="literals:CharacterLiteral" value="13"/>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.26"/>
                    <arguments xsi:type="expressions:CastExpression">
                      <typeReference xsi:type="types:Char"/>
                      <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.1/@variable"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
            </cases>
            <variable xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
            </variable>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.2/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:NullLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.1/@variable"/>
              <children xsi:type="expressions:UnaryExpression">
                <operators xsi:type="operators:Subtraction"/>
                <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </children>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.6"/>
                </next>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/StringBuffer.class.xmi#//@classifiers.0/@members.55"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readUTF">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Reads in a string from this file. The string has been encoded &#xA;     * using a&#xA;     * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;>modified UTF-8&lt;/a>&#xA;     * format. &#xA;     * &lt;p>&#xA;     * The first two bytes are read, starting from the current file &#xA;     * pointer, as if by &#xA;     * &lt;code>readUnsignedShort&lt;/code>. This value gives the number of &#xA;     * following bytes that are in the encoded string, not&#xA;     * the length of the resulting string. The following bytes are then &#xA;     * interpreted as bytes encoding characters in the modified UTF-8 format &#xA;     * and are converted into characters. &#xA;     * &lt;p>&#xA;     * This method blocks until all the bytes are read, the end of the &#xA;     * stream is detected, or an exception is thrown. &#xA;     *&#xA;     * @return     a Unicode string.&#xA;     * @exception  EOFException            if this file reaches the end before&#xA;     *               reading all the bytes.&#xA;     * @exception  IOException             if an I/O error occurs.&#xA;     * @exception  UTFDataFormatException  if the bytes do not represent &#xA;     *               valid modified UTF-8 encoding of a Unicode string.&#xA;     * @see        java.io.RandomAccessFile#readUnsignedShort()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="DataInputStream.class.xmi#//@classifiers.0/@members.22"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="DataInputStream.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeBoolean">
      <comments>//written++;</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a &lt;code>boolean&lt;/code> to the file as a one-byte value. The &#xA;     * value &lt;code>true&lt;/code> is written out as the value &#xA;     * &lt;code>(byte)1&lt;/code>; the value &lt;code>false&lt;/code> is written out &#xA;     * as the value &lt;code>(byte)0&lt;/code>. The write starts at &#xA;     * the current position of the file pointer.&#xA;     *&#xA;     * @param      v   a &lt;code>boolean&lt;/code> value to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
            <expressionIf xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <expressionElse xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeByte">
      <comments>//written++;</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a &lt;code>byte&lt;/code> to the file as a one-byte value. The &#xA;     * write starts at the current position of the file pointer.&#xA;     *&#xA;     * @param      v   a &lt;code>byte&lt;/code> value to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeShort">
      <comments>//written += 2;</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a &lt;code>short&lt;/code> to the file as two bytes, high byte first. &#xA;     * The write starts at the current position of the file pointer.&#xA;     *&#xA;     * @param      v   a &lt;code>short&lt;/code> to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                <shiftOperators xsi:type="operators:UnsignedRightShift"/>
              </expression>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <shiftOperators xsi:type="operators:UnsignedRightShift"/>
              </expression>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeChar">
      <comments>//written += 2;</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a &lt;code>char&lt;/code> to the file as a two-byte value, high&#xA;     * byte first. The write starts at the current position of the &#xA;     * file pointer.&#xA;     *&#xA;     * @param      v   a &lt;code>char&lt;/code> value to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                <shiftOperators xsi:type="operators:UnsignedRightShift"/>
              </expression>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <shiftOperators xsi:type="operators:UnsignedRightShift"/>
              </expression>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeInt">
      <comments>//written += 4;</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes an &lt;code>int&lt;/code> to the file as four bytes, high byte first. &#xA;     * The write starts at the current position of the file pointer.&#xA;     *&#xA;     * @param      v   an &lt;code>int&lt;/code> to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="24"/>
                <shiftOperators xsi:type="operators:UnsignedRightShift"/>
              </expression>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                <shiftOperators xsi:type="operators:UnsignedRightShift"/>
              </expression>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                <shiftOperators xsi:type="operators:UnsignedRightShift"/>
              </expression>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:ShiftExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <shiftOperators xsi:type="operators:UnsignedRightShift"/>
              </expression>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeLong">
      <comments>//written += 8;</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a &lt;code>long&lt;/code> to the file as eight bytes, high byte first. &#xA;     * The write starts at the current position of the file pointer.&#xA;     *&#xA;     * @param      v   a &lt;code>long&lt;/code> to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="56"/>
                  <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                </expression>
              </child>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="48"/>
                  <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                </expression>
              </child>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="40"/>
                  <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                </expression>
              </child>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="32"/>
                  <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                </expression>
              </child>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="24"/>
                  <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                </expression>
              </child>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                  <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                </expression>
              </child>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                  <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                </expression>
              </child>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AndExpression">
            <children xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:Int"/>
              <child xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:ShiftExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                </expression>
              </child>
            </children>
            <children xsi:type="literals:HexIntegerLiteral" hexValue="255"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeFloat">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts the float argument to an &lt;code>int&lt;/code> using the &#xA;     * &lt;code>floatToIntBits&lt;/code> method in class &lt;code>Float&lt;/code>, &#xA;     * and then writes that &lt;code>int&lt;/code> value to the file as a &#xA;     * four-byte quantity, high byte first. The write starts at the &#xA;     * current position of the file pointer.&#xA;     *&#xA;     * @param      v   a &lt;code>float&lt;/code> value to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     * @see        java.lang.Float#floatToIntBits(float)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.44">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Float.class.xmi#//@classifiers.0/@members.30"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Float.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeDouble">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="v">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts the double argument to a &lt;code>long&lt;/code> using the &#xA;     * &lt;code>doubleToLongBits&lt;/code> method in class &lt;code>Double&lt;/code>, &#xA;     * and then writes that &lt;code>long&lt;/code> value to the file as an &#xA;     * eight-byte quantity, high byte first. The write starts at the current &#xA;     * position of the file pointer.&#xA;     *&#xA;     * @param      v   a &lt;code>double&lt;/code> value to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     * @see        java.lang.Double#doubleToLongBits(double)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.45">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Double.class.xmi#//@classifiers.0/@members.29"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/Double.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeBytes">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes the string to the file as a sequence of bytes. Each &#xA;     * character in the string is written out, in sequence, by discarding &#xA;     * its high eight bits. The write starts at the current position of &#xA;     * the file pointer.&#xA;     *&#xA;     * @param      s   a string of bytes to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="len">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="b">
          <typeReference xsi:type="types:Byte"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Byte"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.30"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.1/@variable"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.1/@variable"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.0/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeChars">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a string to the file as a sequence of characters. Each &#xA;     * character is written to the data output stream as if by the &#xA;     * &lt;code>writeChar&lt;/code> method. The write starts at the current &#xA;     * position of the file pointer.&#xA;     *&#xA;     * @param      s   a &lt;code>String&lt;/code> value to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     * @see        java.io.RandomAccessFile#writeChar(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="clen">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="blen">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.0/@variable"/>
            <multiplicativeOperators xsi:type="operators:Multiplication"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="b">
          <typeReference xsi:type="types:Byte"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Byte"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:Char"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Char"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.0/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.29"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.0/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.3/@variable"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.5/@init/@additionalLocalVariables.0"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Byte"/>
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.3/@variable">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.5/@init"/>
                      </arraySelectors>
                    </children>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                    <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                  </expression>
                </child>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable">
                <arraySelectors>
                  <position xsi:type="expressions:SuffixUnaryModificationExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.5/@init/@additionalLocalVariables.0"/>
                    <operator xsi:type="operators:PlusPlus"/>
                  </position>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:Byte"/>
                <child xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.3/@variable">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.5/@init"/>
                      </arraySelectors>
                    </children>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                    <shiftOperators xsi:type="operators:UnsignedRightShift"/>
                  </expression>
                </child>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.5/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.0/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <additionalLocalVariables name="j">
            <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </additionalLocalVariables>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.5/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.2/@variable"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.1/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeUTF">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a string to the file using&#xA;     * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;>modified UTF-8&lt;/a>&#xA;     * encoding in a machine-independent manner. &#xA;     * &lt;p>&#xA;     * First, two bytes are written to the file, starting at the &#xA;     * current file pointer, as if by the &#xA;     * &lt;code>writeShort&lt;/code> method giving the number of bytes to &#xA;     * follow. This value is the number of bytes actually written out, &#xA;     * not the length of the string. Following the length, each character &#xA;     * of the string is output, in sequence, using the modified UTF-8 encoding &#xA;     * for each character. &#xA;     *&#xA;     * @param      str   a string to be written.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="DataOutputStream.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="DataOutputStream.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="initIDs">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="close0">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="statements:Block">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.51"/>
      </statements>
      <modifiers xsi:type="modifiers:Static"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Instances of this class support both reading and writing to a &#xA; * random access file. A random access file behaves like a large &#xA; * array of bytes stored in the file system. There is a kind of cursor, &#xA; * or index into the implied array, called the &lt;em>file pointer&lt;/em>; &#xA; * input operations read bytes starting at the file pointer and advance &#xA; * the file pointer past the bytes read. If the random access file is &#xA; * created in read/write mode, then output operations are also available; &#xA; * output operations write bytes starting at the file pointer and advance &#xA; * the file pointer past the bytes written. Output operations that write &#xA; * past the current end of the implied array cause the array to be &#xA; * extended. The file pointer can be read by the &#xA; * &lt;code>getFilePointer&lt;/code> method and set by the &lt;code>seek&lt;/code> &#xA; * method. &#xA; * &lt;p>&#xA; * It is generally true of all the reading routines in this class that &#xA; * if end-of-file is reached before the desired number of bytes has been &#xA; * read, an &lt;code>EOFException&lt;/code> (which is a kind of &#xA; * &lt;code>IOException&lt;/code>) is thrown. If any byte cannot be read for &#xA; * any reason other than end-of-file, an &lt;code>IOException&lt;/code> other &#xA; * than &lt;code>EOFException&lt;/code> is thrown. In particular, an &#xA; * &lt;code>IOException&lt;/code> may be thrown if the stream has been closed.&#xA; *&#xA; * @author  unascribed&#xA; * @version 1.78, 05/13/04&#xA; * @since   JDK1.0&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="DataOutput.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="DataInput.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Closeable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
