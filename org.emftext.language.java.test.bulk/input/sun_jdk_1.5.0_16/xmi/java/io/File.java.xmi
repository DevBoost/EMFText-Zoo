<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="File.java">
  <comments>/*&#xA; * @(#)File.java&#x9;1.122 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>io</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>net</namespaces>
    <classifier xsi:type="classifiers:Class" href="../net/URI.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>net</namespaces>
    <classifier xsi:type="classifiers:Class" href="../net/URL.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>net</namespaces>
    <classifier xsi:type="classifiers:Class" href="../net/MalformedURLException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>net</namespaces>
    <classifier xsi:type="classifiers:Class" href="../net/URISyntaxException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/ArrayList.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Hashtable.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Random.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../security/AccessControlException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>security</namespaces>
    <namespaces>action</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/security/action/GetPropertyAction.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="File">
    <members xsi:type="members:Field" name="fs">
      <initialValue xsi:type="references:IdentifierReference">
        <next xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.7"/>
        </next>
        <target xsi:type="classifiers:Class" href="FileSystem.class.xmi#//@classifiers.0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileSystem.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * The FileSystem object representing the platform's local file system.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="path">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * This abstract pathname's normalized pathname string.  A normalized&#xA;     * pathname string uses the default name-separator character and does not&#xA;     * contain any duplicate or redundant separators.&#xA;     *&#xA;     * @serial&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="prefixLength">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * The length of this abstract pathname's prefix, or zero if it has no&#xA;     * prefix.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getPrefixLength">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Returns the length of this abstract pathname's prefix.&#xA;     * For use by FileSystem classes.&#xA;     */</comments>
      </typeReference>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:Field" name="separatorChar">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
        <next xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.8"/>
        </next>
      </initialValue>
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The system-dependent default name-separator character.  This field is&#xA;     * initialized to contain the first character of the value of the system&#xA;     * property &lt;code>file.separator&lt;/code>.  On UNIX systems the value of this&#xA;     * field is &lt;code>'/'&lt;/code>; on Microsoft Windows systems it is &lt;code>'\\'&lt;/code>.&#xA;     *&#xA;     * @see     java.lang.System#getProperty(java.lang.String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="separator">
      <initialValue xsi:type="expressions:AdditiveExpression">
        <children xsi:type="references:StringReference" value=""/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        <additiveOperators xsi:type="operators:Addition"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The system-dependent default name-separator character, represented as a&#xA;     * string for convenience.  This string contains a single character, namely&#xA;     * &lt;code>{@link #separatorChar}&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="pathSeparatorChar">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
        <next xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.9"/>
        </next>
      </initialValue>
      <typeReference xsi:type="types:Char"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The system-dependent path-separator character.  This field is&#xA;     * initialized to contain the first character of the value of the system&#xA;     * property &lt;code>path.separator&lt;/code>.  This character is used to&#xA;     * separate filenames in a sequence of files given as a &lt;em>path list&lt;/em>.&#xA;     * On UNIX systems, this character is &lt;code>':'&lt;/code>; on Microsoft Windows systems it&#xA;     * is &lt;code>';'&lt;/code>.&#xA;     *&#xA;     * @see     java.lang.System#getProperty(java.lang.String)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="pathSeparator">
      <initialValue xsi:type="expressions:AdditiveExpression">
        <children xsi:type="references:StringReference" value=""/>
        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        <additiveOperators xsi:type="operators:Addition"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The system-dependent path-separator character, represented as a string&#xA;     * for convenience.  This string contains a single character, namely&#xA;     * &lt;code>{@link #pathSeparatorChar}&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="File">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.1"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pathname">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefixLength">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/* -- Constructors -- */</comments>
        <comments>/**&#xA;     * Internal constructor for already-normalized pathname strings.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="File">
      <statements xsi:type="statements:Assert">
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </children>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Assert">
        <condition xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                  <arguments xsi:type="references:StringReference" value=""/>
                </next>
              </next>
            </child>
          </expression>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.12"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="child">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parent">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Internal constructor for already-normalized pathname strings.&#xA;     * The parameter order is used to disambiguate this method from the&#xA;     * public(File, String) constructor.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="File">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.10"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pathname">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new &lt;code>File&lt;/code> instance by converting the given&#xA;     * pathname string into an abstract pathname.  If the given string is&#xA;     * the empty string, then the result is the empty abstract pathname.&#xA;     *&#xA;     * @param   pathname  A pathname string&#xA;     * @throws  NullPointerException&#xA;     *          If the &lt;code>pathname&lt;/code> argument is &lt;code>null&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="File">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:SelfReference">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <self xsi:type="literals:This"/>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.12"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.13"/>
                        </next>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.10"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
                        </next>
                      </arguments>
                    </next>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                <arguments xsi:type="references:StringReference" value=""/>
              </next>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:SelfReference">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <self xsi:type="literals:This"/>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.12"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.10"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
                        </next>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.10"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
                        </next>
                      </arguments>
                    </next>
                  </value>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.10"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
                </next>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parent">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="child">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* Note: The two-argument File constructors do not interpret an empty&#xA;       parent abstract pathname as the current user directory.  An empty parent&#xA;       instead causes the child to be resolved against the system-dependent&#xA;       directory defined by the FileSystem.getDefaultParent method.  On Unix&#xA;       this default is &quot;/&quot;, while on Microsoft Windows it is &quot;\\&quot;.  This is required for&#xA;       compatibility with the original behavior of this class. */</comments>
        <comments>/**&#xA;     * Creates a new &lt;code>File&lt;/code> instance from a parent pathname string&#xA;     * and a child pathname string.&#xA;     *&#xA;     * &lt;p> If &lt;code>parent&lt;/code> is &lt;code>null&lt;/code> then the new&#xA;     * &lt;code>File&lt;/code> instance is created as if by invoking the&#xA;     * single-argument &lt;code>File&lt;/code> constructor on the given&#xA;     * &lt;code>child&lt;/code> pathname string.&#xA;     *&#xA;     * &lt;p> Otherwise the &lt;code>parent&lt;/code> pathname string is taken to denote&#xA;     * a directory, and the &lt;code>child&lt;/code> pathname string is taken to&#xA;     * denote either a directory or a file.  If the &lt;code>child&lt;/code> pathname&#xA;     * string is absolute then it is converted into a relative pathname in a&#xA;     * system-dependent way.  If &lt;code>parent&lt;/code> is the empty string then&#xA;     * the new &lt;code>File&lt;/code> instance is created by converting&#xA;     * &lt;code>child&lt;/code> into an abstract pathname and resolving the result&#xA;     * against a system-dependent default directory.  Otherwise each pathname&#xA;     * string is converted into an abstract pathname and the child abstract&#xA;     * pathname is resolved against the parent.&#xA;     *&#xA;     * @param   parent  The parent pathname string&#xA;     * @param   child   The child pathname string&#xA;     * @throws  NullPointerException&#xA;     *          If &lt;code>child&lt;/code> is &lt;code>null&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="File">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:SelfReference">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <self xsi:type="literals:This"/>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.12"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.13"/>
                        </next>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.10"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
                        </next>
                      </arguments>
                    </next>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
                  <arguments xsi:type="references:StringReference" value=""/>
                </next>
              </next>
            </condition>
            <elseStatement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:SelfReference">
                    <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <self xsi:type="literals:This"/>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.12"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0">
                        <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                      </arguments>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                        <next xsi:type="references:MethodCall">
                          <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.10"/>
                          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
                        </next>
                      </arguments>
                    </next>
                  </value>
                </expression>
              </statements>
            </elseStatement>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.10"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
                </next>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parent">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="child">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new &lt;code>File&lt;/code> instance from a parent abstract&#xA;     * pathname and a child pathname string.&#xA;     *&#xA;     * &lt;p> If &lt;code>parent&lt;/code> is &lt;code>null&lt;/code> then the new&#xA;     * &lt;code>File&lt;/code> instance is created as if by invoking the&#xA;     * single-argument &lt;code>File&lt;/code> constructor on the given&#xA;     * &lt;code>child&lt;/code> pathname string.&#xA;     *&#xA;     * &lt;p> Otherwise the &lt;code>parent&lt;/code> abstract pathname is taken to&#xA;     * denote a directory, and the &lt;code>child&lt;/code> pathname string is taken&#xA;     * to denote either a directory or a file.  If the &lt;code>child&lt;/code>&#xA;     * pathname string is absolute then it is converted into a relative&#xA;     * pathname in a system-dependent way.  If &lt;code>parent&lt;/code> is the empty&#xA;     * abstract pathname then the new &lt;code>File&lt;/code> instance is created by&#xA;     * converting &lt;code>child&lt;/code> into an abstract pathname and resolving&#xA;     * the result against a system-dependent default directory.  Otherwise each&#xA;     * pathname string is converted into an abstract pathname and the child&#xA;     * abstract pathname is resolved against the parent.&#xA;     *&#xA;     * @param   parent  The parent abstract pathname&#xA;     * @param   child   The child pathname string&#xA;     * @throws  NullPointerException&#xA;     *          If &lt;code>child&lt;/code> is &lt;code>null&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="File">
      <statements xsi:type="statements:Condition">
        <comments>// Check our many preconditions</comments>
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="URI is not absolute"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../net/URI.class.xmi#//@classifiers.0/@members.78"/>
            </next>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="URI is not hierarchical"/>
          </throwable>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../net/URI.class.xmi#//@classifiers.0/@members.79"/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="scheme">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../net/URI.class.xmi#//@classifiers.0/@members.77"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="URI scheme is not &quot;file&quot;"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.2/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.2/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.36"/>
                <arguments xsi:type="references:StringReference" value="file"/>
              </next>
            </child>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="URI has an authority component"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../net/URI.class.xmi#//@classifiers.0/@members.83"/>
            </next>
          </children>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="URI has a fragment component"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../net/URI.class.xmi#//@classifiers.0/@members.93"/>
            </next>
          </children>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="URI has a query component"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../net/URI.class.xmi#//@classifiers.0/@members.91"/>
            </next>
          </children>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../net/URI.class.xmi#//@classifiers.0/@members.89"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="URI path component is empty"/>
          </throwable>
        </statement>
        <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.7/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.33"/>
            <arguments xsi:type="references:StringReference" value=""/>
          </next>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.7/@variable">
            <comments>// Okay, now initialize</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.14"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.7/@variable"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.7/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.7/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.59"/>
                <arguments xsi:type="literals:CharacterLiteral" value="47"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                </arguments>
              </next>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
          <children xsi:type="literals:CharacterLiteral" value="47"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.10"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.7/@variable"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="uri">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../net/URI.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new &lt;tt>File&lt;/tt> instance by converting the given&#xA;     * &lt;tt>file:&lt;/tt> URI into an abstract pathname.&#xA;     *&#xA;     * &lt;p> The exact form of a &lt;tt>file:&lt;/tt> URI is system-dependent, hence&#xA;     * the transformation performed by this constructor is also&#xA;     * system-dependent.&#xA;     *&#xA;     * &lt;p> For a given abstract pathname &lt;i>f&lt;/i> it is guaranteed that&#xA;     *&#xA;     * &lt;blockquote>&lt;tt>&#xA;     * new File(&lt;/tt>&lt;i>&amp;nbsp;f&lt;/i>&lt;tt>.{@link #toURI() toURI}()).equals(&lt;/tt>&lt;i>&amp;nbsp;f&lt;/i>&lt;tt>.{@link #getAbsoluteFile() getAbsoluteFile}())&#xA;     * &lt;/tt>&lt;/blockquote>&#xA;     *&#xA;     * so long as the original abstract pathname, the URI, and the new abstract&#xA;     * pathname are all created in (possibly different invocations of) the same&#xA;     * Java virtual machine.  This relationship typically does not hold,&#xA;     * however, when a &lt;tt>file:&lt;/tt> URI that is created in a virtual machine&#xA;     * on one operating system is converted into an abstract pathname in a&#xA;     * virtual machine on a different operating system.&#xA;     *&#xA;     * @param  uri&#xA;     *         An absolute, hierarchical URI with a scheme equal to&#xA;     *         &lt;tt>&quot;file&quot;&lt;/tt>, a non-empty path component, and undefined&#xA;     *         authority, query, and fragment components&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If &lt;tt>uri&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the preconditions on the parameter do not hold&#xA;     *&#xA;     * @see #toURI()&#xA;     * @see java.net.URI&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* -- Path-component accessors -- */</comments>
        <comments>/**&#xA;     * Returns the name of the file or directory denoted by this abstract&#xA;     * pathname.  This is just the last name in the pathname's name&#xA;     * sequence.  If the pathname's name sequence is empty, then the empty&#xA;     * string is returned.&#xA;     *&#xA;     * @return  The name of the file or directory denoted by this abstract&#xA;     *          pathname, or the empty string if this pathname's name sequence&#xA;     *          is empty&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="index">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.47"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.55"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            </next>
          </returnValue>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.55"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getParent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the pathname string of this abstract pathname's parent, or&#xA;     * &lt;code>null&lt;/code> if this pathname does not name a parent directory.&#xA;     *&#xA;     * &lt;p> The &lt;em>parent&lt;/em> of an abstract pathname consists of the&#xA;     * pathname's prefix, if any, and each name in the pathname's name&#xA;     * sequence except for the last.  If the name sequence is empty then&#xA;     * the pathname does not name a parent directory.&#xA;     *&#xA;     * @return  The pathname string of the parent directory named by this&#xA;     *          abstract pathname, or &lt;code>null&lt;/code> if this pathname&#xA;     *          does not name a parent&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="index">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.47"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return">
              <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.56"/>
                  <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                </next>
              </returnValue>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
                    </next>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  <relationOperators xsi:type="operators:GreaterThan"/>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:NullLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.56"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.0/@variable"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getParentFile">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the abstract pathname of this abstract pathname's parent,&#xA;     * or &lt;code>null&lt;/code> if this pathname does not name a parent&#xA;     * directory.&#xA;     *&#xA;     * &lt;p> The &lt;em>parent&lt;/em> of an abstract pathname consists of the&#xA;     * pathname's prefix, if any, and each name in the pathname's name&#xA;     * sequence except for the last.  If the name sequence is empty then&#xA;     * the pathname does not name a parent directory.&#xA;     *&#xA;     * @return  The abstract pathname of the parent directory named by this&#xA;     *          abstract pathname, or &lt;code>null&lt;/code> if this pathname&#xA;     *          does not name a parent&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.15"/>
            <self xsi:type="literals:This"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:NullLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.0/@variable"/>
          <arguments xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this abstract pathname into a pathname string.  The resulting&#xA;     * string uses the {@link #separator default name-separator character} to&#xA;     * separate the names in the name sequence.&#xA;     *&#xA;     * @return  The string form of this abstract pathname&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isAbsolute">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* -- Path operations -- */</comments>
        <comments>/**&#xA;     * Tests whether this abstract pathname is absolute.  The definition of&#xA;     * absolute pathname is system dependent.  On UNIX systems, a pathname is&#xA;     * absolute if its prefix is &lt;code>&quot;/&quot;&lt;/code>.  On Microsoft Windows systems, a&#xA;     * pathname is absolute if its prefix is a drive specifier followed by&#xA;     * &lt;code>&quot;\\&quot;&lt;/code>, or if its prefix is &lt;code>&quot;\\\\&quot;&lt;/code>.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if this abstract pathname is absolute,&#xA;     *          &lt;code>false&lt;/code> otherwise&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.15"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAbsolutePath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the absolute pathname string of this abstract pathname.&#xA;     *&#xA;     * &lt;p> If this abstract pathname is already absolute, then the pathname&#xA;     * string is simply returned as if by the &lt;code>{@link #getPath}&lt;/code>&#xA;     * method.  If this abstract pathname is the empty abstract pathname then&#xA;     * the pathname string of the current user directory, which is named by the&#xA;     * system property &lt;code>user.dir&lt;/code>, is returned.  Otherwise this&#xA;     * pathname is resolved in a system-dependent way.  On UNIX systems, a&#xA;     * relative pathname is made absolute by resolving it against the current&#xA;     * user directory.  On Microsoft Windows systems, a relative pathname is made absolute&#xA;     * by resolving it against the current directory of the drive named by the&#xA;     * pathname, if any; if not, it is resolved against the current user&#xA;     * directory.&#xA;     *&#xA;     * @return  The absolute pathname string denoting the same file or&#xA;     *          directory as this abstract pathname&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a required system property value cannot be accessed.&#xA;     *&#xA;     * @see     java.io.File#isAbsolute()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.16"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAbsoluteFile">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the absolute form of this abstract pathname.  Equivalent to&#xA;     * &lt;code>new&amp;nbsp;File(this.{@link #getAbsolutePath}())&lt;/code>.&#xA;     *&#xA;     * @return  The absolute abstract pathname denoting the same file or&#xA;     *          directory as this abstract pathname&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a required system property value cannot be accessed.&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="absPath">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.19"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.0/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.0/@variable"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCanonicalPath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the canonical pathname string of this abstract pathname.&#xA;     *&#xA;     * &lt;p> A canonical pathname is both absolute and unique.  The precise&#xA;     * definition of canonical form is system-dependent.  This method first&#xA;     * converts this pathname to absolute form if necessary, as if by invoking the&#xA;     * {@link #getAbsolutePath} method, and then maps it to its unique form in a&#xA;     * system-dependent way.  This typically involves removing redundant names&#xA;     * such as &lt;tt>&quot;.&quot;&lt;/tt> and &lt;tt>&quot;..&quot;&lt;/tt> from the pathname, resolving&#xA;     * symbolic links (on UNIX platforms), and converting drive letters to a&#xA;     * standard case (on Microsoft Windows platforms).&#xA;     *&#xA;     * &lt;p> Every pathname that denotes an existing file or directory has a&#xA;     * unique canonical form.  Every pathname that denotes a nonexistent file&#xA;     * or directory also has a unique canonical form.  The canonical form of&#xA;     * the pathname of a nonexistent file or directory may be different from&#xA;     * the canonical form of the same pathname after the file or directory is&#xA;     * created.  Similarly, the canonical form of the pathname of an existing&#xA;     * file or directory may be different from the canonical form of the same&#xA;     * pathname after the file or directory is deleted.&#xA;     *&#xA;     * @return  The canonical pathname string denoting the same file or&#xA;     *          directory as this abstract pathname&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If an I/O error occurs, which is possible because the&#xA;     *          construction of the canonical pathname may require&#xA;     *          filesystem queries&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a required system property value cannot be accessed, or&#xA;     *          if a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead}&lt;/code> method denies&#xA;     *          read access to the file&#xA;     *&#xA;     * @since   JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.17"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.16"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
              </next>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCanonicalFile">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the canonical form of this abstract pathname.  Equivalent to&#xA;     * &lt;code>new&amp;nbsp;File(this.{@link #getCanonicalPath}())&lt;/code>.&#xA;     *&#xA;     * @return  The canonical pathname string denoting the same file or&#xA;     *          directory as this abstract pathname&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If an I/O error occurs, which is possible because the&#xA;     *          construction of the canonical pathname may require&#xA;     *          filesystem queries&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a required system property value cannot be accessed, or&#xA;     *          if a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead}&lt;/code> method denies&#xA;     *          read access to the file&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="canonPath">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.21"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@variable"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="slashify">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="path">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="isDirectory">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.59"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                </arguments>
                <arguments xsi:type="literals:CharacterLiteral" value="47"/>
              </next>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          </children>
          <children xsi:type="literals:CharacterLiteral" value="47"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:StringReference" value="/"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.42"/>
              <arguments xsi:type="references:StringReference" value="/"/>
            </next>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
              <children xsi:type="references:StringReference" value="/"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.43"/>
                <arguments xsi:type="references:StringReference" value="/"/>
              </next>
            </child>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toURL">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../net/URL.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../net/MalformedURLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Converts this abstract pathname into a &lt;code>file:&lt;/code> URL.  The&#xA;     * exact form of the URL is system-dependent.  If it can be determined that&#xA;     * the file denoted by this abstract pathname is a directory, then the&#xA;     * resulting URL will end with a slash.&#xA;     *&#xA;     * &lt;p> &lt;b>Usage note:&lt;/b> This method does not automatically escape&#xA;     * characters that are illegal in URLs.  It is recommended that new code&#xA;     * convert an abstract pathname into a URL by first converting it into a&#xA;     * URI, via the {@link #toURI() toURI} method, and then converting the URI&#xA;     * into a URL via the {@link java.net.URI#toURL() URI.toURL} method.&#xA;     *&#xA;     * @return  A URL object representing the equivalent file URL&#xA;     *&#xA;     * @throws  MalformedURLException&#xA;     *          If the path cannot be parsed as a URL&#xA;     *&#xA;     * @see     #toURI()&#xA;     * @see     java.net.URI&#xA;     * @see     java.net.URI#toURL()&#xA;     * @see     java.net.URL&#xA;     * @since   1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../net/URL.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="file"/>
          <arguments xsi:type="references:StringReference" value=""/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.29"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toURI">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../net/URI.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Constructs a &lt;tt>file:&lt;/tt> URI that represents this abstract pathname.&#xA;     *&#xA;     * &lt;p> The exact form of the URI is system-dependent.  If it can be&#xA;     * determined that the file denoted by this abstract pathname is a&#xA;     * directory, then the resulting URI will end with a slash.&#xA;     *&#xA;     * &lt;p> For a given abstract pathname &lt;i>f&lt;/i>, it is guaranteed that&#xA;     *&#xA;     * &lt;blockquote>&lt;tt>&#xA;     * new {@link #File(java.net.URI) File}(&lt;/tt>&lt;i>&amp;nbsp;f&lt;/i>&lt;tt>.toURI()).equals(&lt;/tt>&lt;i>&amp;nbsp;f&lt;/i>&lt;tt>.{@link #getAbsoluteFile() getAbsoluteFile}())&#xA;     * &lt;/tt>&lt;/blockquote>&#xA;     *&#xA;     * so long as the original abstract pathname, the URI, and the new abstract&#xA;     * pathname are all created in (possibly different invocations of) the same&#xA;     * Java virtual machine.  Due to the system-dependent nature of abstract&#xA;     * pathnames, however, this relationship typically does not hold when a&#xA;     * &lt;tt>file:&lt;/tt> URI that is created in a virtual machine on one operating&#xA;     * system is converted into an abstract pathname in a virtual machine on a&#xA;     * different operating system.&#xA;     *&#xA;     * @return  An absolute, hierarchical URI with a scheme equal to&#xA;     *          &lt;tt>&quot;file&quot;&lt;/tt>, a path representing this abstract pathname,&#xA;     *          and undefined authority, query, and fragment components&#xA;     *&#xA;     * @see #File(java.net.URI)&#xA;     * @see java.net.URI&#xA;     * @see java.net.URI#toURL()&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="f">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.20"/>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="sp">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statements.0/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.17"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statements.0/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.29"/>
              </arguments>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statements.1/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="//"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statements.1/@variable"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </value>
            </expression>
          </statement>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.42"/>
              <arguments xsi:type="references:StringReference" value="//"/>
            </next>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../net/URI.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="file"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@statements.1/@variable"/>
            <arguments xsi:type="literals:NullLiteral"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <comments>// Can't happen</comments>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/Error.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@catcheBlocks.0/@parameter"/>
            </throwable>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../net/URISyntaxException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canRead">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* -- Attribute accessors -- */</comments>
        <comments>/**&#xA;     * Tests whether the application can read the file denoted by this&#xA;     * abstract pathname.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if and only if the file specified by this&#xA;     *          abstract pathname exists &lt;em>and&lt;/em> can be read by the&#xA;     *          application; &lt;code>false&lt;/code> otherwise&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the file&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="literals:BooleanLiteral"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="canWrite">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests whether the application can modify the file denoted by this&#xA;     * abstract pathname.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if and only if the file system actually&#xA;     *          contains a file denoted by this abstract pathname &lt;em>and&lt;/em>&#xA;     *          the application is allowed to write to the file;&#xA;     *          &lt;code>false&lt;/code> otherwise.&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code>&#xA;     *          method denies write access to the file&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.35"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="literals:BooleanLiteral" value="true"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="exists">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests whether the file or directory denoted by this abstract pathname&#xA;     * exists.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if and only if the file or directory denoted&#xA;     *          by this abstract pathname exists; &lt;code>false&lt;/code> otherwise&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the file or directory&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.18"/>
                    <arguments xsi:type="references:SelfReference">
                      <self xsi:type="literals:This"/>
                    </arguments>
                  </next>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="FileSystem.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="FileSystem.class.xmi#//@classifiers.0"/>
                </children>
              </expression>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isDirectory">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests whether the file denoted by this abstract pathname is a&#xA;     * directory.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if and only if the file denoted by this&#xA;     *          abstract pathname exists &lt;em>and&lt;/em> is a directory;&#xA;     *          &lt;code>false&lt;/code> otherwise&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the file&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.18"/>
                    <arguments xsi:type="references:SelfReference">
                      <self xsi:type="literals:This"/>
                    </arguments>
                  </next>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="FileSystem.class.xmi#//@classifiers.0/@members.2"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="FileSystem.class.xmi#//@classifiers.0"/>
                </children>
              </expression>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isFile">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests whether the file denoted by this abstract pathname is a normal&#xA;     * file.  A file is &lt;em>normal&lt;/em> if it is not a directory and, in&#xA;     * addition, satisfies other system-dependent criteria.  Any non-directory&#xA;     * file created by a Java application is guaranteed to be a normal file.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if and only if the file denoted by this&#xA;     *          abstract pathname exists &lt;em>and&lt;/em> is a normal file;&#xA;     *          &lt;code>false&lt;/code> otherwise&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the file&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.18"/>
                    <arguments xsi:type="references:SelfReference">
                      <self xsi:type="literals:This"/>
                    </arguments>
                  </next>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="FileSystem.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="FileSystem.class.xmi#//@classifiers.0"/>
                </children>
              </expression>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isHidden">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests whether the file named by this abstract pathname is a hidden&#xA;     * file.  The exact definition of &lt;em>hidden&lt;/em> is system-dependent.  On&#xA;     * UNIX systems, a file is considered to be hidden if its name begins with&#xA;     * a period character (&lt;code>'.'&lt;/code>).  On Microsoft Windows systems, a file is&#xA;     * considered to be hidden if it has been marked as such in the filesystem.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if and only if the file denoted by this&#xA;     *          abstract pathname is hidden according to the conventions of the&#xA;     *          underlying platform&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the file&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AndExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.18"/>
                    <arguments xsi:type="references:SelfReference">
                      <self xsi:type="literals:This"/>
                    </arguments>
                  </next>
                </children>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="FileSystem.class.xmi#//@classifiers.0/@members.3"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="FileSystem.class.xmi#//@classifiers.0"/>
                </children>
              </expression>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="lastModified">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the time that the file denoted by this abstract pathname was&#xA;     * last modified.&#xA;     *&#xA;     * @return  A &lt;code>long&lt;/code> value representing the time the file was&#xA;     *          last modified, measured in milliseconds since the epoch&#xA;     *          (00:00:00 GMT, January 1, 1970), or &lt;code>0L&lt;/code> if the&#xA;     *          file does not exist or if an I/O error occurs&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the file&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="length">
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the length of the file denoted by this abstract pathname.&#xA;     * The return value is unspecified if this pathname denotes a directory.&#xA;     *&#xA;     * @return  The length, in bytes, of the file denoted by this abstract&#xA;     *          pathname, or &lt;code>0L&lt;/code> if the file does not exist&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the file&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.21"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createNewFile">
      <typeReference xsi:type="types:Boolean"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* -- File operations -- */</comments>
        <comments>/**&#xA;     * Atomically creates a new, empty file named by this abstract pathname if&#xA;     * and only if a file with this name does not yet exist.  The check for the&#xA;     * existence of the file and the creation of the file if it does not exist&#xA;     * are a single operation that is atomic with respect to all other&#xA;     * filesystem activities that might affect the file.&#xA;     * &lt;P>&#xA;     * Note: this method should &lt;i>not&lt;/i> be used for file-locking, as&#xA;     * the resulting protocol cannot be made to work reliably. The &#xA;     * {@link java.nio.channels.FileLock FileLock}&#xA;     * facility should be used instead. &#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if the named file does not exist and was&#xA;     *          successfully created; &lt;code>false&lt;/code> if the named file&#xA;     *          already exists&#xA;     *&#xA;     * @throws  IOException&#xA;     *          If an I/O error occurred&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code>&#xA;     *          method denies write access to the file&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.35"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            </next>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.22"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="delete">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Deletes the file or directory denoted by this abstract pathname.  If&#xA;     * this pathname denotes a directory, then the directory must be empty in&#xA;     * order to be deleted.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if and only if the file or directory is&#xA;     *          successfully deleted; &lt;code>false&lt;/code> otherwise&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkDelete}&lt;/code> method denies&#xA;     *          delete access to the file&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.36"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.23"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="deleteOnExit">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Requests that the file or directory denoted by this abstract &#xA;     * pathname be deleted when the virtual machine terminates.  &#xA;     * Deletion will be attempted only for normal termination of the &#xA;     * virtual machine, as defined by the Java Language Specification. &#xA;     *&#xA;     * &lt;p> Once deletion has been requested, it is not possible to cancel the&#xA;     * request.  This method should therefore be used with care.&#xA;     *&#xA;     * &lt;P>&#xA;     * Note: this method should &lt;i>not&lt;/i> be used for file-locking, as &#xA;     * the resulting protocol cannot be made to work reliably. The &#xA;     * {@link java.nio.channels.FileLock FileLock}&#xA;     * facility should be used instead.&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkDelete}&lt;/code> method denies&#xA;     *          delete access to the file&#xA;     *&#xA;     * @see #delete&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.36"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.24"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="list">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an array of strings naming the files and directories in the&#xA;     * directory denoted by this abstract pathname.&#xA;     *&#xA;     * &lt;p> If this abstract pathname does not denote a directory, then this&#xA;     * method returns &lt;code>null&lt;/code>.  Otherwise an array of strings is&#xA;     * returned, one for each file or directory in the directory.  Names&#xA;     * denoting the directory itself and the directory's parent directory are&#xA;     * not included in the result.  Each string is a file name rather than a&#xA;     * complete path.&#xA;     *&#xA;     * &lt;p> There is no guarantee that the name strings in the resulting array&#xA;     * will appear in any specific order; they are not, in particular,&#xA;     * guaranteed to appear in alphabetical order.&#xA;     *&#xA;     * @return  An array of strings naming the files and directories in the&#xA;     *          directory denoted by this abstract pathname.  The array will be&#xA;     *          empty if the directory is empty.  Returns &lt;code>null&lt;/code> if&#xA;     *          this abstract pathname does not denote a directory, or if an&#xA;     *          I/O error occurs.&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the directory&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.25"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="list">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filter">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="FilenameFilter.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an array of strings naming the files and directories in the&#xA;     * directory denoted by this abstract pathname that satisfy the specified&#xA;     * filter.  The behavior of this method is the same as that of the&#xA;     * &lt;code>{@link #list()}&lt;/code> method, except that the strings in the&#xA;     * returned array must satisfy the filter.  If the given&#xA;     * &lt;code>filter&lt;/code> is &lt;code>null&lt;/code> then all names are accepted.&#xA;     * Otherwise, a name satisfies the filter if and only if the value&#xA;     * &lt;code>true&lt;/code> results when the &lt;code>{@link&#xA;     * FilenameFilter#accept}&lt;/code> method of the filter is invoked on this&#xA;     * abstract pathname and the name of a file or directory in the directory&#xA;     * that it denotes.&#xA;     *&#xA;     * @param  filter  A filename filter&#xA;     *&#xA;     * @return  An array of strings naming the files and directories in the&#xA;     *          directory denoted by this abstract pathname that were accepted&#xA;     *          by the given &lt;code>filter&lt;/code>.  The array will be empty if&#xA;     *          the directory is empty or if no names were accepted by the&#xA;     *          filter.  Returns &lt;code>null&lt;/code> if this abstract pathname&#xA;     *          does not denote a directory, or if an I/O error occurs.&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the directory&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="names">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.37"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/ArrayList.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../util/ArrayList.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.2/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../util/ArrayList.class.xmi#//@classifiers.0/@members.18"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.3/@init"/>
                      </arraySelectors>
                    </arguments>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="FilenameFilter.class.xmi#//@classifiers.0/@members.0"/>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.3/@init"/>
                  </arraySelectors>
                </arguments>
              </next>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@statements.2/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/ArrayList.class.xmi#//@classifiers.0/@members.15"/>
                <arguments xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arguments>
              </next>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="listFiles">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an array of abstract pathnames denoting the files in the&#xA;     * directory denoted by this abstract pathname.&#xA;     *&#xA;     * &lt;p> If this abstract pathname does not denote a directory, then this&#xA;     * method returns &lt;code>null&lt;/code>.  Otherwise an array of&#xA;     * &lt;code>File&lt;/code> objects is returned, one for each file or directory in&#xA;     * the directory.  Pathnames denoting the directory itself and the&#xA;     * directory's parent directory are not included in the result.  Each&#xA;     * resulting abstract pathname is constructed from this abstract pathname&#xA;     * using the &lt;code>{@link #File(java.io.File, java.lang.String)&#xA;     * File(File,&amp;nbsp;String)}&lt;/code> constructor.  Therefore if this pathname&#xA;     * is absolute then each resulting pathname is absolute; if this pathname&#xA;     * is relative then each resulting pathname will be relative to the same&#xA;     * directory.&#xA;     *&#xA;     * &lt;p> There is no guarantee that the name strings in the resulting array&#xA;     * will appear in any specific order; they are not, in particular,&#xA;     * guaranteed to appear in alphabetical order.&#xA;     *&#xA;     * @return  An array of abstract pathnames denoting the files and&#xA;     *          directories in the directory denoted by this abstract&#xA;     *          pathname.  The array will be empty if the directory is&#xA;     *          empty.  Returns &lt;code>null&lt;/code> if this abstract pathname&#xA;     *          does not denote a directory, or if an I/O error occurs.&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the directory&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ss">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.37"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:NullLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="n">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="fs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.2/@variable"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.3/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.4/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.0/@variable">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.4/@init"/>
                  </arraySelectors>
                </arguments>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.4/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.2/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.4/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@statements.3/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="listFiles">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filter">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="FilenameFilter.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an array of abstract pathnames denoting the files and&#xA;     * directories in the directory denoted by this abstract pathname that&#xA;     * satisfy the specified filter.  The behavior of this method is the&#xA;     * same as that of the &lt;code>{@link #listFiles()}&lt;/code> method, except&#xA;     * that the pathnames in the returned array must satisfy the filter.&#xA;     * If the given &lt;code>filter&lt;/code> is &lt;code>null&lt;/code> then all&#xA;     * pathnames are accepted.  Otherwise, a pathname satisfies the filter&#xA;     * if and only if the value &lt;code>true&lt;/code> results when the&#xA;     * &lt;code>{@link FilenameFilter#accept}&lt;/code> method of the filter is&#xA;     * invoked on this abstract pathname and the name of a file or&#xA;     * directory in the directory that it denotes.&#xA;     *&#xA;     * @param  filter  A filename filter&#xA;     *&#xA;     * @return  An array of abstract pathnames denoting the files and&#xA;     *          directories in the directory denoted by this abstract&#xA;     *          pathname.  The array will be empty if the directory is&#xA;     *          empty.  Returns &lt;code>null&lt;/code> if this abstract pathname&#xA;     *          does not denote a directory, or if an I/O error occurs.&#xA;     *          &#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the directory&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ss">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.37"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:NullLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/ArrayList.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../util/ArrayList.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.2/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../util/ArrayList.class.xmi#//@classifiers.0/@members.18"/>
                    <arguments xsi:type="instantiations:NewConstructorCall">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <classifierReferences target="//@classifiers.0"/>
                      </typeReference>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@variable">
                        <arraySelectors>
                          <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.3/@init"/>
                        </arraySelectors>
                      </arguments>
                      <arguments xsi:type="references:SelfReference">
                        <self xsi:type="literals:This"/>
                      </arguments>
                    </arguments>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
                  <children xsi:type="literals:NullLiteral"/>
                </expression>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="FilenameFilter.class.xmi#//@classifiers.0/@members.0"/>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.3/@init"/>
                    </arraySelectors>
                  </arguments>
                </next>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsBefore/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@statements.2/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/ArrayList.class.xmi#//@classifiers.0/@members.15"/>
                <arguments xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0"/>
                  </typeReference>
                  <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arguments>
              </next>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="listFiles">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filter">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="FileFilter.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an array of abstract pathnames denoting the files and&#xA;     * directories in the directory denoted by this abstract pathname that&#xA;     * satisfy the specified filter.  The behavior of this method is the&#xA;     * same as that of the &lt;code>{@link #listFiles()}&lt;/code> method, except&#xA;     * that the pathnames in the returned array must satisfy the filter.&#xA;     * If the given &lt;code>filter&lt;/code> is &lt;code>null&lt;/code> then all&#xA;     * pathnames are accepted.  Otherwise, a pathname satisfies the filter&#xA;     * if and only if the value &lt;code>true&lt;/code> results when the&#xA;     * &lt;code>{@link FileFilter#accept(java.io.File)}&lt;/code> method of&#xA;     * the filter is invoked on the pathname.&#xA;     *&#xA;     * @param  filter  A file filter&#xA;     *&#xA;     * @return  An array of abstract pathnames denoting the files and&#xA;     *          directories in the directory denoted by this abstract&#xA;     *          pathname.  The array will be empty if the directory is&#xA;     *          empty.  Returns &lt;code>null&lt;/code> if this abstract pathname&#xA;     *          does not denote a directory, or if an I/O error occurs.&#xA;     *          &#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method denies read access to the directory&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ss">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsAfter/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.37"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:NullLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="v">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../util/ArrayList.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../util/ArrayList.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="f">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <initialValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.0/@variable">
                  <arraySelectors>
                    <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@init"/>
                  </arraySelectors>
                </arguments>
                <arguments xsi:type="references:SelfReference">
                  <self xsi:type="literals:This"/>
                </arguments>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.2/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../util/ArrayList.class.xmi#//@classifiers.0/@members.18"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@statement/@statements.0/@variable"/>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0"/>
                  <children xsi:type="literals:NullLiteral"/>
                </expression>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:InterfaceMethod" href="FileFilter.class.xmi#//@classifiers.0/@members.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@statement/@statements.0/@variable"/>
                </next>
              </children>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.0/@variable">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:CastExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arrayDimensionsBefore/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@statements.2/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/ArrayList.class.xmi#//@classifiers.0/@members.15"/>
                <arguments xsi:type="arrays:ArrayInstantiationBySize">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0"/>
                  </typeReference>
                  <sizes xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </arguments>
              </next>
            </expression>
          </child>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="mkdir">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates the directory named by this abstract pathname.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if and only if the directory was&#xA;     *          created; &lt;code>false&lt;/code> otherwise&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code>&#xA;     *          method does not permit the named directory to be created&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.35"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.26"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="mkdirs">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates the directory named by this abstract pathname, including any&#xA;     * necessary but nonexistent parent directories.  Note that if this&#xA;     * operation fails it may have succeeded in creating some of the necessary&#xA;     * parent directories.&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if and only if the directory was created,&#xA;     *          along with all necessary parent directories; &lt;code>false&lt;/code>&#xA;     *          otherwise&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code>&#xA;     *          method does not permit verification of the existence of the &#xA;     *          named directory and all necessary parent directories; or if&#xA;     *          the &lt;code>{@link &#xA;     *          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code>&#xA;     *          method does not permit the named directory and all necessary&#xA;     *          parent directories to be created&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.28"/>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
          </statements>
        </statement>
        <condition xsi:type="references:MethodCall" target="//@classifiers.0/@members.42"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="canonFile">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="literals:NullLiteral"/>
        </variable>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.2/@variable"/>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.22"/>
          </expression>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="parent">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.2/@variable">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.15"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.4/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0"/>
                </typeReference>
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.43"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.4/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.11"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.4/@variable"/>
                  </next>
                </arguments>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@statements.2/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.42"/>
              </children>
            </expression>
          </children>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="renameTo">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dest">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Renames the file denoted by this abstract pathname.&#xA;     * &#xA;     * &lt;p> Many aspects of the behavior of this method are inherently&#xA;     * platform-dependent: The rename operation might not be able to move a&#xA;     * file from one filesystem to another, it might not be atomic, and it&#xA;     * might not succeed if a file with the destination abstract pathname&#xA;     * already exists.  The return value should always be checked to make sure&#xA;     * that the rename operation was successful.&#xA;     *&#xA;     * @param  dest  The new abstract pathname for the named file&#xA;     * &#xA;     * @return  &lt;code>true&lt;/code> if and only if the renaming succeeded;&#xA;     *          &lt;code>false&lt;/code> otherwise&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code>&#xA;     *          method denies write access to either the old or new pathnames&#xA;     * &#xA;     * @throws  NullPointerException  &#xA;     *          If parameter &lt;code>dest&lt;/code> is &lt;code>null&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.35"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.35"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                </arguments>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.27"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setLastModified">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="time">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the last-modified time of the file or directory named by this&#xA;     * abstract pathname.&#xA;     *&#xA;     * &lt;p> All platforms support file-modification times to the nearest second,&#xA;     * but some provide more precision.  The argument will be truncated to fit&#xA;     * the supported precision.  If the operation succeeds and no intervening&#xA;     * operations on the file take place, then the next invocation of the&#xA;     * &lt;code>{@link #lastModified}&lt;/code> method will return the (possibly&#xA;     * truncated) &lt;code>time&lt;/code> argument that was passed to this method.&#xA;     *&#xA;     * @param  time  The new last-modified time, measured in milliseconds since&#xA;     *               the epoch (00:00:00 GMT, January 1, 1970)&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if and only if the operation succeeded;&#xA;     *          &lt;code>false&lt;/code> otherwise&#xA;     *&#xA;     * @throws  IllegalArgumentException  If the argument is negative&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code>&#xA;     *          method denies write access to the named file&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Negative time"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.35"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@statements.1/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.28"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setReadOnly">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Marks the file or directory named by this abstract pathname so that&#xA;     * only read operations are allowed.  After invoking this method the file&#xA;     * or directory is guaranteed not to change until it is either deleted or&#xA;     * marked to allow write access.  Whether or not a read-only file or&#xA;     * directory may be deleted depends upon the underlying system.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if and only if the operation succeeded;&#xA;     *          &lt;code>false&lt;/code> otherwise&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code>&#xA;     *          method denies write access to the named file&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="security">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.35"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.29"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="listRoots">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* -- Filesystem interface -- */</comments>
        <comments>/**&#xA;     * List the available filesystem roots.&#xA;     *&#xA;     * &lt;p> A particular Java platform may support zero or more&#xA;     * hierarchically-organized file systems.  Each file system has a&#xA;     * &lt;code>root&lt;/code> directory from which all other files in that file&#xA;     * system can be reached.  Windows platforms, for example, have a root&#xA;     * directory for each active drive; UNIX platforms have a single root&#xA;     * directory, namely &lt;code>&quot;/&quot;&lt;/code>.  The set of available filesystem&#xA;     * roots is affected by various system-level operations such as the insertion&#xA;     * or ejection of removable media and the disconnecting or unmounting of&#xA;     * physical or virtual disk drives.&#xA;     *&#xA;     * &lt;p> This method returns an array of &lt;code>File&lt;/code> objects that&#xA;     * denote the root directories of the available filesystem roots.  It is&#xA;     * guaranteed that the canonical pathname of any file physically present on&#xA;     * the local machine will begin with one of the roots returned by this&#xA;     * method.&#xA;     *&#xA;     * &lt;p> The canonical pathname of a file that resides on some other machine&#xA;     * and is accessed via a remote-filesystem protocol such as SMB or NFS may&#xA;     * or may not begin with one of the roots returned by this method.  If the&#xA;     * pathname of a remote file is syntactically indistinguishable from the&#xA;     * pathname of a local file then it will begin with one of the roots&#xA;     * returned by this method.  Thus, for example, &lt;code>File&lt;/code> objects&#xA;     * denoting the root directories of the mapped network drives of a Windows&#xA;     * platform will be returned by this method, while &lt;code>File&lt;/code>&#xA;     * objects containing UNC pathnames will not be returned by this method.&#xA;     *&#xA;     * &lt;p> Unlike most methods in this class, this method does not throw&#xA;     * security exceptions.  If a security manager exists and its &lt;code>{@link&#xA;     * java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code> method&#xA;     * denies read access to a particular root directory, then that directory&#xA;     * will not appear in the result.&#xA;     *&#xA;     * @return  An array of &lt;code>File&lt;/code> objects denoting the available&#xA;     *          filesystem roots, or &lt;code>null&lt;/code> if the set of roots&#xA;     *          could not be determined.  The array will be empty if there are&#xA;     *          no filesystem roots.&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.30"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="tmpFileLock">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/* -- Temporary files -- */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="counter">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      </initialValue>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="generateFile">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="suffix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dir">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/* Protected by tmpFileLock */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:AndExpression">
                <children xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../util/Random.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../util/Random.class.xmi#//@classifiers.0/@members.16"/>
                  </next>
                </children>
                <children xsi:type="literals:HexIntegerLiteral" hexValue="65535"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
          <children xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Subtraction"/>
            <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
          <operator xsi:type="operators:PlusPlus"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.2"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/Integer.class.xmi#//@classifiers.0/@members.15"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Integer.class.xmi#//@classifiers.0"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Field" name="tmpdir">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getTempDir">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/* Protected by tmpFileLock */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="a">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../sun/security/action/GetPropertyAction.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../sun/security/action/GetPropertyAction.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="java.io.tmpdir"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../security/AccessController.class.xmi#//@classifiers.0/@members.1"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@statements.0/@statement/@statements.0/@variable"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
                  </child>
                </expression>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.10"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkAndCreate">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="filename">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sm">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:TryBlock">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/SecurityManager.class.xmi#//@classifiers.0/@members.35"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0"/>
                </next>
              </expression>
            </statements>
            <catcheBlocks>
              <statements xsi:type="statements:Throw">
                <comments>/* Throwing the original AccessControlException could disclose&#xA;&#x9;&#x9;   the location of the default temporary directory, so we&#xA;&#x9;&#x9;   re-throw a more innocuous SecurityException */</comments>
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../lang/SecurityException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:StringReference" value="Unable to create temporary file"/>
                </throwable>
              </statements>
              <parameter name="x">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../security/AccessControlException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </parameter>
            </catcheBlocks>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.22"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createTempFile">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="suffix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="directory">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;p> Creates a new empty file in the specified directory, using the&#xA;     * given prefix and suffix strings to generate its name.  If this method&#xA;     * returns successfully then it is guaranteed that:&#xA;     *&#xA;     * &lt;ol>&#xA;     * &lt;li> The file denoted by the returned abstract pathname did not exist&#xA;     *      before this method was invoked, and&#xA;     * &lt;li> Neither this method nor any of its variants will return the same&#xA;     *      abstract pathname again in the current invocation of the virtual&#xA;     *      machine.&#xA;     * &lt;/ol>&#xA;     *&#xA;     * This method provides only part of a temporary-file facility.  To arrange&#xA;     * for a file created by this method to be deleted automatically, use the&#xA;     * &lt;code>{@link #deleteOnExit}&lt;/code> method.&#xA;     *&#xA;     * &lt;p> The &lt;code>prefix&lt;/code> argument must be at least three characters&#xA;     * long.  It is recommended that the prefix be a short, meaningful string&#xA;     * such as &lt;code>&quot;hjb&quot;&lt;/code> or &lt;code>&quot;mail&quot;&lt;/code>.  The&#xA;     * &lt;code>suffix&lt;/code> argument may be &lt;code>null&lt;/code>, in which case the&#xA;     * suffix &lt;code>&quot;.tmp&quot;&lt;/code> will be used.&#xA;     *&#xA;     * &lt;p> To create the new file, the prefix and the suffix may first be&#xA;     * adjusted to fit the limitations of the underlying platform.  If the&#xA;     * prefix is too long then it will be truncated, but its first three&#xA;     * characters will always be preserved.  If the suffix is too long then it&#xA;     * too will be truncated, but if it begins with a period character&#xA;     * (&lt;code>'.'&lt;/code>) then the period and the first three characters&#xA;     * following it will always be preserved.  Once these adjustments have been&#xA;     * made the name of the new file will be generated by concatenating the&#xA;     * prefix, five or more internally-generated characters, and the suffix.&#xA;     *&#xA;     * &lt;p> If the &lt;code>directory&lt;/code> argument is &lt;code>null&lt;/code> then the&#xA;     * system-dependent default temporary-file directory will be used.  The&#xA;     * default temporary-file directory is specified by the system property&#xA;     * &lt;code>java.io.tmpdir&lt;/code>.  On UNIX systems the default value of this&#xA;     * property is typically &lt;code>&quot;/tmp&quot;&lt;/code> or &lt;code>&quot;/var/tmp&quot;&lt;/code>; on&#xA;     * Microsoft Windows systems it is typically &lt;code>&quot;C:\\WINNT\\TEMP&quot;&lt;/code>.  A different&#xA;     * value may be given to this system property when the Java virtual machine&#xA;     * is invoked, but programmatic changes to this property are not guaranteed&#xA;     * to have any effect upon the temporary directory used by this method.&#xA;     *&#xA;     * @param  prefix     The prefix string to be used in generating the file's&#xA;     *                    name; must be at least three characters long&#xA;     *&#xA;     * @param  suffix     The suffix string to be used in generating the file's&#xA;     *                    name; may be &lt;code>null&lt;/code>, in which case the&#xA;     *                    suffix &lt;code>&quot;.tmp&quot;&lt;/code> will be used&#xA;     *&#xA;     * @param  directory  The directory in which the file is to be created, or&#xA;     *                    &lt;code>null&lt;/code> if the default temporary-file&#xA;     *                    directory is to be used&#xA;     *&#xA;     * @return  An abstract pathname denoting a newly-created empty file&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the &lt;code>prefix&lt;/code> argument contains fewer than three&#xA;     *          characters&#xA;     *&#xA;     * @throws  IOException  If a file could not be created&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code>&#xA;     *          method does not allow a file to be created&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Prefix string too short"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="s">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:ConditionalExpression">
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1"/>
                <children xsi:type="literals:NullLiteral"/>
              </expression>
            </child>
            <expressionIf xsi:type="references:StringReference" value=".tmp"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:LocalVariableStatement">
              <variable name="tmpDir">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.52"/>
              </variable>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.2"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0"/>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.3/@statements.0/@statement/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.11"/>
                      <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.3/@statements.0/@statement/@statements.0/@variable"/>
                    </next>
                  </arguments>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.2"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="sm">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/SecurityManager.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../lang/System.class.xmi#//@classifiers.0/@members.17"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/System.class.xmi#//@classifiers.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="f">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
          </variable>
        </statements>
        <statements xsi:type="statements:DoWhileLoop">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.3/@statements.2/@variable"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.50">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.2/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.2"/>
                </value>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.53">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.3/@statements.2/@variable">
                <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.17"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.3/@statements.1/@variable"/>
            </child>
          </condition>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@statements.3/@statements.2/@variable"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createTempFile">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="prefix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="suffix">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an empty file in the default temporary-file directory, using&#xA;     * the given prefix and suffix to generate its name.  Invoking this method&#xA;     * is equivalent to invoking &lt;code>{@link #createTempFile(java.lang.String,&#xA;     * java.lang.String, java.io.File)&#xA;     * createTempFile(prefix,&amp;nbsp;suffix,&amp;nbsp;null)}&lt;/code>.&#xA;     *&#xA;     * @param  prefix     The prefix string to be used in generating the file's&#xA;     *                    name; must be at least three characters long&#xA;     *&#xA;     * @param  suffix     The suffix string to be used in generating the file's&#xA;     *                    name; may be &lt;code>null&lt;/code>, in which case the&#xA;     *                    suffix &lt;code>&quot;.tmp&quot;&lt;/code> will be used&#xA;     *&#xA;     * @return  An abstract pathname denoting a newly-created empty file&#xA;     *&#xA;     * @throws  IllegalArgumentException&#xA;     *          If the &lt;code>prefix&lt;/code> argument contains fewer than three&#xA;     *          characters&#xA;     *&#xA;     * @throws  IOException  If a file could not be created&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager exists and its &lt;code>{@link&#xA;     *          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code>&#xA;     *          method does not allow a file to be created&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.54">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.1"/>
          <arguments xsi:type="literals:NullLiteral"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="compareTo">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pathname">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* -- Basic infrastructure -- */</comments>
        <comments>/**&#xA;     * Compares two abstract pathnames lexicographically.  The ordering&#xA;     * defined by this method depends upon the underlying system.  On UNIX&#xA;     * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows&#xA;     * systems it is not.&#xA;     *&#xA;     * @param   pathname  The abstract pathname to be compared to this abstract&#xA;     *                    pathname&#xA;     * &#xA;     * @return  Zero if the argument is equal to this abstract pathname, a&#xA;     *&#x9;&#x9;value less than zero if this abstract pathname is&#xA;     *&#x9;&#x9;lexicographically less than the argument, or a value greater&#xA;     *&#x9;&#x9;than zero if this abstract pathname is lexicographically&#xA;     *&#x9;&#x9;greater than the argument&#xA;     *&#xA;     * @since   1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.31"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests this abstract pathname for equality with the given object.&#xA;     * Returns &lt;code>true&lt;/code> if and only if the argument is not&#xA;     * &lt;code>null&lt;/code> and is an abstract pathname that denotes the same file&#xA;     * or directory as this abstract pathname.  Whether or not two abstract&#xA;     * pathnames are equal depends upon the underlying system.  On UNIX&#xA;     * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows&#xA;     * systems it is not.&#xA;     *&#xA;     * @param   obj   The object to be compared with this abstract pathname&#xA;     *&#xA;     * @return  &lt;code>true&lt;/code> if and only if the objects are the same;&#xA;     *          &lt;code>false&lt;/code> otherwise&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.56">
                <arguments xsi:type="expressions:CastExpression">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences target="//@classifiers.0"/>
                  </typeReference>
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
                </arguments>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Computes a hash code for this abstract pathname.  Because equality of&#xA;     * abstract pathnames is inherently system-dependent, so is the computation&#xA;     * of their hash codes.  On UNIX systems, the hash code of an abstract&#xA;     * pathname is equal to the exclusive &lt;em>or&lt;/em> of the hash code&#xA;     * of its pathname string and the decimal value&#xA;     * &lt;code>1234321&lt;/code>.  On Microsoft Windows systems, the hash&#xA;     * code is equal to the exclusive &lt;em>or&lt;/em> of the hash code of&#xA;     * its pathname string converted to lower case and the decimal&#xA;     * value &lt;code>1234321&lt;/code>.&#xA;     *&#xA;     * @return  A hash code for this abstract pathname&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.32"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the pathname string of this abstract pathname.  This is just the&#xA;     * string returned by the &lt;code>{@link #getPath}&lt;/code> method.&#xA;     *&#xA;     * @return  The string form of this abstract pathname&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.17"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="writeObject">
      <comments>// Add the separator character</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ObjectOutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * WriteObject is called to save this filename.&#xA;     * The separator character is saved also so it can be replaced&#xA;     * in case the path is reconstituted on a different host type.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ObjectOutputStream.class.xmi#//@classifiers.0/@members.17"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ObjectOutputStream.class.xmi#//@classifiers.0/@members.36"/>
            <arguments xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="readObject">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <namespaces>java</namespaces>
          <namespaces>io</namespaces>
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ObjectInputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/ClassNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * readObject is called to restore this filename.&#xA;     * The original separator character is read.  If it is different&#xA;     * than the separator character on this system, then the old separator&#xA;     * is replaced by the local separator.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Synchronized"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ObjectInputStream.class.xmi#//@classifiers.0/@members.19"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sep">
          <typeReference xsi:type="types:Char"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="ObjectInputStream.class.xmi#//@classifiers.0/@members.35"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// read the previous separator char</comments>
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="expressions:AssignmentExpression">
            <child xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <self xsi:type="literals:This"/>
            </child>
            <assignmentOperator xsi:type="operators:Assignment"/>
            <value xsi:type="references:SelfReference">
              <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.59"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                </next>
              </next>
              <self xsi:type="literals:This"/>
            </value>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@statements.1/@variable"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.10"/>
              <arguments xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="FileSystem.class.xmi#//@classifiers.0/@members.11"/>
              <arguments xsi:type="references:SelfReference">
                <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <self xsi:type="literals:This"/>
              </arguments>
            </next>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="301077366599181567"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** use serialVersionUID from JDK 1.0.2 for interoperability */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * An abstract representation of file and directory pathnames.&#xA; *&#xA; * &lt;p> User interfaces and operating systems use system-dependent &lt;em>pathname&#xA; * strings&lt;/em> to name files and directories.  This class presents an&#xA; * abstract, system-independent view of hierarchical pathnames.  An&#xA; * &lt;em>abstract pathname&lt;/em> has two components:&#xA; *&#xA; * &lt;ol>&#xA; * &lt;li> An optional system-dependent &lt;em>prefix&lt;/em> string,&#xA; *      such as a disk-drive specifier, &lt;code>&quot;/&quot;&lt;/code>&amp;nbsp;for the UNIX root&#xA; *      directory, or &lt;code>&quot;\\\\&quot;&lt;/code>&amp;nbsp;for a Microsoft Windows UNC pathname, and&#xA; * &lt;li> A sequence of zero or more string &lt;em>names&lt;/em>.&#xA; * &lt;/ol>&#xA; *&#xA; * Each name in an abstract pathname except for the last denotes a directory;&#xA; * the last name may denote either a directory or a file.  The &lt;em>empty&lt;/em>&#xA; * abstract pathname has no prefix and an empty name sequence.&#xA; *&#xA; * &lt;p> The conversion of a pathname string to or from an abstract pathname is&#xA; * inherently system-dependent.  When an abstract pathname is converted into a&#xA; * pathname string, each name is separated from the next by a single copy of&#xA; * the default &lt;em>separator character&lt;/em>.  The default name-separator&#xA; * character is defined by the system property &lt;code>file.separator&lt;/code>, and&#xA; * is made available in the public static fields &lt;code>{@link&#xA; * #separator}&lt;/code> and &lt;code>{@link #separatorChar}&lt;/code> of this class.&#xA; * When a pathname string is converted into an abstract pathname, the names&#xA; * within it may be separated by the default name-separator character or by any&#xA; * other name-separator character that is supported by the underlying system.&#xA; *&#xA; * &lt;p> A pathname, whether abstract or in string form, may be either&#xA; * &lt;em>absolute&lt;/em> or &lt;em>relative&lt;/em>.  An absolute pathname is complete in&#xA; * that no other information is required in order to locate the file that it&#xA; * denotes.  A relative pathname, in contrast, must be interpreted in terms of&#xA; * information taken from some other pathname.  By default the classes in the&#xA; * &lt;code>java.io&lt;/code> package always resolve relative pathnames against the&#xA; * current user directory.  This directory is named by the system property&#xA; * &lt;code>user.dir&lt;/code>, and is typically the directory in which the Java&#xA; * virtual machine was invoked.&#xA; *&#xA; * &lt;p> The prefix concept is used to handle root directories on UNIX platforms,&#xA; * and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms,&#xA; * as follows:&#xA; *&#xA; * &lt;ul>&#xA; *&#xA; * &lt;li> For UNIX platforms, the prefix of an absolute pathname is always&#xA; * &lt;code>&quot;/&quot;&lt;/code>.  Relative pathnames have no prefix.  The abstract pathname&#xA; * denoting the root directory has the prefix &lt;code>&quot;/&quot;&lt;/code> and an empty&#xA; * name sequence.&#xA; *&#xA; * &lt;li> For Microsoft Windows platforms, the prefix of a pathname that contains a drive&#xA; * specifier consists of the drive letter followed by &lt;code>&quot;:&quot;&lt;/code> and&#xA; * possibly followed by &lt;code>&quot;\\&quot;&lt;/code> if the pathname is absolute.  The&#xA; * prefix of a UNC pathname is &lt;code>&quot;\\\\&quot;&lt;/code>; the hostname and the share&#xA; * name are the first two names in the name sequence.  A relative pathname that&#xA; * does not specify a drive has no prefix.&#xA; *&#xA; * &lt;/ul>&#xA; *&#xA; * &lt;p> Instances of the &lt;code>File&lt;/code> class are immutable; that is, once&#xA; * created, the abstract pathname represented by a &lt;code>File&lt;/code> object&#xA; * will never change.&#xA; *&#xA; * @version 1.122, 05/05/04&#xA; * @author  unascribed&#xA; * @since   JDK1.0&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Serializable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <typeArguments xsi:type="generics:QualifiedTypeArgument">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
        </typeArguments>
        <target xsi:type="classifiers:Interface" href="../lang/Comparable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
