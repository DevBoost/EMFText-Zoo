<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="PrintStream.java">
  <comments>/*&#xA; * @(#)PrintStream.java&#x9;1.32 04/07/16&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>io</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Formatter.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="PrintStream">
    <members xsi:type="members:Field" name="autoFlush">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="trouble">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="formatter">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Formatter.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="textOut">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BufferedWriter.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Track both the text- and character-output streams, so that their buffers&#xA;     * can be flushed without flushing the entire stream.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="charOut">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Constructor" name="PrintStream">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          <arguments xsi:type="literals:BooleanLiteral"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a new print stream.  This stream will not flush automatically.&#xA;     *&#xA;     * @param  out        The output stream to which values and objects will be&#xA;     *                    printed&#xA;     *&#xA;     * @see java.io.PrintWriter#PrintWriter(java.io.OutputStream)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintStream">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.1"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Null output stream"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="autoFlush">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/* Initialization is factored into a private constructor (note the swapped&#xA;     * parameters so that this one isn't confused with the public one) and a&#xA;     * separate init method so that the following two public constructors can&#xA;     * share code.  We use a separate init method so that the constructor that&#xA;     * takes an encoding will throw an NPE for a null stream before it throws&#xA;     * an UnsupportedEncodingException for an unsupported encoding.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="init">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="osw">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferedWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          </value>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:Constructor" name="PrintStream">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </arguments>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="autoFlush">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a new print stream.&#xA;     *&#xA;     * @param  out        The output stream to which values and objects will be&#xA;     *                    printed&#xA;     * @param  autoFlush  A boolean; if true, the output buffer will be flushed&#xA;     *                    whenever a byte array is written, one of the&#xA;     *                    &lt;code>println&lt;/code> methods is invoked, or a newline&#xA;     *                    character or byte (&lt;code>'\n'&lt;/code>) is written&#xA;     *&#xA;     * @see java.io.PrintWriter#PrintWriter(java.io.OutputStream, boolean)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintStream">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.2"/>
          </arguments>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="autoFlush">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="encoding">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="UnsupportedEncodingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a new print stream.&#xA;     *&#xA;     * @param  out        The output stream to which values and objects will be&#xA;     *                    printed&#xA;     * @param  autoFlush  A boolean; if true, the output buffer will be flushed&#xA;     *                    whenever a byte array is written, one of the&#xA;     *                    &lt;code>println&lt;/code> methods is invoked, or a newline&#xA;     *                    character or byte (&lt;code>'\n'&lt;/code>) is written&#xA;     * @param  encoding   The name of a supported&#xA;     *                    &lt;a href=&quot;../lang/package-summary.html#charenc&quot;>&#xA;     *                    character encoding&lt;/a>&#xA;     *&#xA;     * @exception  UnsupportedEncodingException&#xA;     *             If the named encoding is not supported&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintStream">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="literals:BooleanLiteral"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="FileOutputStream.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </arguments>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fileName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new print stream, without automatic line flushing, with the&#xA;     * specified file name.  This convenience constructor creates&#xA;     * the necessary intermediate {@link java.io.OutputStreamWriter&#xA;     * OutputStreamWriter}, which will encode characters using the&#xA;     * {@linkplain java.nio.charset.Charset#defaultCharset default charset}&#xA;     * for this instance of the Java virtual machine.&#xA;     *&#xA;     * @param  fileName&#xA;     *         The name of the file to use as the destination of this print&#xA;     *         stream.  If the file exists, then it will be truncated to&#xA;     *         zero size; otherwise, a new file will be created.  The output&#xA;     *         will be written to the file and is buffered.&#xA;     *&#xA;     * @throws  FileNotFoundException&#xA;     *          If the given file object does not denote an existing, writable&#xA;     *          regular file and a new regular file of that name cannot be&#xA;     *          created, or if some other error occurs while opening or&#xA;     *          creating the file&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager is present and {@link&#xA;     *          SecurityManager#checkWrite checkWrite(fileName)} denies write&#xA;     *          access to the file&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintStream">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="literals:BooleanLiteral"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="FileOutputStream.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.1"/>
          </arguments>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fileName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csn">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="UnsupportedEncodingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new print stream, without automatic line flushing, with the&#xA;     * specified file name and charset.  This convenience constructor creates&#xA;     * the necessary intermediate {@link java.io.OutputStreamWriter&#xA;     * OutputStreamWriter}, which will encode characters using the provided&#xA;     * charset.&#xA;     *&#xA;     * @param  fileName&#xA;     *         The name of the file to use as the destination of this print&#xA;     *         stream.  If the file exists, then it will be truncated to&#xA;     *         zero size; otherwise, a new file will be created.  The output&#xA;     *         will be written to the file and is buffered.&#xA;     *&#xA;     * @param  csn&#xA;     *         The name of a supported {@linkplain java.nio.charset.Charset&#xA;     *         charset}&#xA;     *&#xA;     * @throws  FileNotFoundException&#xA;     *          If the given file object does not denote an existing, writable&#xA;     *          regular file and a new regular file of that name cannot be&#xA;     *          created, or if some other error occurs while opening or&#xA;     *          creating the file&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager is present and {@link&#xA;     *          SecurityManager#checkWrite checkWrite(fileName)} denies write&#xA;     *          access to the file&#xA;     *&#xA;     * @throws  UnsupportedEncodingException&#xA;     *          If the named charset is not supported&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintStream">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="literals:BooleanLiteral"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="FileOutputStream.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </arguments>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="file">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="File.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new print stream, without automatic line flushing, with the&#xA;     * specified file.  This convenience constructor creates the necessary&#xA;     * intermediate {@link java.io.OutputStreamWriter OutputStreamWriter},&#xA;     * which will encode characters using the {@linkplain&#xA;     * java.nio.charset.Charset#defaultCharset default charset} for this&#xA;     * instance of the Java virtual machine.&#xA;     *&#xA;     * @param  file&#xA;     *         The file to use as the destination of this print stream.  If the&#xA;     *         file exists, then it will be truncated to zero size; otherwise,&#xA;     *         a new file will be created.  The output will be written to the&#xA;     *         file and is buffered.&#xA;     *&#xA;     * @throws  FileNotFoundException&#xA;     *          If the given file object does not denote an existing, writable&#xA;     *          regular file and a new regular file of that name cannot be&#xA;     *          created, or if some other error occurs while opening or&#xA;     *          creating the file&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager is present and {@link&#xA;     *          SecurityManager#checkWrite checkWrite(file.getPath())}&#xA;     *          denies write access to the file&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintStream">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="literals:BooleanLiteral"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="FileOutputStream.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          </arguments>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.7">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
          </arguments>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="file">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="File.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csn">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="UnsupportedEncodingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new print stream, without automatic line flushing, with the&#xA;     * specified file and charset.  This convenience constructor creates&#xA;     * the necessary intermediate {@link java.io.OutputStreamWriter&#xA;     * OutputStreamWriter}, which will encode characters using the provided&#xA;     * charset.&#xA;     *&#xA;     * @param  file&#xA;     *         The file to use as the destination of this print stream.  If the&#xA;     *         file exists, then it will be truncated to zero size; otherwise,&#xA;     *         a new file will be created.  The output will be written to the&#xA;     *         file and is buffered.&#xA;     *&#xA;     * @param  csn&#xA;     *         The name of a supported {@linkplain java.nio.charset.Charset&#xA;     *         charset}&#xA;     *&#xA;     * @throws  FileNotFoundException&#xA;     *          If the given file object does not denote an existing, writable&#xA;     *          regular file and a new regular file of that name cannot be&#xA;     *          created, or if some other error occurs while opening or&#xA;     *          creating the file&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager is presentand {@link&#xA;     *          SecurityManager#checkWrite checkWrite(file.getPath())}&#xA;     *          denies write access to the file&#xA;     *&#xA;     * @throws  UnsupportedEncodingException&#xA;     *          If the named charset is not supported&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="ensureOpen">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** Check to make sure that the stream has not been closed */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Stream closed"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
          </children>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="flush">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Flush the stream.  This is done by writing any buffered output bytes to&#xA;     * the underlying output stream and then flushing that stream.&#xA;     *&#xA;     * @see        java.io.OutputStream#flush()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:TryBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="OutputStream.class.xmi#//@classifiers.0/@members.4"/>
              </next>
              <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
            </expression>
          </statements>
          <catcheBlocks>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </expression>
            </statements>
            <parameter name="x">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </parameter>
          </catcheBlocks>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:Field" name="closing">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:ClassMethod" name="close">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* To avoid recursive closing */</comments>
        <comments>/**&#xA;     * Close the stream.  This is done by flushing the stream and then closing&#xA;     * the underlying output stream.&#xA;     *&#xA;     * @see        java.io.OutputStream#close()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:BooleanLiteral" value="true"/>
              </expression>
            </statements>
            <statements xsi:type="statements:TryBlock">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="BufferedWriter.class.xmi#//@classifiers.0/@members.16"/>
                  </next>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="OutputStream.class.xmi#//@classifiers.0/@members.5"/>
                  </next>
                  <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
                </expression>
              </statements>
              <catcheBlocks>
                <statements xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="expressions:AssignmentExpression">
                    <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
                    <assignmentOperator xsi:type="operators:Assignment"/>
                    <value xsi:type="literals:BooleanLiteral" value="true"/>
                  </expression>
                </statements>
                <parameter name="x">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                </parameter>
              </catcheBlocks>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:NullLiteral"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:NullLiteral"/>
              </expression>
            </statements>
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
                </child>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="literals:NullLiteral"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:UnaryExpression">
            <operators xsi:type="operators:Negate"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
          </condition>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkError">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Flush the stream and check its error state.  The internal error state&#xA;     * is set to &lt;code>true&lt;/code> when the underlying output stream throws an&#xA;     * &lt;code>IOException&lt;/code> other than &lt;code>InterruptedIOException&lt;/code>,&#xA;     * and when the &lt;code>setError&lt;/code> method is invoked.  If an operation&#xA;     * on the underlying output stream throws an&#xA;     * &lt;code>InterruptedIOException&lt;/code>, then the &lt;code>PrintStream&lt;/code>&#xA;     * converts the exception back into an interrupt by doing:&#xA;     * &lt;pre>&#xA;     *     Thread.currentThread().interrupt();&#xA;     * &lt;/pre>&#xA;     * or the equivalent.&#xA;     *&#xA;     * @return True if and only if this stream has encountered an&#xA;     *         &lt;code>IOException&lt;/code> other than&#xA;     *         &lt;code>InterruptedIOException&lt;/code>, or the&#xA;     *         &lt;code>setError&lt;/code> method has been invoked&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.15"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
          </children>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setError">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Set the error state of the stream to &lt;code>true&lt;/code>.&#xA;     *&#xA;     * @since JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statements>
        <catcheBlocks>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/*&#xA;     * Exception-catching, synchronized output operations,&#xA;     * which also implement the write() methods of OutputStream&#xA;     */</comments>
        <comments>/**&#xA;     * Write the specified byte to this stream.  If the byte is a newline and&#xA;     * automatic flushing is enabled then the &lt;code>flush&lt;/code> method will be&#xA;     * invoked.&#xA;     *&#xA;     * &lt;p> Note that the byte is written as given; to write a character that&#xA;     * will be translated according to the platform's default character&#xA;     * encoding, use the &lt;code>print(char)&lt;/code> or &lt;code>println(char)&lt;/code>&#xA;     * methods.&#xA;     *&#xA;     * @param  b  The byte to be written&#xA;     * @see #print(char)&#xA;     * @see #println(char)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="OutputStream.class.xmi#//@classifiers.0/@members.1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              </next>
              <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="OutputStream.class.xmi#//@classifiers.0/@members.4"/>
                </next>
                <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
              </expression>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
                  <children xsi:type="literals:CharacterLiteral" value="10"/>
                </expression>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </condition>
          </statements>
          <lockProvider xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Write &lt;code>len&lt;/code> bytes from the specified byte array starting at&#xA;     * offset &lt;code>off&lt;/code> to this stream.  If automatic flushing is&#xA;     * enabled then the &lt;code>flush&lt;/code> method will be invoked.&#xA;     *&#xA;     * &lt;p> Note that the bytes will be written as given; to write characters&#xA;     * that will be translated according to the platform's default character&#xA;     * encoding, use the &lt;code>print(char)&lt;/code> or &lt;code>println(char)&lt;/code>&#xA;     * methods.&#xA;     *&#xA;     * @param  buf   A byte array&#xA;     * @param  off   Offset from which to start taking bytes&#xA;     * @param  len   Number of bytes to write&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="OutputStream.class.xmi#//@classifiers.0/@members.3"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
              </next>
              <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="OutputStream.class.xmi#//@classifiers.0/@members.4"/>
                </next>
                <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </statements>
          <lockProvider xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/*&#xA;     * The following private methods on the text- and character-output streams&#xA;     * always flush the stream buffers, so that writes to the underlying byte&#xA;     * stream occur as promptly as with the original PrintStream.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Writer.class.xmi#//@classifiers.0/@members.6"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BufferedWriter.class.xmi#//@classifiers.0/@members.9"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="OutputStreamWriter.class.xmi#//@classifiers.0/@members.6"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ForLoop">
                <statement xsi:type="statements:Condition">
                  <statement xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="OutputStream.class.xmi#//@classifiers.0/@members.4"/>
                      </next>
                      <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
                    </expression>
                  </statement>
                  <condition xsi:type="expressions:EqualityExpression">
                    <equalityOperators xsi:type="operators:Equal"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
                      <arraySelectors>
                        <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@statements.0/@statements.4/@statement/@statements.0/@init"/>
                      </arraySelectors>
                    </children>
                    <children xsi:type="literals:CharacterLiteral" value="10"/>
                  </condition>
                </statement>
                <condition xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@statements.0/@statements.4/@statement/@statements.0/@init"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
                    <next xsi:type="references:IdentifierReference"/>
                  </children>
                  <relationOperators xsi:type="operators:LessThan"/>
                </condition>
                <init xsi:type="variables:LocalVariable" name="i">
                  <typeReference xsi:type="types:Int"/>
                  <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                </init>
                <updates xsi:type="expressions:SuffixUnaryModificationExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.0/@statements.0/@statements.4/@statement/@statements.0/@init"/>
                  <operator xsi:type="operators:PlusPlus"/>
                </updates>
              </statements>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </statements>
          <lockProvider xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Writer.class.xmi#//@classifiers.0/@members.8"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BufferedWriter.class.xmi#//@classifiers.0/@members.9"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="OutputStreamWriter.class.xmi#//@classifiers.0/@members.6"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="OutputStream.class.xmi#//@classifiers.0/@members.4"/>
                </next>
                <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
              </expression>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:RelationExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.45"/>
                      <arguments xsi:type="literals:CharacterLiteral" value="10"/>
                    </next>
                  </children>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  <relationOperators xsi:type="operators:GreaterThanOrEqual"/>
                </expression>
              </children>
            </condition>
          </statements>
          <lockProvider xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newLine">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BufferedWriter.class.xmi#//@classifiers.0/@members.14"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="BufferedWriter.class.xmi#//@classifiers.0/@members.9"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="OutputStreamWriter.class.xmi#//@classifiers.0/@members.6"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="OutputStream.class.xmi#//@classifiers.0/@members.4"/>
                </next>
                <target xsi:type="members:Field" href="FilterOutputStream.class.xmi#//@classifiers.0/@members.0"/>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          </statements>
          <lockProvider xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* Methods that do not terminate lines */</comments>
        <comments>/**&#xA;     * Print a boolean value.  The string produced by &lt;code>{@link&#xA;     * java.lang.String#valueOf(boolean)}&lt;/code> is translated into bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the&#xA;     * &lt;code>{@link #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      b   The &lt;code>boolean&lt;/code> to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <expressionIf xsi:type="references:StringReference" value="true"/>
            <expressionElse xsi:type="references:StringReference" value="false"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a character.  The character is translated into one or more bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the&#xA;     * &lt;code>{@link #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      c   The &lt;code>char&lt;/code> to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.82"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an integer.  The string produced by &lt;code>{@link&#xA;     * java.lang.String#valueOf(int)}&lt;/code> is translated into bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the&#xA;     * &lt;code>{@link #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      i   The &lt;code>int&lt;/code> to be printed&#xA;     * @see        java.lang.Integer#toString(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.83"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a long integer.  The string produced by &lt;code>{@link&#xA;     * java.lang.String#valueOf(long)}&lt;/code> is translated into bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the&#xA;     * &lt;code>{@link #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      l   The &lt;code>long&lt;/code> to be printed&#xA;     * @see        java.lang.Long#toString(long)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.84"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a floating-point number.  The string produced by &lt;code>{@link&#xA;     * java.lang.String#valueOf(float)}&lt;/code> is translated into bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the&#xA;     * &lt;code>{@link #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      f   The &lt;code>float&lt;/code> to be printed&#xA;     * @see        java.lang.Float#toString(float)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.85"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a double-precision floating-point number.  The string produced by&#xA;     * &lt;code>{@link java.lang.String#valueOf(double)}&lt;/code> is translated into&#xA;     * bytes according to the platform's default character encoding, and these&#xA;     * bytes are written in exactly the manner of the &lt;code>{@link&#xA;     * #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      d   The &lt;code>double&lt;/code> to be printed&#xA;     * @see        java.lang.Double#toString(double)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.86"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an array of characters.  The characters are converted into bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the&#xA;     * &lt;code>{@link #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      s   The array of chars to be printed&#xA;     *&#xA;     * @throws  NullPointerException  If &lt;code>s&lt;/code> is &lt;code>null&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a string.  If the argument is &lt;code>null&lt;/code> then the string&#xA;     * &lt;code>&quot;null&quot;&lt;/code> is printed.  Otherwise, the string's characters are&#xA;     * converted into bytes according to the platform's default character&#xA;     * encoding, and these bytes are written in exactly the manner of the&#xA;     * &lt;code>{@link #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      s   The &lt;code>String&lt;/code> to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:StringReference" value="null"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an object.  The string produced by the &lt;code>{@link&#xA;     * java.lang.String#valueOf(Object)}&lt;/code> method is translated into bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the&#xA;     * &lt;code>{@link #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      obj   The &lt;code>Object&lt;/code> to be printed&#xA;     * @see        java.lang.Object#toString()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.76"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* Methods that do terminate lines */</comments>
        <comments>/**&#xA;     * Terminate the current line by writing the line separator string.  The&#xA;     * line separator string is defined by the system property&#xA;     * &lt;code>line.separator&lt;/code>, and is not necessarily a single newline&#xA;     * character (&lt;code>'\n'&lt;/code>).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a boolean and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(boolean)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x  The &lt;code>boolean&lt;/code> to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24"/>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a character and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(char)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x  The &lt;code>char&lt;/code> to be printed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24"/>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an integer and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(int)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x  The &lt;code>int&lt;/code> to be printed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.27">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24"/>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a long and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(long)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x  a The &lt;code>long&lt;/code> to be printed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24"/>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a float and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(float)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x  The &lt;code>float&lt;/code> to be printed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.29">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24"/>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a double and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(double)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x  The &lt;code>double&lt;/code> to be printed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24"/>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an array of characters and then terminate the line.  This method&#xA;     * behaves as though it invokes &lt;code>{@link #print(char[])}&lt;/code> and&#xA;     * then &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x  an array of chars to print.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24"/>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a String and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(String)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x  The &lt;code>String&lt;/code> to be printed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.32">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24"/>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an Object and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(Object)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x  The &lt;code>Object&lt;/code> to be printed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.33">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24"/>
        </statements>
        <lockProvider xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="printf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="format">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:VariableLengthParameter" name="args">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A convenience method to write a formatted string to this output stream&#xA;     * using the specified format string and arguments.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>out.printf(format,&#xA;     * args)&lt;/tt> behaves in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     out.format(format, args) &lt;/pre>&#xA;     *&#xA;     * @param  format&#xA;     *         A format string as described in &lt;a&#xA;     *         href=&quot;../util//Formatter.html#syntax&quot;>Format string syntax&lt;/a>&#xA;     *&#xA;     * @param  args&#xA;     *         Arguments referenced by the format specifiers in the format&#xA;     *         string.  If there are more arguments than format specifiers, the&#xA;     *         extra arguments are ignored.  The number of arguments is&#xA;     *         variable and may be zero.  The maximum number of arguments is&#xA;     *         limited by the maximum dimension of a Java array as defined by&#xA;     *         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;>Java&#xA;     *         Virtual Machine Specification&lt;/a>.  The behaviour on a&#xA;     *         &lt;tt>null&lt;/tt> argument depends on the &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>conversion&lt;/a>.&#xA;     *&#xA;     * @throws  IllegalFormatException&#xA;     *          If a format string contains an illegal syntax, a format&#xA;     *          specifier that is incompatible with the given arguments,&#xA;     *          insufficient arguments given the format string, or other&#xA;     *          illegal conditions.  For specification of all possible&#xA;     *          formatting errors, see the &lt;a&#xA;     *          href=&quot;../util/Formatter.html#detail&quot;>Details&lt;/a> section of the&#xA;     *          formatter class specification.&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If the &lt;tt>format&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @return  This output stream&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.46">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="printf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="format">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:VariableLengthParameter" name="args">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A convenience method to write a formatted string to this output stream&#xA;     * using the specified format string and arguments.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>out.printf(l, format,&#xA;     * args)&lt;/tt> behaves in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     out.format(l, format, args) &lt;/pre>&#xA;     *&#xA;     * @param  l&#xA;     *         The {@linkplain java.util.Locale locale} to apply during&#xA;     *         formatting.  If &lt;tt>l&lt;/tt> is &lt;tt>null&lt;/tt> then no localization&#xA;     *         is applied.&#xA;     *&#xA;     * @param  format&#xA;     *         A format string as described in &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>Format string syntax&lt;/a>&#xA;     *&#xA;     * @param  args&#xA;     *         Arguments referenced by the format specifiers in the format&#xA;     *         string.  If there are more arguments than format specifiers, the&#xA;     *         extra arguments are ignored.  The number of arguments is&#xA;     *         variable and may be zero.  The maximum number of arguments is&#xA;     *         limited by the maximum dimension of a Java array as defined by&#xA;     *         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;>Java&#xA;     *         Virtual Machine Specification&lt;/a>.  The behaviour on a&#xA;     *         &lt;tt>null&lt;/tt> argument depends on the &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>conversion&lt;/a>.&#xA;     *&#xA;     * @throws  IllegalFormatException&#xA;     *          If a format string contains an illegal syntax, a format&#xA;     *          specifier that is incompatible with the given arguments,&#xA;     *          insufficient arguments given the format string, or other&#xA;     *          illegal conditions.  For specification of all possible&#xA;     *          formatting errors, see the &lt;a&#xA;     *          href=&quot;../util/Formatter.html#detail&quot;>Details&lt;/a> section of the&#xA;     *          formatter class specification.&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If the &lt;tt>format&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @return  This output stream&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.47">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="format">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:VariableLengthParameter" name="args">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a formatted string to this output stream using the specified&#xA;     * format string and arguments.&#xA;     *&#xA;     * &lt;p> The locale always used is the one returned by {@link&#xA;     * java.util.Locale#getDefault() Locale.getDefault()}, regardless of any&#xA;     * previous invocations of other formatting methods on this object.&#xA;     *&#xA;     * @param  format&#xA;     *         A format string as described in &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>Format string syntax&lt;/a>&#xA;     *&#xA;     * @param  args&#xA;     *         Arguments referenced by the format specifiers in the format&#xA;     *         string.  If there are more arguments than format specifiers, the&#xA;     *         extra arguments are ignored.  The number of arguments is&#xA;     *         variable and may be zero.  The maximum number of arguments is&#xA;     *         limited by the maximum dimension of a Java array as defined by&#xA;     *         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;>Java&#xA;     *         Virtual Machine Specification&lt;/a>.  The behaviour on a&#xA;     *         &lt;tt>null&lt;/tt> argument depends on the &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>conversion&lt;/a>.&#xA;     *&#xA;     * @throws  IllegalFormatException&#xA;     *          If a format string contains an illegal syntax, a format&#xA;     *          specifier that is incompatible with the given arguments,&#xA;     *          insufficient arguments given the format string, or other&#xA;     *          illegal conditions.  For specification of all possible&#xA;     *          formatting errors, see the &lt;a&#xA;     *          href=&quot;../util/Formatter.html#detail&quot;>Details&lt;/a> section of the&#xA;     *          formatter class specification.&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If the &lt;tt>format&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @return  This output stream&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../util/Formatter.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:CastExpression">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Interface" href="../lang/Appendable.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <child xsi:type="references:SelfReference">
                      <self xsi:type="literals:This"/>
                    </child>
                  </arguments>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  <children xsi:type="literals:NullLiteral"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.24"/>
                    </next>
                  </children>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
                  </children>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1"/>
              </next>
            </expression>
          </statements>
          <lockProvider xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="format">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:VariableLengthParameter" name="args">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a formatted string to this output stream using the specified&#xA;     * format string and arguments.&#xA;     *&#xA;     * @param  l&#xA;     *         The {@linkplain java.util.Locale locale} to apply during&#xA;     *         formatting.  If &lt;tt>l&lt;/tt> is &lt;tt>null&lt;/tt> then no localization&#xA;     *         is applied.&#xA;     *&#xA;     * @param  format&#xA;     *         A format string as described in &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>Format string syntax&lt;/a>&#xA;     *&#xA;     * @param  args&#xA;     *         Arguments referenced by the format specifiers in the format&#xA;     *         string.  If there are more arguments than format specifiers, the&#xA;     *         extra arguments are ignored.  The number of arguments is&#xA;     *         variable and may be zero.  The maximum number of arguments is&#xA;     *         limited by the maximum dimension of a Java array as defined by&#xA;     *         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;>Java&#xA;     *         Virtual Machine Specification&lt;/a>.  The behaviour on a&#xA;     *         &lt;tt>null&lt;/tt> argument depends on the &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>conversion&lt;/a>.&#xA;     *&#xA;     * @throws  IllegalFormatException&#xA;     *          If a format string contains an illegal syntax, a format&#xA;     *          specifier that is incompatible with the given arguments,&#xA;     *          insufficient arguments given the format string, or other&#xA;     *          illegal conditions.  For specification of all possible&#xA;     *          formatting errors, see the &lt;a&#xA;     *          href=&quot;../util/Formatter.html#detail&quot;>Details&lt;/a> section of the&#xA;     *          formatter class specification.&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If the &lt;tt>format&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @return  This output stream&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../util/Formatter.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  <children xsi:type="literals:NullLiteral"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.24"/>
                    </next>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.2"/>
              </next>
            </expression>
          </statements>
          <lockProvider xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the specified character sequence to this output stream.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>out.append(csq)&lt;/tt>&#xA;     * behaves in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     out.print(csq.toString()) &lt;/pre>&#xA;     *&#xA;     * &lt;p> Depending on the specification of &lt;tt>toString&lt;/tt> for the&#xA;     * character sequence &lt;tt>csq&lt;/tt>, the entire sequence may not be&#xA;     * appended.  appended.  For instance, invoking then &lt;tt>toString&lt;/tt>&#xA;     * method of a character buffer will return a subsequence whose content&#xA;     * depends upon the buffer's position and limit.&#xA;     *&#xA;     * @param  csq&#xA;     *         The character sequence to append.  If &lt;tt>csq&lt;/tt> is&#xA;     *         &lt;tt>null&lt;/tt>, then the four characters &lt;tt>&quot;null&quot;&lt;/tt> are&#xA;     *         appended to this output stream.&#xA;     *&#xA;     * @return  This character stream&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.32">
            <arguments xsi:type="references:StringReference" value="null"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.32">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../lang/CharSequence.class.xmi#//@classifiers.0/@members.3"/>
              </next>
            </arguments>
          </expression>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends a subsequence of the specified character sequence to this output&#xA;     * stream. &#xA;     * &#xA;     * &lt;p> An invocation of this method of the form &lt;tt>out.append(csq, start,&#xA;     * end)&lt;/tt> when &lt;tt>csq&lt;/tt> is not &lt;tt>null&lt;/tt>, behaves in&#xA;     * exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     out.print(csq.subSequence(start, end).toString()) &lt;/pre>&#xA;     *&#xA;     * @param  csq&#xA;     *         The character sequence from which a subsequence will be&#xA;     *         appended.  If &lt;tt>csq&lt;/tt> is &lt;tt>null&lt;/tt>, then characters&#xA;     *         will be appended as if &lt;tt>csq&lt;/tt> contained the four&#xA;     *         characters &lt;tt>&quot;null&quot;&lt;/tt>.&#xA;     *&#xA;     * @param  start&#xA;     *         The index of the first character in the subsequence&#xA;     *&#xA;     * @param  end&#xA;     *         The index of the character following the last character in the&#xA;     *         subsequence&#xA;     *&#xA;     * @return  This character stream&#xA;     *&#xA;     * @throws  IndexOutOfBoundsException&#xA;     *          If &lt;tt>start&lt;/tt> or &lt;tt>end&lt;/tt> are negative, &lt;tt>start&lt;/tt>&#xA;     *          is greater than &lt;tt>end&lt;/tt>, or &lt;tt>end&lt;/tt> is greater than&#xA;     *          &lt;tt>csq.length()&lt;/tt>&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalExpression">
              <child xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
                <children xsi:type="literals:NullLiteral"/>
              </child>
              <expressionIf xsi:type="references:StringReference" value="null"/>
              <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../lang/CharSequence.class.xmi#//@classifiers.0/@members.3"/>
              </next>
              <target xsi:type="members:InterfaceMethod" href="../lang/CharSequence.class.xmi#//@classifiers.0/@members.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.2"/>
            </next>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the specified character to this output stream.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>out.append(c)&lt;/tt>&#xA;     * behaves in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     out.print(c) &lt;/pre>&#xA;     *&#xA;     * @param  c&#xA;     *         The 16-bit character to append&#xA;     *&#xA;     * @return  This output stream&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A &lt;code>PrintStream&lt;/code> adds functionality to another output stream,&#xA; * namely the ability to print representations of various data values&#xA; * conveniently.  Two other features are provided as well.  Unlike other output&#xA; * streams, a &lt;code>PrintStream&lt;/code> never throws an&#xA; * &lt;code>IOException&lt;/code>; instead, exceptional situations merely set an&#xA; * internal flag that can be tested via the &lt;code>checkError&lt;/code> method.&#xA; * Optionally, a &lt;code>PrintStream&lt;/code> can be created so as to flush&#xA; * automatically; this means that the &lt;code>flush&lt;/code> method is&#xA; * automatically invoked after a byte array is written, one of the&#xA; * &lt;code>println&lt;/code> methods is invoked, or a newline character or byte&#xA; * (&lt;code>'\n'&lt;/code>) is written.&#xA; *&#xA; * &lt;p> All characters printed by a &lt;code>PrintStream&lt;/code> are converted into&#xA; * bytes using the platform's default character encoding.  The &lt;code>{@link&#xA; * PrintWriter}&lt;/code> class should be used in situations that require writing&#xA; * characters rather than bytes.&#xA; *&#xA; * @version    1.32, 04/07/16&#xA; * @author     Frank Yellin&#xA; * @author     Mark Reinhold&#xA; * @since      JDK1.0&#xA; */</comments>
    </annotationsAndModifiers>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../lang/Appendable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Closeable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="FilterOutputStream.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
