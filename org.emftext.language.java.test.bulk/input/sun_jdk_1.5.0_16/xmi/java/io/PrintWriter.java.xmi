<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="PrintWriter.java">
  <comments>/*&#xA; * @(#)PrintWriter.java&#x9;1.37 04/07/16&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>io</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Formatter.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="PrintWriter">
    <members xsi:type="members:Field" name="out">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Writer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The underlying character-output stream of this&#xA;     * &lt;code>PrintWriter&lt;/code>.&#xA;     *&#xA;     * @since 1.2&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="autoFlush">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="trouble">
      <initialValue xsi:type="literals:BooleanLiteral"/>
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="formatter">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../util/Formatter.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="lineSeparator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Line separator string.  This is the value of the line.separator&#xA;     * property at the moment that the stream was created.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintWriter">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          <arguments xsi:type="literals:BooleanLiteral"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Writer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a new PrintWriter, without automatic line flushing.&#xA;     *&#xA;     * @param  out        A character-output stream&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintWriter">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../security/AccessController.class.xmi#//@classifiers.0/@members.1"/>
                    <arguments xsi:type="instantiations:NewConstructorCall">
                      <typeReference xsi:type="types:NamespaceClassifierReference">
                        <namespaces>sun</namespaces>
                        <namespaces>security</namespaces>
                        <namespaces>action</namespaces>
                        <classifierReferences>
                          <target xsi:type="classifiers:Class" href="../../sun/security/action/GetPropertyAction.class.xmi#//@classifiers.0"/>
                        </classifierReferences>
                      </typeReference>
                      <arguments xsi:type="references:StringReference" value="line.separator"/>
                    </arguments>
                  </next>
                  <target xsi:type="classifiers:Class" href="../security/AccessController.class.xmi#//@classifiers.0"/>
                </next>
              </next>
            </child>
          </value>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Writer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="autoFlush">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a new PrintWriter.&#xA;     *&#xA;     * @param  out        A character-output stream&#xA;     * @param  autoFlush  A boolean; if true, the &lt;tt>println&lt;/tt>,&#xA;     *                    &lt;tt>printf&lt;/tt>, or &lt;tt>format&lt;/tt> methods will&#xA;     *                    flush the output buffer&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintWriter">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          <arguments xsi:type="literals:BooleanLiteral"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a new PrintWriter, without automatic line flushing, from an&#xA;     * existing OutputStream.  This convenience constructor creates the&#xA;     * necessary intermediate OutputStreamWriter, which will convert characters&#xA;     * into bytes using the default character encoding.&#xA;     *&#xA;     * @param  out        An output stream&#xA;     *&#xA;     * @see java.io.OutputStreamWriter#OutputStreamWriter(java.io.OutputStream)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintWriter">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferedWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
            </arguments>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.1"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="out">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="OutputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="autoFlush">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a new PrintWriter from an existing OutputStream.  This&#xA;     * convenience constructor creates the necessary intermediate&#xA;     * OutputStreamWriter, which will convert characters into bytes using the&#xA;     * default character encoding.&#xA;     *&#xA;     * @param  out        An output stream&#xA;     * @param  autoFlush  A boolean; if true, the &lt;tt>println&lt;/tt>,&#xA;     *                    &lt;tt>printf&lt;/tt>, or &lt;tt>format&lt;/tt> methods will&#xA;     *                    flush the output buffer&#xA;     *&#xA;     * @see java.io.OutputStreamWriter#OutputStreamWriter(java.io.OutputStream)&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintWriter">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferedWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="FileOutputStream.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
              </arguments>
            </arguments>
          </arguments>
          <arguments xsi:type="literals:BooleanLiteral"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fileName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new PrintWriter, without automatic line flushing, with the&#xA;     * specified file name.  This convenience constructor creates the necessary&#xA;     * intermediate {@link java.io.OutputStreamWriter OutputStreamWriter},&#xA;     * which will encode characters using the {@linkplain&#xA;     * java.nio.charset.Charset#defaultCharset default charset} for this&#xA;     * instance of the Java virtual machine.&#xA;     *&#xA;     * @param  fileName&#xA;     *         The name of the file to use as the destination of this writer.&#xA;     *         If the file exists then it will be truncated to zero size;&#xA;     *         otherwise, a new file will be created.  The output will be&#xA;     *         written to the file and is buffered.&#xA;     *&#xA;     * @throws  FileNotFoundException&#xA;     *          If the given string does not denote an existing, writable&#xA;     *          regular file and a new regular file of that name cannot be&#xA;     *          created, or if some other error occurs while opening or&#xA;     *          creating the file&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager is present and {@link&#xA;     *          SecurityManager#checkWrite checkWrite(fileName)} denies write&#xA;     *          access to the file&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintWriter">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferedWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="FileOutputStream.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.1"/>
            </arguments>
          </arguments>
          <arguments xsi:type="literals:BooleanLiteral"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fileName">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csn">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="UnsupportedEncodingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new PrintWriter, without automatic line flushing, with the&#xA;     * specified file name and charset.  This convenience constructor creates&#xA;     * the necessary intermediate {@link java.io.OutputStreamWriter&#xA;     * OutputStreamWriter}, which will encode characters using the provided&#xA;     * charset.&#xA;     *&#xA;     * @param  fileName&#xA;     *         The name of the file to use as the destination of this writer.&#xA;     *         If the file exists then it will be truncated to zero size;&#xA;     *         otherwise, a new file will be created.  The output will be&#xA;     *         written to the file and is buffered.&#xA;     *&#xA;     * @param  csn&#xA;     *         The name of a supported {@linkplain java.nio.charset.Charset&#xA;     *         charset}&#xA;     *&#xA;     * @throws  FileNotFoundException&#xA;     *          If the given string does not denote an existing, writable&#xA;     *          regular file and a new regular file of that name cannot be&#xA;     *          created, or if some other error occurs while opening or&#xA;     *          creating the file&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager is present and {@link&#xA;     *          SecurityManager#checkWrite checkWrite(fileName)} denies write&#xA;     *          access to the file&#xA;     *&#xA;     * @throws  UnsupportedEncodingException&#xA;     *          If the named charset is not supported&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintWriter">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferedWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="FileOutputStream.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
              </arguments>
            </arguments>
          </arguments>
          <arguments xsi:type="literals:BooleanLiteral"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="file">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="File.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new PrintWriter, without automatic line flushing, with the&#xA;     * specified file.  This convenience constructor creates the necessary&#xA;     * intermediate {@link java.io.OutputStreamWriter OutputStreamWriter},&#xA;     * which will encode characters using the {@linkplain&#xA;     * java.nio.charset.Charset#defaultCharset default charset} for this&#xA;     * instance of the Java virtual machine.&#xA;     *&#xA;     * @param  file&#xA;     *         The file to use as the destination of this writer.  If the file&#xA;     *         exists then it will be truncated to zero size; otherwise, a new&#xA;     *         file will be created.  The output will be written to the file&#xA;     *         and is buffered.&#xA;     *&#xA;     * @throws  FileNotFoundException&#xA;     *          If the given file object does not denote an existing, writable&#xA;     *          regular file and a new regular file of that name cannot be&#xA;     *          created, or if some other error occurs while opening or&#xA;     *          creating the file&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager is present and {@link&#xA;     *          SecurityManager#checkWrite checkWrite(file.getPath())}&#xA;     *          denies write access to the file&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="PrintWriter">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BufferedWriter.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="OutputStreamWriter.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="FileOutputStream.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
            </arguments>
          </arguments>
          <arguments xsi:type="literals:BooleanLiteral"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="file">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="File.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csn">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FileNotFoundException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="UnsupportedEncodingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new PrintWriter, without automatic line flushing, with the&#xA;     * specified file and charset.  This convenience constructor creates the&#xA;     * necessary intermediate {@link java.io.OutputStreamWriter&#xA;     * OutputStreamWriter}, which will encode characters using the provided&#xA;     * charset.&#xA;     *&#xA;     * @param  file&#xA;     *         The file to use as the destination of this writer.  If the file&#xA;     *         exists then it will be truncated to zero size; otherwise, a new&#xA;     *         file will be created.  The output will be written to the file&#xA;     *         and is buffered.&#xA;     *&#xA;     * @param  csn&#xA;     *         The name of a supported {@linkplain java.nio.charset.Charset&#xA;     *         charset}&#xA;     *&#xA;     * @throws  FileNotFoundException&#xA;     *          If the given file object does not denote an existing, writable&#xA;     *          regular file and a new regular file of that name cannot be&#xA;     *          created, or if some other error occurs while opening or&#xA;     *          creating the file&#xA;     *&#xA;     * @throws  SecurityException&#xA;     *          If a security manager is present and {@link&#xA;     *          SecurityManager#checkWrite checkWrite(file.getPath())}&#xA;     *          denies write access to the file&#xA;     *&#xA;     * @throws  UnsupportedEncodingException&#xA;     *          If the named charset is not supported&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="ensureOpen">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** Check to make sure that the stream has not been closed */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:StringReference" value="Stream closed"/>
          </throwable>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="flush">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Flush the stream.&#xA;     * @see #checkError()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Writer.class.xmi#//@classifiers.0/@members.13"/>
              </next>
            </expression>
          </statements>
          <lockProvider xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="close">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Close the stream.&#xA;     * @see #checkError()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Return"/>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Writer.class.xmi#//@classifiers.0/@members.14"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:NullLiteral"/>
            </expression>
          </statements>
          <lockProvider xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkError">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Flush the stream if it's not closed and check its error state.&#xA;     * Errors are cumulative; once the stream encounters an error, this&#xA;     * routine will return true on all successive calls.&#xA;     *&#xA;     * @return True if the print stream has encountered an error, either on the&#xA;     * underlying output stream or during a format conversion.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.14"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setError">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** Indicate that an error has occurred. */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="literals:BooleanLiteral" value="true"/>
        </expression>
      </statements>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Throw">
          <throwable xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </throwable>
        </statements>
        <catcheBlocks>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/*&#xA;     * Exception-catching, synchronized output operations,&#xA;     * which also implement the write() methods of Writer&#xA;     */</comments>
        <comments>/**&#xA;     * Write a single character.&#xA;     * @param c int specifying a character to be written.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Writer.class.xmi#//@classifiers.0/@members.5"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
              </next>
            </expression>
          </statements>
          <lockProvider xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Write A Portion of an array of characters.&#xA;     * @param buf Array of characters&#xA;     * @param off Offset from which to start writing characters&#xA;     * @param len Number of characters to write&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Writer.class.xmi#//@classifiers.0/@members.7"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.2"/>
              </next>
            </expression>
          </statements>
          <lockProvider xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="buf">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Write an array of characters.  This method cannot be inherited from the&#xA;     * Writer class because it must suppress I/O exceptions.&#xA;     * @param buf Array of characters to be written&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Write a portion of a string.&#xA;     * @param s A String&#xA;     * @param off Offset from which to start writing characters&#xA;     * @param len Number of characters to write&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Writer.class.xmi#//@classifiers.0/@members.9"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
              </next>
            </expression>
          </statements>
          <lockProvider xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Write a string.  This method cannot be inherited from the Writer class&#xA;     * because it must suppress I/O exceptions.&#xA;     * @param s String to be written&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.21">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="newLine">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13"/>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Writer.class.xmi#//@classifiers.0/@members.8"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Writer.class.xmi#//@classifiers.0/@members.13"/>
                </next>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </statements>
          <lockProvider xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* Methods that do not terminate lines */</comments>
        <comments>/**&#xA;     * Print a boolean value.  The string produced by &lt;code>{@link&#xA;     * java.lang.String#valueOf(boolean)}&lt;/code> is translated into bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the &lt;code>{@link&#xA;     * #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      b   The &lt;code>boolean&lt;/code> to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            <expressionIf xsi:type="references:StringReference" value="true"/>
            <expressionElse xsi:type="references:StringReference" value="false"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a character.  The character is translated into one or more bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the &lt;code>{@link&#xA;     * #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      c   The &lt;code>char&lt;/code> to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="i">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an integer.  The string produced by &lt;code>{@link&#xA;     * java.lang.String#valueOf(int)}&lt;/code> is translated into bytes according&#xA;     * to the platform's default character encoding, and these bytes are&#xA;     * written in exactly the manner of the &lt;code>{@link #write(int)}&lt;/code>&#xA;     * method.&#xA;     *&#xA;     * @param      i   The &lt;code>int&lt;/code> to be printed&#xA;     * @see        java.lang.Integer#toString(int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.83"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a long integer.  The string produced by &lt;code>{@link&#xA;     * java.lang.String#valueOf(long)}&lt;/code> is translated into bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the &lt;code>{@link #write(int)}&lt;/code>&#xA;     * method.&#xA;     *&#xA;     * @param      l   The &lt;code>long&lt;/code> to be printed&#xA;     * @see        java.lang.Long#toString(long)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.84"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a floating-point number.  The string produced by &lt;code>{@link&#xA;     * java.lang.String#valueOf(float)}&lt;/code> is translated into bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the &lt;code>{@link #write(int)}&lt;/code>&#xA;     * method.&#xA;     *&#xA;     * @param      f   The &lt;code>float&lt;/code> to be printed&#xA;     * @see        java.lang.Float#toString(float)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.85"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="d">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a double-precision floating-point number.  The string produced by&#xA;     * &lt;code>{@link java.lang.String#valueOf(double)}&lt;/code> is translated into&#xA;     * bytes according to the platform's default character encoding, and these&#xA;     * bytes are written in exactly the manner of the &lt;code>{@link&#xA;     * #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      d   The &lt;code>double&lt;/code> to be printed&#xA;     * @see        java.lang.Double#toString(double)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.86"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an array of characters.  The characters are converted into bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the &lt;code>{@link #write(int)}&lt;/code>&#xA;     * method.&#xA;     *&#xA;     * @param      s   The array of chars to be printed&#xA;     *&#xA;     * @throws  NullPointerException  If &lt;code>s&lt;/code> is &lt;code>null&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a string.  If the argument is &lt;code>null&lt;/code> then the string&#xA;     * &lt;code>&quot;null&quot;&lt;/code> is printed.  Otherwise, the string's characters are&#xA;     * converted into bytes according to the platform's default character&#xA;     * encoding, and these bytes are written in exactly the manner of the&#xA;     * &lt;code>{@link #write(int)}&lt;/code> method.&#xA;     *&#xA;     * @param      s   The &lt;code>String&lt;/code> to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:StringReference" value="null"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="print">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an object.  The string produced by the &lt;code>{@link&#xA;     * java.lang.String#valueOf(Object)}&lt;/code> method is translated into bytes&#xA;     * according to the platform's default character encoding, and these bytes&#xA;     * are written in exactly the manner of the &lt;code>{@link #write(int)}&lt;/code>&#xA;     * method.&#xA;     *&#xA;     * @param      obj   The &lt;code>Object&lt;/code> to be printed&#xA;     * @see        java.lang.Object#toString()&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/String.class.xmi#//@classifiers.0/@members.76"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/* Methods that do terminate lines */</comments>
        <comments>/**&#xA;     * Terminate the current line by writing the line separator string.  The&#xA;     * line separator string is defined by the system property&#xA;     * &lt;code>line.separator&lt;/code>, and is not necessarily a single newline&#xA;     * character (&lt;code>'\n'&lt;/code>).&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.23"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a boolean value and then terminate the line.  This method behaves&#xA;     * as though it invokes &lt;code>{@link #print(boolean)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x the &lt;code>boolean&lt;/code> value to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.24">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a character and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(char)}&lt;/code> and then &lt;code>{@link&#xA;     * #println()}&lt;/code>.&#xA;     *&#xA;     * @param x the &lt;code>char&lt;/code> value to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an integer and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(int)}&lt;/code> and then &lt;code>{@link&#xA;     * #println()}&lt;/code>.&#xA;     *&#xA;     * @param x the &lt;code>int&lt;/code> value to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.26">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Long"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a long integer and then terminate the line.  This method behaves&#xA;     * as though it invokes &lt;code>{@link #print(long)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x the &lt;code>long&lt;/code> value to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.27">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a floating-point number and then terminate the line.  This method&#xA;     * behaves as though it invokes &lt;code>{@link #print(float)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x the &lt;code>float&lt;/code> value to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.28">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a double-precision floating-point number and then terminate the&#xA;     * line.  This method behaves as though it invokes &lt;code>{@link&#xA;     * #print(double)}&lt;/code> and then &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x the &lt;code>double&lt;/code> value to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.29">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.39/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an array of characters and then terminate the line.  This method&#xA;     * behaves as though it invokes &lt;code>{@link #print(char[])}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x the array of &lt;code>char&lt;/code> values to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.40/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print a String and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(String)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x the &lt;code>String&lt;/code> value to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.41/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="println">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Print an Object and then terminate the line.  This method behaves as&#xA;     * though it invokes &lt;code>{@link #print(Object)}&lt;/code> and then&#xA;     * &lt;code>{@link #println()}&lt;/code>.&#xA;     *&#xA;     * @param x the &lt;code>Object&lt;/code> value to be printed&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:SynchronizedBlock">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.32">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.42/@parameters.0"/>
          </expression>
        </statements>
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </statements>
        <lockProvider xsi:type="references:IdentifierReference">
          <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
        </lockProvider>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="printf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="format">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:VariableLengthParameter" name="args">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A convenience method to write a formatted string to this writer using&#xA;     * the specified format string and arguments.  If automatic flushing is&#xA;     * enabled, calls to this method will flush the output buffer.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>out.printf(format,&#xA;     * args)&lt;/tt> behaves in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     out.format(format, args) &lt;/pre>&#xA;     *&#xA;     * @param  format&#xA;     *         A format string as described in &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>Format string syntax&lt;/a>.&#xA;     *&#xA;     * @param  args&#xA;     *         Arguments referenced by the format specifiers in the format&#xA;     *         string.  If there are more arguments than format specifiers, the&#xA;     *         extra arguments are ignored.  The number of arguments is&#xA;     *         variable and may be zero.  The maximum number of arguments is&#xA;     *         limited by the maximum dimension of a Java array as defined by&#xA;     *         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;>Java&#xA;     *         Virtual Machine Specification&lt;/a>.  The behaviour on a&#xA;     *         &lt;tt>null&lt;/tt> argument depends on the &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>conversion&lt;/a>.&#xA;     *&#xA;     * @throws  IllegalFormatException&#xA;     *          If a format string contains an illegal syntax, a format&#xA;     *          specifier that is incompatible with the given arguments,&#xA;     *          insufficient arguments given the format string, or other&#xA;     *          illegal conditions.  For specification of all possible&#xA;     *          formatting errors, see the &lt;a&#xA;     *          href=&quot;../util/Formatter.html#detail&quot;>Details&lt;/a> section of the&#xA;     *          formatter class specification.&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If the &lt;tt>format&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @return  This writer&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.45">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.43/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="printf">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="format">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:VariableLengthParameter" name="args">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * A convenience method to write a formatted string to this writer using&#xA;     * the specified format string and arguments.  If automatic flushing is&#xA;     * enabled, calls to this method will flush the output buffer.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>out.printf(l, format,&#xA;     * args)&lt;/tt> behaves in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     out.format(l, format, args) &lt;/pre>&#xA;     *&#xA;     * @param  l&#xA;     *         The {@linkplain java.util.Locale locale} to apply during&#xA;     *         formatting.  If &lt;tt>l&lt;/tt> is &lt;tt>null&lt;/tt> then no localization&#xA;     *         is applied.&#xA;     *&#xA;     * @param  format&#xA;     *         A format string as described in &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>Format string syntax&lt;/a>.&#xA;     *&#xA;     * @param  args&#xA;     *         Arguments referenced by the format specifiers in the format&#xA;     *         string.  If there are more arguments than format specifiers, the&#xA;     *         extra arguments are ignored.  The number of arguments is&#xA;     *         variable and may be zero.  The maximum number of arguments is&#xA;     *         limited by the maximum dimension of a Java array as defined by&#xA;     *         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;>Java&#xA;     *         Virtual Machine Specification&lt;/a>.  The behaviour on a&#xA;     *         &lt;tt>null&lt;/tt> argument depends on the &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>conversion&lt;/a>.&#xA;     *&#xA;     * @throws  IllegalFormatException&#xA;     *          If a format string contains an illegal syntax, a format&#xA;     *          specifier that is incompatible with the given arguments,&#xA;     *          insufficient arguments given the format string, or other&#xA;     *          illegal conditions.  For specification of all possible&#xA;     *          formatting errors, see the &lt;a&#xA;     *          href=&quot;../util/Formatter.html#detail&quot;>Details&lt;/a> section of the&#xA;     *          formatter class specification.&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If the &lt;tt>format&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @return  This writer&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.46">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.44/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="format">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:VariableLengthParameter" name="args">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a formatted string to this writer using the specified format&#xA;     * string and arguments.  If automatic flushing is enabled, calls to this&#xA;     * method will flush the output buffer.&#xA;     *&#xA;     * &lt;p> The locale always used is the one returned by {@link&#xA;     * java.util.Locale#getDefault() Locale.getDefault()}, regardless of any&#xA;     * previous invocations of other formatting methods on this object.&#xA;     *&#xA;     * @param  format&#xA;     *         A format string as described in &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>Format string syntax&lt;/a>.&#xA;     *&#xA;     * @param  args&#xA;     *         Arguments referenced by the format specifiers in the format&#xA;     *         string.  If there are more arguments than format specifiers, the&#xA;     *         extra arguments are ignored.  The number of arguments is&#xA;     *         variable and may be zero.  The maximum number of arguments is&#xA;     *         limited by the maximum dimension of a Java array as defined by&#xA;     *         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;>Java&#xA;     *         Virtual Machine Specification&lt;/a>.  The behaviour on a&#xA;     *         &lt;tt>null&lt;/tt> argument depends on the &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>conversion&lt;/a>.&#xA;     *&#xA;     * @throws  IllegalFormatException&#xA;     *          If a format string contains an illegal syntax, a format&#xA;     *          specifier that is incompatible with the given arguments,&#xA;     *          insufficient arguments given the format string, or other&#xA;     *          illegal conditions.  For specification of all possible&#xA;     *          formatting errors, see the &lt;a&#xA;     *          href=&quot;../util/Formatter.html#detail&quot;>Details&lt;/a> section of the&#xA;     *          Formatter class specification.&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If the &lt;tt>format&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @return  This writer&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13"/>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../util/Formatter.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  <children xsi:type="literals:NullLiteral"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.24"/>
                    </next>
                  </children>
                  <children xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
                  </children>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../util/Locale.class.xmi#//@classifiers.0/@members.35"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.45/@parameters.1"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Writer.class.xmi#//@classifiers.0/@members.13"/>
                </next>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </statements>
          <lockProvider xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="format">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="l">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="format">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:VariableLengthParameter" name="args">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes a formatted string to this writer using the specified format&#xA;     * string and arguments.  If automatic flushing is enabled, calls to this&#xA;     * method will flush the output buffer.&#xA;     *&#xA;     * @param  l&#xA;     *         The {@linkplain java.util.Locale locale} to apply during&#xA;     *         formatting.  If &lt;tt>l&lt;/tt> is &lt;tt>null&lt;/tt> then no localization&#xA;     *         is applied.&#xA;     *&#xA;     * @param  format&#xA;     *         A format string as described in &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>Format string syntax&lt;/a>.&#xA;     *&#xA;     * @param  args&#xA;     *         Arguments referenced by the format specifiers in the format&#xA;     *         string.  If there are more arguments than format specifiers, the&#xA;     *         extra arguments are ignored.  The number of arguments is&#xA;     *         variable and may be zero.  The maximum number of arguments is&#xA;     *         limited by the maximum dimension of a Java array as defined by&#xA;     *         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;>Java&#xA;     *         Virtual Machine Specification&lt;/a>.  The behaviour on a&#xA;     *         &lt;tt>null&lt;/tt> argument depends on the &lt;a&#xA;     *         href=&quot;../util/Formatter.html#syntax&quot;>conversion&lt;/a>.&#xA;     *&#xA;     * @throws  IllegalFormatException&#xA;     *          If a format string contains an illegal syntax, a format&#xA;     *          specifier that is incompatible with the given arguments,&#xA;     *          insufficient arguments given the format string, or other&#xA;     *          illegal conditions.  For specification of all possible&#xA;     *          formatting errors, see the &lt;a&#xA;     *          href=&quot;../util/Formatter.html#detail&quot;>Details&lt;/a> section of the&#xA;     *          formatter class specification.&#xA;     *&#xA;     * @throws  NullPointerException&#xA;     *          If the &lt;tt>format&lt;/tt> is &lt;tt>null&lt;/tt>&#xA;     *&#xA;     * @return  This writer&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:SynchronizedBlock">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13"/>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="expressions:AssignmentExpression">
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                <assignmentOperator xsi:type="operators:Assignment"/>
                <value xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../util/Formatter.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
                </value>
              </expression>
            </statement>
            <condition xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:Equal"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  <children xsi:type="literals:NullLiteral"/>
                </expression>
              </children>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:EqualityExpression">
                  <equalityOperators xsi:type="operators:NotEqual"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
                    <next xsi:type="references:MethodCall">
                      <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.24"/>
                    </next>
                  </children>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
                </expression>
              </children>
            </condition>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../util/Formatter.class.xmi#//@classifiers.0/@members.32"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.1"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.46/@parameters.2"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Writer.class.xmi#//@classifiers.0/@members.13"/>
                </next>
              </expression>
            </statement>
            <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </statements>
          <lockProvider xsi:type="references:IdentifierReference">
            <target xsi:type="members:Field" href="Writer.class.xmi#//@classifiers.0/@members.2"/>
          </lockProvider>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.52"/>
                </next>
                <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
              </next>
              <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="InterruptedIOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
        <catcheBlocks>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:BooleanLiteral" value="true"/>
            </expression>
          </statements>
          <parameter name="x">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the specified character sequence to this writer.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>out.append(csq)&lt;/tt>&#xA;     * behaves in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     out.write(csq.toString()) &lt;/pre>&#xA;     *&#xA;     * &lt;p> Depending on the specification of &lt;tt>toString&lt;/tt> for the&#xA;     * character sequence &lt;tt>csq&lt;/tt>, the entire sequence may not be&#xA;     * appended. For instance, invoking the &lt;tt>toString&lt;/tt> method of a&#xA;     * character buffer will return a subsequence whose content depends upon&#xA;     * the buffer's position and limit.&#xA;     *&#xA;     * @param  csq&#xA;     *         The character sequence to append.  If &lt;tt>csq&lt;/tt> is&#xA;     *         &lt;tt>null&lt;/tt>, then the four characters &lt;tt>&quot;null&quot;&lt;/tt> are&#xA;     *         appended to this writer.&#xA;     *&#xA;     * @return  This writer&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <arguments xsi:type="references:StringReference" value="null"/>
          </expression>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:ExpressionStatement">
          <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.47/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../lang/CharSequence.class.xmi#//@classifiers.0/@members.3"/>
              </next>
            </arguments>
          </expression>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="csq">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="start">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="end">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends a subsequence of the specified character sequence to this writer.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>out.append(csq, start,&#xA;     * end)&lt;/tt> when &lt;tt>csq&lt;/tt> is not &lt;tt>null&lt;/tt>, behaves in&#xA;     * exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     out.write(csq.subSequence(start, end).toString()) &lt;/pre>&#xA;     *&#xA;     * @param  csq&#xA;     *         The character sequence from which a subsequence will be&#xA;     *         appended.  If &lt;tt>csq&lt;/tt> is &lt;tt>null&lt;/tt>, then characters&#xA;     *         will be appended as if &lt;tt>csq&lt;/tt> contained the four&#xA;     *         characters &lt;tt>&quot;null&quot;&lt;/tt>.&#xA;     *&#xA;     * @param  start&#xA;     *         The index of the first character in the subsequence&#xA;     *&#xA;     * @param  end&#xA;     *         The index of the character following the last character in the&#xA;     *         subsequence&#xA;     *&#xA;     * @return  This writer&#xA;     *&#xA;     * @throws  IndexOutOfBoundsException&#xA;     *          If &lt;tt>start&lt;/tt> or &lt;tt>end&lt;/tt> are negative, &lt;tt>start&lt;/tt>&#xA;     *          is greater than &lt;tt>end&lt;/tt>, or &lt;tt>end&lt;/tt> is greater than&#xA;     *          &lt;tt>csq.length()&lt;/tt>&#xA;     *&#xA;     * @since  1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="../lang/CharSequence.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalExpression">
              <child xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
                <children xsi:type="literals:NullLiteral"/>
              </child>
              <expressionIf xsi:type="references:StringReference" value="null"/>
              <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
            </expression>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:InterfaceMethod" href="../lang/CharSequence.class.xmi#//@classifiers.0/@members.3"/>
              </next>
              <target xsi:type="members:InterfaceMethod" href="../lang/CharSequence.class.xmi#//@classifiers.0/@members.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.2"/>
            </next>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="append">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:Char"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Appends the specified character to this writer.&#xA;     *&#xA;     * &lt;p> An invocation of this method of the form &lt;tt>out.append(c)&lt;/tt>&#xA;     * behaves in exactly the same way as the invocation&#xA;     *&#xA;     * &lt;pre>&#xA;     *     out.write(c) &lt;/pre>&#xA;     *&#xA;     * @param  c&#xA;     *         The 16-bit character to append&#xA;     *&#xA;     * @return  This writer&#xA;     *&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Print formatted representations of objects to a text-output stream.  This&#xA; * class implements all of the &lt;tt>print&lt;/tt> methods found in {@link&#xA; * PrintStream}.  It does not contain methods for writing raw bytes, for which&#xA; * a program should use unencoded byte streams.&#xA; *&#xA; * &lt;p> Unlike the {@link PrintStream} class, if automatic flushing is enabled&#xA; * it will be done only when one of the &lt;tt>println&lt;/tt>, &lt;tt>printf&lt;/tt>, or&#xA; * &lt;tt>format&lt;/tt> methods is invoked, rather than whenever a newline character&#xA; * happens to be output.  These methods use the platform's own notion of line&#xA; * separator rather than the newline character.&#xA; *&#xA; * &lt;p> Methods in this class never throw I/O exceptions, although some of its&#xA; * constructors may.  The client may inquire as to whether any errors have&#xA; * occurred by invoking {@link #checkError checkError()}.&#xA; *&#xA; * @version &#x9;1.37, 07/16/04&#xA; * @author&#x9;Frank Yellin&#xA; * @author&#x9;Mark Reinhold&#xA; * @since&#x9;JDK1.1&#xA; */</comments>
    </annotationsAndModifiers>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Writer.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
