<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:modifiers="http://www.emftext.org/java/modifiers" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/modifiers ../../java.ecore#/11" name="Serializable.java">
  <comments>/*&#xA; * @(#)Serializable.java&#x9;1.22 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>io</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="Serializable">
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Serializability of a class is enabled by the class implementing the&#xA; * java.io.Serializable interface. Classes that do not implement this&#xA; * interface will not have any of their state serialized or&#xA; * deserialized.  All subtypes of a serializable class are themselves&#xA; * serializable.  The serialization interface has no methods or fields&#xA; * and serves only to identify the semantics of being serializable. &lt;p>&#xA; *&#xA; * To allow subtypes of non-serializable classes to be serialized, the&#xA; * subtype may assume responsibility for saving and restoring the&#xA; * state of the supertype's public, protected, and (if accessible)&#xA; * package fields.  The subtype may assume this responsibility only if&#xA; * the class it extends has an accessible no-arg constructor to&#xA; * initialize the class's state.  It is an error to declare a class&#xA; * Serializable if this is not the case.  The error will be detected at runtime. &lt;p>&#xA; *&#xA; * During deserialization, the fields of non-serializable classes will&#xA; * be initialized using the public or protected no-arg constructor of&#xA; * the class.  A no-arg constructor must be accessible to the subclass&#xA; * that is serializable.  The fields of serializable subclasses will&#xA; * be restored from the stream. &lt;p>&#xA; *&#xA; * When traversing a graph, an object may be encountered that does not&#xA; * support the Serializable interface. In this case the&#xA; * NotSerializableException will be thrown and will identify the class&#xA; * of the non-serializable object. &lt;p>&#xA; *&#xA; * Classes that require special handling during the serialization and&#xA; * deserialization process must implement special methods with these exact&#xA; * signatures: &lt;p>&#xA; *&#xA; * &lt;PRE>&#xA; * private void writeObject(java.io.ObjectOutputStream out)&#xA; *     throws IOException&#xA; * private void readObject(java.io.ObjectInputStream in)&#xA; *     throws IOException, ClassNotFoundException;&#xA; * &lt;/PRE>&lt;p>&#xA; *&#xA; * The writeObject method is responsible for writing the state of the&#xA; * object for its particular class so that the corresponding&#xA; * readObject method can restore it.  The default mechanism for saving&#xA; * the Object's fields can be invoked by calling&#xA; * out.defaultWriteObject. The method does not need to concern&#xA; * itself with the state belonging to its superclasses or subclasses.&#xA; * State is saved by writing the individual fields to the&#xA; * ObjectOutputStream using the writeObject method or by using the&#xA; * methods for primitive data types supported by DataOutput. &lt;p>&#xA; *&#xA; * The readObject method is responsible for reading from the stream and&#xA; * restoring the classes fields. It may call in.defaultReadObject to invoke&#xA; * the default mechanism for restoring the object's non-static and non-transient&#xA; * fields.  The defaultReadObject method uses information in the stream to&#xA; * assign the fields of the object saved in the stream with the correspondingly&#xA; * named fields in the current object.  This handles the case when the class&#xA; * has evolved to add new fields. The method does not need to concern&#xA; * itself with the state belonging to its superclasses or subclasses.&#xA; * State is saved by writing the individual fields to the&#xA; * ObjectOutputStream using the writeObject method or by using the&#xA; * methods for primitive data types supported by DataOutput. &lt;p>&#xA; *&#xA; * Serializable classes that need to designate an alternative object to be&#xA; * used when writing an object to the stream should implement this&#xA; * special method with the exact signature: &lt;p>&#xA; *&#xA; * &lt;PRE>&#xA; * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;&#xA; * &lt;/PRE>&lt;p>&#xA; *&#xA; * This writeReplace method is invoked by serialization if the method&#xA; * exists and it would be accessible from a method defined within the&#xA; * class of the object being serialized. Thus, the method can have private,&#xA; * protected and package-private access. Subclass access to this method&#xA; * follows java accessibility rules. &lt;p>&#xA; *&#xA; * Classes that need to designate a replacement when an instance of it&#xA; * is read from the stream should implement this special method with the&#xA; * exact signature.&lt;p>&#xA; *&#xA; * &lt;PRE>&#xA; * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;&#xA; * &lt;/PRE>&lt;p>&#xA; *&#xA; * This readResolve method follows the same invocation rules and&#xA; * accessibility rules as writeReplace.&lt;p>&#xA; *&#xA; * The serialization runtime associates with each serializable class a version&#xA; * number, called a serialVersionUID, which is used during deserialization to&#xA; * verify that the sender and receiver of a serialized object have loaded&#xA; * classes for that object that are compatible with respect to serialization.&#xA; * If the receiver has loaded a class for the object that has a different&#xA; * serialVersionUID than that of the corresponding sender's class, then&#xA; * deserialization will result in an {@link InvalidClassException}.  A&#xA; * serializable class can declare its own serialVersionUID explicitly by&#xA; * declaring a field named &lt;code>&quot;serialVersionUID&quot;&lt;/code> that must be static,&#xA; * final, and of type &lt;code>long&lt;/code>:&lt;p>&#xA; *&#xA; * &lt;PRE>&#xA; * ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;&#xA; * &lt;/PRE>&#xA; *&#xA; * If a serializable class does not explicitly declare a serialVersionUID, then&#xA; * the serialization runtime will calculate a default serialVersionUID value&#xA; * for that class based on various aspects of the class, as described in the&#xA; * Java(TM) Object Serialization Specification.  However, it is &lt;em>strongly&#xA; * recommended&lt;/em> that all serializable classes explicitly declare&#xA; * serialVersionUID values, since the default serialVersionUID computation is&#xA; * highly sensitive to class details that may vary depending on compiler&#xA; * implementations, and can thus result in unexpected&#xA; * &lt;code>InvalidClassException&lt;/code>s during deserialization.  Therefore, to&#xA; * guarantee a consistent serialVersionUID value across different java compiler&#xA; * implementations, a serializable class must declare an explicit&#xA; * serialVersionUID value.  It is also strongly advised that explicit&#xA; * serialVersionUID declarations use the &lt;code>private&lt;/code> modifier where&#xA; * possible, since such declarations apply only to the immediately declaring&#xA; * class--serialVersionUID fields are not useful as inherited members.&#xA; *&#xA; * @author  unascribed&#xA; * @version 1.22, 12/19/03&#xA; * @see java.io.ObjectOutputStream&#xA; * @see java.io.ObjectInputStream&#xA; * @see java.io.ObjectOutput&#xA; * @see java.io.ObjectInput&#xA; * @see java.io.Externalizable&#xA; * @since   JDK1.1&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
