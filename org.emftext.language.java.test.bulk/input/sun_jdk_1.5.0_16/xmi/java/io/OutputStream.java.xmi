<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16 http://www.emftext.org/java/variables ../../java.ecore#/17" name="OutputStream.java">
  <comments>/*&#xA; * @(#)OutputStream.java&#x9;1.29 04/04/21&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>io</namespaces>
  <classifiers xsi:type="classifiers:Class" name="OutputStream">
    <members xsi:type="members:InterfaceMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes the specified byte to this output stream. The general &#xA;     * contract for &lt;code>write&lt;/code> is that one byte is written &#xA;     * to the output stream. The byte to be written is the eight &#xA;     * low-order bits of the argument &lt;code>b&lt;/code>. The 24 &#xA;     * high-order bits of &lt;code>b&lt;/code> are ignored.&#xA;     * &lt;p>&#xA;     * Subclasses of &lt;code>OutputStream&lt;/code> must provide an &#xA;     * implementation for this method. &#xA;     *&#xA;     * @param      b   the &lt;code>byte&lt;/code>.&#xA;     * @exception  IOException  if an I/O error occurs. In particular, &#xA;     *             an &lt;code>IOException&lt;/code> may be thrown if the &#xA;     *             output stream has been closed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes &lt;code>b.length&lt;/code> bytes from the specified byte array &#xA;     * to this output stream. The general contract for &lt;code>write(b)&lt;/code> &#xA;     * is that it should have exactly the same effect as the call &#xA;     * &lt;code>write(b, 0, b.length)&lt;/code>.&#xA;     *&#xA;     * @param      b   the data.&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     * @see        java.io.OutputStream#write(byte[], int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.2">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0">
            <next xsi:type="references:IdentifierReference"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="write">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Writes &lt;code>len&lt;/code> bytes from the specified byte array &#xA;     * starting at offset &lt;code>off&lt;/code> to this output stream. &#xA;     * The general contract for &lt;code>write(b, off, len)&lt;/code> is that &#xA;     * some of the bytes in the array &lt;code>b&lt;/code> are written to the &#xA;     * output stream in order; element &lt;code>b[off]&lt;/code> is the first &#xA;     * byte written and &lt;code>b[off+len-1]&lt;/code> is the last byte written &#xA;     * by this operation.&#xA;     * &lt;p>&#xA;     * The &lt;code>write&lt;/code> method of &lt;code>OutputStream&lt;/code> calls &#xA;     * the write method of one argument on each of the bytes to be &#xA;     * written out. Subclasses are encouraged to override this method and &#xA;     * provide a more efficient implementation. &#xA;     * &lt;p>&#xA;     * If &lt;code>b&lt;/code> is &lt;code>null&lt;/code>, a &#xA;     * &lt;code>NullPointerException&lt;/code> is thrown.&#xA;     * &lt;p>&#xA;     * If &lt;code>off&lt;/code> is negative, or &lt;code>len&lt;/code> is negative, or &#xA;     * &lt;code>off+len&lt;/code> is greater than the length of the array &#xA;     * &lt;code>b&lt;/code>, then an &lt;tt>IndexOutOfBoundsException&lt;/tt> is thrown.&#xA;     *&#xA;     * @param      b     the data.&#xA;     * @param      off   the start offset in the data.&#xA;     * @param      len   the number of bytes to write.&#xA;     * @exception  IOException  if an I/O error occurs. In particular, &#xA;     *             an &lt;code>IOException&lt;/code> is thrown if the output &#xA;     *             stream is closed.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/IndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
              </throwable>
            </statements>
          </statement>
          <condition xsi:type="expressions:ConditionalOrExpression">
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0">
                  <next xsi:type="references:IdentifierReference"/>
                </children>
                <relationOperators xsi:type="operators:GreaterThan"/>
              </expression>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:RelationExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </expression>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </expression>
            </children>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return"/>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </condition>
          </elseStatement>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.0">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0">
                <arraySelectors>
                  <position xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.1/@init"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </position>
                </arraySelectors>
              </arguments>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.1/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="flush">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Flushes this output stream and forces any buffered output bytes &#xA;     * to be written out. The general contract of &lt;code>flush&lt;/code> is &#xA;     * that calling it is an indication that, if any bytes previously &#xA;     * written have been buffered by the implementation of the output &#xA;     * stream, such bytes should immediately be written to their &#xA;     * intended destination.&#xA;     * &lt;p>&#xA;     * If the intended destination of this stream is an abstraction provided by&#xA;     * the underlying operating system, for example a file, then flushing the&#xA;     * stream guarantees only that bytes previously written to the stream are&#xA;     * passed to the operating system for writing; it does not guarantee that&#xA;     * they are actually written to a physical device such as a disk drive.&#xA;     * &lt;p>&#xA;     * The &lt;code>flush&lt;/code> method of &lt;code>OutputStream&lt;/code> does nothing.&#xA;     *&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="close">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Closes this output stream and releases any system resources &#xA;     * associated with this stream. The general contract of &lt;code>close&lt;/code> &#xA;     * is that it closes the output stream. A closed stream cannot perform &#xA;     * output operations and cannot be reopened.&#xA;     * &lt;p>&#xA;     * The &lt;code>close&lt;/code> method of &lt;code>OutputStream&lt;/code> does nothing.&#xA;     *&#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This abstract class is the superclass of all classes representing &#xA; * an output stream of bytes. An output stream accepts output bytes &#xA; * and sends them to some sink.&#xA; * &lt;p>&#xA; * Applications that need to define a subclass of &#xA; * &lt;code>OutputStream&lt;/code> must always provide at least a method &#xA; * that writes one byte of output.&#xA; *&#xA; * @author  Arthur van Hoff&#xA; * @version 1.29, 04/21/04&#xA; * @see     java.io.BufferedOutputStream&#xA; * @see     java.io.ByteArrayOutputStream&#xA; * @see     java.io.DataOutputStream&#xA; * @see     java.io.FilterOutputStream&#xA; * @see     java.io.InputStream&#xA; * @see     java.io.OutputStream#write(int)&#xA; * @since   JDK1.0&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Closeable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Flushable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
