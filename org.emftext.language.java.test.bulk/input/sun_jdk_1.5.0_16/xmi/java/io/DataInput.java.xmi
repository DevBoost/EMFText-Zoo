<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/types ../../java.ecore#/16" name="DataInput.java">
  <comments>/*&#xA; * @(#)DataInput.java&#x9;1.23 04/06/03&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>io</namespaces>
  <classifiers xsi:type="classifiers:Interface" name="DataInput">
    <members xsi:type="members:InterfaceMethod" name="readFully">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     * Reads some bytes from an input&#xA;     * stream and stores them into the buffer&#xA;     * array &lt;code>b&lt;/code>. The number of bytes&#xA;     * read is equal&#xA;     * to the length of &lt;code>b&lt;/code>.&#xA;     * &lt;p>&#xA;     * This method blocks until one of the&#xA;     * following conditions occurs:&lt;p>&#xA;     * &lt;ul>&#xA;     * &lt;li>&lt;code>b.length&lt;/code>&#xA;     * bytes of input data are available, in which&#xA;     * case a normal return is made.&#xA;     *&#xA;     * &lt;li>End of&#xA;     * file is detected, in which case an &lt;code>EOFException&lt;/code>&#xA;     * is thrown.&#xA;     *&#xA;     * &lt;li>An I/O error occurs, in&#xA;     * which case an &lt;code>IOException&lt;/code> other&#xA;     * than &lt;code>EOFException&lt;/code> is thrown.&#xA;     * &lt;/ul>&#xA;     * &lt;p>&#xA;     * If &lt;code>b&lt;/code> is &lt;code>null&lt;/code>,&#xA;     * a &lt;code>NullPointerException&lt;/code> is thrown.&#xA;     * If &lt;code>b.length&lt;/code> is zero, then&#xA;     * no bytes are read. Otherwise, the first&#xA;     * byte read is stored into element &lt;code>b[0]&lt;/code>,&#xA;     * the next one into &lt;code>b[1]&lt;/code>, and&#xA;     * so on.&#xA;     * If an exception is thrown from&#xA;     * this method, then it may be that some but&#xA;     * not all bytes of &lt;code>b&lt;/code> have been&#xA;     * updated with data from the input stream.&#xA;     *&#xA;     * @param     b   the buffer into which the data is read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readFully">
      <typeReference xsi:type="types:Void">
        <comments>/**&#xA;     *&#xA;     * Reads &lt;code>len&lt;/code>&#xA;     * bytes from&#xA;     * an input stream.&#xA;     * &lt;p>&#xA;     * This method&#xA;     * blocks until one of the following conditions&#xA;     * occurs:&lt;p>&#xA;     * &lt;ul>&#xA;     * &lt;li>&lt;code>len&lt;/code> bytes&#xA;     * of input data are available, in which case&#xA;     * a normal return is made.&#xA;     *&#xA;     * &lt;li>End of file&#xA;     * is detected, in which case an &lt;code>EOFException&lt;/code>&#xA;     * is thrown.&#xA;     *&#xA;     * &lt;li>An I/O error occurs, in&#xA;     * which case an &lt;code>IOException&lt;/code> other&#xA;     * than &lt;code>EOFException&lt;/code> is thrown.&#xA;     * &lt;/ul>&#xA;     * &lt;p>&#xA;     * If &lt;code>b&lt;/code> is &lt;code>null&lt;/code>,&#xA;     * a &lt;code>NullPointerException&lt;/code> is thrown.&#xA;     * If &lt;code>off&lt;/code> is negative, or &lt;code>len&lt;/code>&#xA;     * is negative, or &lt;code>off+len&lt;/code> is&#xA;     * greater than the length of the array &lt;code>b&lt;/code>,&#xA;     * then an &lt;code>IndexOutOfBoundsException&lt;/code>&#xA;     * is thrown.&#xA;     * If &lt;code>len&lt;/code> is zero,&#xA;     * then no bytes are read. Otherwise, the first&#xA;     * byte read is stored into element &lt;code>b[off]&lt;/code>,&#xA;     * the next one into &lt;code>b[off+1]&lt;/code>,&#xA;     * and so on. The number of bytes read is,&#xA;     * at most, equal to &lt;code>len&lt;/code>.&#xA;     *&#xA;     * @param     b   the buffer into which the data is read.&#xA;     * @param off  an int specifying the offset into the data.&#xA;     * @param len  an int specifying the number of bytes to read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="off">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="len">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="skipBytes">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Makes an attempt to skip over&#xA;     * &lt;code>n&lt;/code> bytes&#xA;     * of data from the input&#xA;     * stream, discarding the skipped bytes. However,&#xA;     * it may skip&#xA;     * over some smaller number of&#xA;     * bytes, possibly zero. This may result from&#xA;     * any of a&#xA;     * number of conditions; reaching&#xA;     * end of file before &lt;code>n&lt;/code> bytes&#xA;     * have been skipped is&#xA;     * only one possibility.&#xA;     * This method never throws an &lt;code>EOFException&lt;/code>.&#xA;     * The actual&#xA;     * number of bytes skipped is returned.&#xA;     *&#xA;     * @param      n   the number of bytes to be skipped.&#xA;     * @return     the number of bytes actually skipped.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="n">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readBoolean">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Reads one input byte and returns&#xA;     * &lt;code>true&lt;/code> if that byte is nonzero,&#xA;     * &lt;code>false&lt;/code> if that byte is zero.&#xA;     * This method is suitable for reading&#xA;     * the byte written by the &lt;code>writeBoolean&lt;/code>&#xA;     * method of interface &lt;code>DataOutput&lt;/code>.&#xA;     *&#xA;     * @return     the &lt;code>boolean&lt;/code> value read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readByte">
      <typeReference xsi:type="types:Byte">
        <comments>/**&#xA;     * Reads and returns one input byte.&#xA;     * The byte is treated as a signed value in&#xA;     * the range &lt;code>-128&lt;/code> through &lt;code>127&lt;/code>,&#xA;     * inclusive.&#xA;     * This method is suitable for&#xA;     * reading the byte written by the &lt;code>writeByte&lt;/code>&#xA;     * method of interface &lt;code>DataOutput&lt;/code>.&#xA;     *&#xA;     * @return     the 8-bit value read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readUnsignedByte">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Reads one input byte, zero-extends&#xA;     * it to type &lt;code>int&lt;/code>, and returns&#xA;     * the result, which is therefore in the range&#xA;     * &lt;code>0&lt;/code>&#xA;     * through &lt;code>255&lt;/code>.&#xA;     * This method is suitable for reading&#xA;     * the byte written by the &lt;code>writeByte&lt;/code>&#xA;     * method of interface &lt;code>DataOutput&lt;/code>&#xA;     * if the argument to &lt;code>writeByte&lt;/code>&#xA;     * was intended to be a value in the range&#xA;     * &lt;code>0&lt;/code> through &lt;code>255&lt;/code>.&#xA;     *&#xA;     * @return     the unsigned 8-bit value read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readShort">
      <typeReference xsi:type="types:Short">
        <comments>/**&#xA;     * Reads two input bytes and returns&#xA;     * a &lt;code>short&lt;/code> value. Let &lt;code>a&lt;/code>&#xA;     * be the first byte read and &lt;code>b&lt;/code>&#xA;     * be the second byte. The value&#xA;     * returned&#xA;     * is:&#xA;     * &lt;p>&lt;pre>&lt;code>(short)((a &amp;lt;&amp;lt; 8) | (b &amp;amp; 0xff))&#xA;     * &lt;/code>&lt;/pre>&#xA;     * This method&#xA;     * is suitable for reading the bytes written&#xA;     * by the &lt;code>writeShort&lt;/code> method of&#xA;     * interface &lt;code>DataOutput&lt;/code>.&#xA;     *&#xA;     * @return     the 16-bit value read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readUnsignedShort">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Reads two input bytes and returns&#xA;     * an &lt;code>int&lt;/code> value in the range &lt;code>0&lt;/code>&#xA;     * through &lt;code>65535&lt;/code>. Let &lt;code>a&lt;/code>&#xA;     * be the first byte read and&#xA;     * &lt;code>b&lt;/code>&#xA;     * be the second byte. The value returned is:&#xA;     * &lt;p>&lt;pre>&lt;code>(((a &amp;amp; 0xff) &amp;lt;&amp;lt; 8) | (b &amp;amp; 0xff))&#xA;     * &lt;/code>&lt;/pre>&#xA;     * This method is suitable for reading the bytes&#xA;     * written by the &lt;code>writeShort&lt;/code> method&#xA;     * of interface &lt;code>DataOutput&lt;/code>  if&#xA;     * the argument to &lt;code>writeShort&lt;/code>&#xA;     * was intended to be a value in the range&#xA;     * &lt;code>0&lt;/code> through &lt;code>65535&lt;/code>.&#xA;     *&#xA;     * @return     the unsigned 16-bit value read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readChar">
      <typeReference xsi:type="types:Char">
        <comments>/**&#xA;     * Reads an input &lt;code>char&lt;/code> and returns the &lt;code>char&lt;/code> value.&#xA;     * A Unicode &lt;code>char&lt;/code> is made up of two bytes.&#xA;     * Let &lt;code>a&lt;/code>&#xA;     * be the first byte read and &lt;code>b&lt;/code>&#xA;     * be the second byte. The value&#xA;     * returned is:&#xA;     * &lt;p>&lt;pre>&lt;code>(char)((a &amp;lt;&amp;lt; 8) | (b &amp;amp; 0xff))&#xA;     * &lt;/code>&lt;/pre>&#xA;     * This method&#xA;     * is suitable for reading bytes written by&#xA;     * the &lt;code>writeChar&lt;/code> method of interface&#xA;     * &lt;code>DataOutput&lt;/code>.&#xA;     *&#xA;     * @return     the Unicode &lt;code>char&lt;/code> read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readInt">
      <typeReference xsi:type="types:Int">
        <comments>/**&#xA;     * Reads four input bytes and returns an&#xA;     * &lt;code>int&lt;/code> value. Let &lt;code>a&lt;/code>&#xA;     * be the first byte read, &lt;code>b&lt;/code> be&#xA;     * the second byte, &lt;code>c&lt;/code> be the third&#xA;     * byte,&#xA;     * and &lt;code>d&lt;/code> be the fourth&#xA;     * byte. The value returned is:&#xA;     * &lt;p>&lt;pre>&#xA;     * &lt;code>&#xA;     * (((a &amp;amp; 0xff) &amp;lt;&amp;lt; 24) | ((b &amp;amp; 0xff) &amp;lt;&amp;lt; 16) |&#xA;     * &amp;#32;((c &amp;amp; 0xff) &amp;lt;&amp;lt; 8) | (d &amp;amp; 0xff))&#xA;     * &lt;/code>&lt;/pre>&#xA;     * This method is suitable&#xA;     * for reading bytes written by the &lt;code>writeInt&lt;/code>&#xA;     * method of interface &lt;code>DataOutput&lt;/code>.&#xA;     *&#xA;     * @return     the &lt;code>int&lt;/code> value read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readLong">
      <typeReference xsi:type="types:Long">
        <comments>/**&#xA;     * Reads eight input bytes and returns&#xA;     * a &lt;code>long&lt;/code> value. Let &lt;code>a&lt;/code>&#xA;     * be the first byte read, &lt;code>b&lt;/code> be&#xA;     * the second byte, &lt;code>c&lt;/code> be the third&#xA;     * byte, &lt;code>d&lt;/code>&#xA;     * be the fourth byte,&#xA;     * &lt;code>e&lt;/code> be the fifth byte, &lt;code>f&lt;/code>&#xA;     * be the sixth byte, &lt;code>g&lt;/code> be the&#xA;     * seventh byte,&#xA;     * and &lt;code>h&lt;/code> be the&#xA;     * eighth byte. The value returned is:&#xA;     * &lt;p>&lt;pre> &lt;code>&#xA;     * (((long)(a &amp;amp; 0xff) &amp;lt;&amp;lt; 56) |&#xA;     *  ((long)(b &amp;amp; 0xff) &amp;lt;&amp;lt; 48) |&#xA;     *  ((long)(c &amp;amp; 0xff) &amp;lt;&amp;lt; 40) |&#xA;     *  ((long)(d &amp;amp; 0xff) &amp;lt;&amp;lt; 32) |&#xA;     *  ((long)(e &amp;amp; 0xff) &amp;lt;&amp;lt; 24) |&#xA;     *  ((long)(f &amp;amp; 0xff) &amp;lt;&amp;lt; 16) |&#xA;     *  ((long)(g &amp;amp; 0xff) &amp;lt;&amp;lt;  8) |&#xA;     *  ((long)(h &amp;amp; 0xff)))&#xA;     * &lt;/code>&lt;/pre>&#xA;     * &lt;p>&#xA;     * This method is suitable&#xA;     * for reading bytes written by the &lt;code>writeLong&lt;/code>&#xA;     * method of interface &lt;code>DataOutput&lt;/code>.&#xA;     *&#xA;     * @return     the &lt;code>long&lt;/code> value read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readFloat">
      <typeReference xsi:type="types:Float">
        <comments>/**&#xA;     * Reads four input bytes and returns&#xA;     * a &lt;code>float&lt;/code> value. It does this&#xA;     * by first constructing an &lt;code>int&lt;/code>&#xA;     * value in exactly the manner&#xA;     * of the &lt;code>readInt&lt;/code>&#xA;     * method, then converting this &lt;code>int&lt;/code>&#xA;     * value to a &lt;code>float&lt;/code> in&#xA;     * exactly the manner of the method &lt;code>Float.intBitsToFloat&lt;/code>.&#xA;     * This method is suitable for reading&#xA;     * bytes written by the &lt;code>writeFloat&lt;/code>&#xA;     * method of interface &lt;code>DataOutput&lt;/code>.&#xA;     *&#xA;     * @return     the &lt;code>float&lt;/code> value read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readDouble">
      <typeReference xsi:type="types:Double">
        <comments>/**&#xA;     * Reads eight input bytes and returns&#xA;     * a &lt;code>double&lt;/code> value. It does this&#xA;     * by first constructing a &lt;code>long&lt;/code>&#xA;     * value in exactly the manner&#xA;     * of the &lt;code>readlong&lt;/code>&#xA;     * method, then converting this &lt;code>long&lt;/code>&#xA;     * value to a &lt;code>double&lt;/code> in exactly&#xA;     * the manner of the method &lt;code>Double.longBitsToDouble&lt;/code>.&#xA;     * This method is suitable for reading&#xA;     * bytes written by the &lt;code>writeDouble&lt;/code>&#xA;     * method of interface &lt;code>DataOutput&lt;/code>.&#xA;     *&#xA;     * @return     the &lt;code>double&lt;/code> value read.&#xA;     * @exception  EOFException  if this stream reaches the end before reading&#xA;     *               all the bytes.&#xA;     * @exception  IOException   if an I/O error occurs.&#xA;     */</comments>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readLine">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Reads the next line of text from the input stream.&#xA;     * It reads successive bytes, converting&#xA;     * each byte separately into a character,&#xA;     * until it encounters a line terminator or&#xA;     * end of&#xA;     * file; the characters read are then&#xA;     * returned as a &lt;code>String&lt;/code>. Note&#xA;     * that because this&#xA;     * method processes bytes,&#xA;     * it does not support input of the full Unicode&#xA;     * character set.&#xA;     * &lt;p>&#xA;     * If end of file is encountered&#xA;     * before even one byte can be read, then &lt;code>null&lt;/code>&#xA;     * is returned. Otherwise, each byte that is&#xA;     * read is converted to type &lt;code>char&lt;/code>&#xA;     * by zero-extension. If the character &lt;code>'\n'&lt;/code>&#xA;     * is encountered, it is discarded and reading&#xA;     * ceases. If the character &lt;code>'\r'&lt;/code>&#xA;     * is encountered, it is discarded and, if&#xA;     * the following byte converts &amp;#32;to the&#xA;     * character &lt;code>'\n'&lt;/code>, then that is&#xA;     * discarded also; reading then ceases. If&#xA;     * end of file is encountered before either&#xA;     * of the characters &lt;code>'\n'&lt;/code> and&#xA;     * &lt;code>'\r'&lt;/code> is encountered, reading&#xA;     * ceases. Once reading has ceased, a &lt;code>String&lt;/code>&#xA;     * is returned that contains all the characters&#xA;     * read and not discarded, taken in order.&#xA;     * Note that every character in this string&#xA;     * will have a value less than &lt;code>&amp;#92;u0100&lt;/code>,&#xA;     * that is, &lt;code>(char)256&lt;/code>.&#xA;     *&#xA;     * @return the next line of text from the input stream,&#xA;     *         or &lt;CODE>null&lt;/CODE> if the end of file is&#xA;     *         encountered before a byte can be read. &#xA;     * @exception  IOException  if an I/O error occurs.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <members xsi:type="members:InterfaceMethod" name="readUTF">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Reads in a string that has been encoded using a&#xA;     * &lt;a href=&quot;#modified-utf-8&quot;>modified UTF-8&lt;/a>&#xA;     * format.&#xA;     * The general contract of &lt;code>readUTF&lt;/code>&#xA;     * is that it reads a representation of a Unicode&#xA;     * character string encoded in modified&#xA;     * UTF-8 format; this string of characters&#xA;     * is then returned as a &lt;code>String&lt;/code>.&#xA;     * &lt;p>&#xA;     * First, two bytes are read and used to&#xA;     * construct an unsigned 16-bit integer in&#xA;     * exactly the manner of the &lt;code>readUnsignedShort&lt;/code>&#xA;     * method . This integer value is called the&#xA;     * &lt;i>UTF length&lt;/i> and specifies the number&#xA;     * of additional bytes to be read. These bytes&#xA;     * are then converted to characters by considering&#xA;     * them in groups. The length of each group&#xA;     * is computed from the value of the first&#xA;     * byte of the group. The byte following a&#xA;     * group, if any, is the first byte of the&#xA;     * next group.&#xA;     * &lt;p>&#xA;     * If the first byte of a group&#xA;     * matches the bit pattern &lt;code>0xxxxxxx&lt;/code>&#xA;     * (where &lt;code>x&lt;/code> means &quot;may be &lt;code>0&lt;/code>&#xA;     * or &lt;code>1&lt;/code>&quot;), then the group consists&#xA;     * of just that byte. The byte is zero-extended&#xA;     * to form a character.&#xA;     * &lt;p>&#xA;     * If the first byte&#xA;     * of a group matches the bit pattern &lt;code>110xxxxx&lt;/code>,&#xA;     * then the group consists of that byte &lt;code>a&lt;/code>&#xA;     * and a second byte &lt;code>b&lt;/code>. If there&#xA;     * is no byte &lt;code>b&lt;/code> (because byte&#xA;     * &lt;code>a&lt;/code> was the last of the bytes&#xA;     * to be read), or if byte &lt;code>b&lt;/code> does&#xA;     * not match the bit pattern &lt;code>10xxxxxx&lt;/code>,&#xA;     * then a &lt;code>UTFDataFormatException&lt;/code>&#xA;     * is thrown. Otherwise, the group is converted&#xA;     * to the character:&lt;p>&#xA;     * &lt;pre>&lt;code>(char)(((a&amp;amp; 0x1F) &amp;lt;&amp;lt; 6) | (b &amp;amp; 0x3F))&#xA;     * &lt;/code>&lt;/pre>&#xA;     * If the first byte of a group&#xA;     * matches the bit pattern &lt;code>1110xxxx&lt;/code>,&#xA;     * then the group consists of that byte &lt;code>a&lt;/code>&#xA;     * and two more bytes &lt;code>b&lt;/code> and &lt;code>c&lt;/code>.&#xA;     * If there is no byte &lt;code>c&lt;/code> (because&#xA;     * byte &lt;code>a&lt;/code> was one of the last&#xA;     * two of the bytes to be read), or either&#xA;     * byte &lt;code>b&lt;/code> or byte &lt;code>c&lt;/code>&#xA;     * does not match the bit pattern &lt;code>10xxxxxx&lt;/code>,&#xA;     * then a &lt;code>UTFDataFormatException&lt;/code>&#xA;     * is thrown. Otherwise, the group is converted&#xA;     * to the character:&lt;p>&#xA;     * &lt;pre>&lt;code>&#xA;     * (char)(((a &amp;amp; 0x0F) &amp;lt;&amp;lt; 12) | ((b &amp;amp; 0x3F) &amp;lt;&amp;lt; 6) | (c &amp;amp; 0x3F))&#xA;     * &lt;/code>&lt;/pre>&#xA;     * If the first byte of a group matches the&#xA;     * pattern &lt;code>1111xxxx&lt;/code> or the pattern&#xA;     * &lt;code>10xxxxxx&lt;/code>, then a &lt;code>UTFDataFormatException&lt;/code>&#xA;     * is thrown.&#xA;     * &lt;p>&#xA;     * If end of file is encountered&#xA;     * at any time during this entire process,&#xA;     * then an &lt;code>EOFException&lt;/code> is thrown.&#xA;     * &lt;p>&#xA;     * After every group has been converted to&#xA;     * a character by this process, the characters&#xA;     * are gathered, in the same order in which&#xA;     * their corresponding groups were read from&#xA;     * the input stream, to form a &lt;code>String&lt;/code>,&#xA;     * which is returned.&#xA;     * &lt;p>&#xA;     * The &lt;code>writeUTF&lt;/code>&#xA;     * method of interface &lt;code>DataOutput&lt;/code>&#xA;     * may be used to write data that is suitable&#xA;     * for reading by this method.&#xA;     * @return     a Unicode string.&#xA;     * @exception  EOFException            if this stream reaches the end&#xA;     *               before reading all the bytes.&#xA;     * @exception  IOException             if an I/O error occurs.&#xA;     * @exception  UTFDataFormatException  if the bytes do not represent a&#xA;     *               valid modified UTF-8 encoding of a string.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="IOException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>DataInput&lt;/code> interface provides&#xA; * for reading bytes from a binary stream and&#xA; * reconstructing from them data in any of&#xA; * the Java primitive types. There is also&#xA; * a&#xA; * facility for reconstructing a &lt;code>String&lt;/code>&#xA; * from data in&#xA; * &lt;a href=&quot;#modified-utf-8&quot;>modified UTF-8&lt;/a>&#xA; * format.&#xA; * &lt;p>&#xA; * It is generally true of all the reading&#xA; * routines in this interface that if end of&#xA; * file is reached before the desired number&#xA; * of bytes has been read, an &lt;code>EOFException&lt;/code>&#xA; * (which is a kind of &lt;code>IOException&lt;/code>)&#xA; * is thrown. If any byte cannot be read for&#xA; * any reason other than end of file, an &lt;code>IOException&lt;/code>&#xA; * other than &lt;code>EOFException&lt;/code> is&#xA; * thrown. In particular, an &lt;code>IOException&lt;/code>&#xA; * may be thrown if the input stream has been&#xA; * closed.&#xA; *&#xA; * &lt;h4>&lt;a name=&quot;modified-utf-8&quot;>Modified UTF-8&lt;/a>&lt;/h4>&#xA; * &lt;p>&#xA; * Implementations of the DataInput and DataOutput interfaces represent&#xA; * Unicode strings in a format that is a slight modification of UTF-8.&#xA; * (For information regarding the standard UTF-8 format, see section&#xA; * &lt;i>3.9 Unicode Encoding Forms&lt;/i> of &lt;i>The Unicode Standard, Version&#xA; * 4.0&lt;/i>).&#xA; * Note that in the following tables, the most significant bit appears in the&#xA; * far left-hand column.&#xA; * &lt;p>&#xA; * All characters in the range &lt;code>'&amp;#92;u0001'&lt;/code> to&#xA; * &lt;code>'&amp;#92;u007F'&lt;/code> are represented by a single byte:&#xA; *&#xA; * &lt;blockquote>&#xA; *   &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;8&quot; width=&quot;50%&quot;&#xA; *          summary=&quot;Bit values and bytes&quot;>&#xA; *     &lt;tr>&#xA; *       &lt;td>&lt;/td>&#xA; *       &lt;th id=&quot;bit&quot;>Bit Values&lt;/th>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;th id=&quot;byte1&quot;>Byte 1&lt;/th>&#xA; *       &lt;td>&#xA; *         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;>&#xA; *           &lt;tr>&#xA; *             &lt;td width=&quot;12%&quot;>&lt;center>0&lt;/center>&#xA; *             &lt;td colspan=&quot;7&quot;>&lt;center>bits 6-0&lt;/center>&#xA; *           &lt;/tr>&#xA; *         &lt;/table>&#xA; *       &lt;/td>&#xA; *     &lt;/tr>&#xA; *   &lt;/table>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>&#xA; * The null character &lt;code>'&amp;#92;u0000'&lt;/code> and characters in the&#xA; * range &lt;code>'&amp;#92;u0080'&lt;/code> to &lt;code>'&amp;#92;u07FF'&lt;/code> are&#xA; * represented by a pair of bytes:&#xA; *&#xA; * &lt;blockquote>&#xA; *   &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;8&quot; width=&quot;50%&quot;&#xA; *          summary=&quot;Bit values and bytes&quot;>&#xA; *     &lt;tr>&#xA; *       &lt;td>&lt;/td>&#xA; *       &lt;th id=&quot;bit&quot;>Bit Values&lt;/th>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;th id=&quot;byte1&quot;>Byte 1&lt;/th>&#xA; *       &lt;td>&#xA; *         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;>&#xA; *           &lt;tr>&#xA; *             &lt;td width=&quot;12%&quot;>&lt;center>1&lt;/center>&#xA; *             &lt;td width=&quot;13%&quot;>&lt;center>1&lt;/center>&#xA; *             &lt;td width=&quot;12%&quot;>&lt;center>0&lt;/center>&#xA; *             &lt;td colspan=&quot;5&quot;>&lt;center>bits 10-6&lt;/center>&#xA; *           &lt;/tr>&#xA; *         &lt;/table>&#xA; *       &lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;th id=&quot;byte2&quot;>Byte 2&lt;/th>&#xA; *       &lt;td>&#xA; *         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;>&#xA; *           &lt;tr>&#xA; *             &lt;td width=&quot;12%&quot;>&lt;center>1&lt;/center>&#xA; *             &lt;td width=&quot;13%&quot;>&lt;center>0&lt;/center>&#xA; *             &lt;td colspan=&quot;6&quot;>&lt;center>bits 5-0&lt;/center>&#xA; *           &lt;/tr>&#xA; *         &lt;/table>&#xA; *       &lt;/td>&#xA; *     &lt;/tr>&#xA; *   &lt;/table>&#xA; *  &lt;/blockquote>&#xA; *&#xA; * &lt;br>&#xA; * &lt;code>char&lt;/code> values in the range &lt;code>'&amp;#92;u0800'&lt;/code> to&#xA; * &lt;code>'&amp;#92;uFFFF'&lt;/code> are represented by three bytes:&#xA; *&#xA; * &lt;blockquote>&#xA; *   &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;8&quot; width=&quot;50%&quot;&#xA; *          summary=&quot;Bit values and bytes&quot;>&#xA; *     &lt;tr>&#xA; *       &lt;td>&lt;/td>&#xA; *       &lt;th id=&quot;bit&quot;>Bit Values&lt;/th>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;th id=&quot;byte1&quot;>Byte 1&lt;/th>&#xA; *       &lt;td>&#xA; *         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;>&#xA; *           &lt;tr>&#xA; *             &lt;td width=&quot;12%&quot;>&lt;center>1&lt;/center>&#xA; *             &lt;td width=&quot;13%&quot;>&lt;center>1&lt;/center>&#xA; *             &lt;td width=&quot;12%&quot;>&lt;center>1&lt;/center>&#xA; *             &lt;td width=&quot;13%&quot;>&lt;center>0&lt;/center>&#xA; *             &lt;td colspan=&quot;4&quot;>&lt;center>bits 15-12&lt;/center>&#xA; *           &lt;/tr>&#xA; *         &lt;/table>&#xA; *       &lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;th id=&quot;byte2&quot;>Byte 2&lt;/th>&#xA; *       &lt;td>&#xA; *         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;>&#xA; *           &lt;tr>&#xA; *             &lt;td width=&quot;12%&quot;>&lt;center>1&lt;/center>&#xA; *             &lt;td width=&quot;13%&quot;>&lt;center>0&lt;/center>&#xA; *             &lt;td colspan=&quot;6&quot;>&lt;center>bits 11-6&lt;/center>&#xA; *           &lt;/tr>&#xA; *         &lt;/table>&#xA; *       &lt;/td>&#xA; *     &lt;/tr>&#xA; *     &lt;tr>&#xA; *       &lt;th id=&quot;byte3&quot;>Byte 3&lt;/th>&#xA; *       &lt;td>&#xA; *         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;>&#xA; *           &lt;tr>&#xA; *             &lt;td width=&quot;12%&quot;>&lt;center>1&lt;/center>&#xA; *             &lt;td width=&quot;13%&quot;>&lt;center>0&lt;/center>&#xA; *             &lt;td colspan=&quot;6&quot;>&lt;center>bits 5-0&lt;/center>&#xA; *           &lt;/tr>&#xA; *         &lt;/table>&#xA; *       &lt;/td>&#xA; *     &lt;/tr>&#xA; *   &lt;/table>&#xA; *  &lt;/blockquote>&#xA; *&#xA; * &lt;p>&#xA; * The differences between this format and the&#xA; * standard UTF-8 format are the following:&#xA; * &lt;ul>&#xA; * &lt;li>The null byte &lt;code>'&amp;#92;u0000'&lt;/code> is encoded in 2-byte format&#xA; *     rather than 1-byte, so that the encoded strings never have&#xA; *     embedded nulls.&#xA; * &lt;li>Only the 1-byte, 2-byte, and 3-byte formats are used.&#xA; * &lt;li>&lt;a href=&quot;../lang/Character.html#unicode&quot;>Supplementary characters&lt;/a>&#xA; *     are represented in the form of surrogate pairs.&#xA; * &lt;/ul>&#xA; * @author  Frank Yellin&#xA; * @version 1.23, 06/03/04&#xA; * @see     java.io.DataInputStream&#xA; * @see     java.io.DataOutput&#xA; * @since   JDK1.0&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
