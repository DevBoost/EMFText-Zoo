<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="CertificateFactorySpi.java">
  <comments>/*&#xA; * @(#)CertificateFactorySpi.java&#x9;1.19 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>security</namespaces>
  <namespaces>cert</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../util/Collection.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../util/Iterator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../util/List.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../Provider.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../NoSuchAlgorithmException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../NoSuchProviderException.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="CertificateFactorySpi">
    <members xsi:type="members:InterfaceMethod" name="engineGenerateCertificate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Certificate.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a certificate object and initializes it with&#xA;     * the data read from the input stream &lt;code>inStream&lt;/code>.&#xA;     *&#xA;     * &lt;p>In order to take advantage of the specialized certificate format&#xA;     * supported by this certificate factory,&#xA;     * the returned certificate object can be typecast to the corresponding&#xA;     * certificate class. For example, if this certificate&#xA;     * factory implements X.509 certificates, the returned certificate object&#xA;     * can be typecast to the &lt;code>X509Certificate&lt;/code> class.&#xA;     *&#xA;     * &lt;p>In the case of a certificate factory for X.509 certificates, the&#xA;     * certificate provided in &lt;code>inStream&lt;/code> must be DER-encoded and&#xA;     * may be supplied in binary or printable (Base64) encoding. If the&#xA;     * certificate is provided in Base64 encoding, it must be bounded at&#xA;     * the beginning by -----BEGIN CERTIFICATE-----, and must be bounded at&#xA;     * the end by -----END CERTIFICATE-----.&#xA;     *&#xA;     * &lt;p>Note that if the given input stream does not support&#xA;     * {@link java.io.InputStream#mark(int) mark} and&#xA;     * {@link java.io.InputStream#reset() reset}, this method will&#xA;     * consume the entire input stream. Otherwise, each call to this&#xA;     * method consumes one certificate and the read position of the input stream&#xA;     * is positioned to the next available byte after the the inherent&#xA;     * end-of-certificate marker. If the data in the&#xA;     * input stream does not contain an inherent end-of-certificate marker (other&#xA;     * than EOF) and there is trailing data after the certificate is parsed, a&#xA;     * &lt;code>CertificateException&lt;/code> is thrown.&#xA;     *&#xA;     * @param inStream an input stream with the certificate data.&#xA;     *&#xA;     * @return a certificate object initialized with the data&#xA;     * from the input stream.&#xA;     *&#xA;     * @exception CertificateException on parsing errors.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="engineGenerateCertPath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertPath.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a &lt;code>CertPath&lt;/code> object and initializes it with&#xA;     * the data read from the &lt;code>InputStream&lt;/code> inStream. The data&#xA;     * is assumed to be in the default encoding.&#xA;     *&#xA;     * &lt;p> This method was added to version 1.4 of the Java 2 Platform&#xA;     * Standard Edition. In order to maintain backwards compatibility with&#xA;     * existing service providers, this method cannot be &lt;code>abstract&lt;/code>&#xA;     * and by default throws an &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param inStream an &lt;code>InputStream&lt;/code> containing the data&#xA;     * @return a &lt;code>CertPath&lt;/code> initialized with the data from the&#xA;     *   &lt;code>InputStream&lt;/code>&#xA;     * @exception CertificateException if an exception occurs while decoding&#xA;     * @exception UnsupportedOperationException if the method is not supported&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="engineGenerateCertPath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertPath.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="encoding">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a &lt;code>CertPath&lt;/code> object and initializes it with&#xA;     * the data read from the &lt;code>InputStream&lt;/code> inStream. The data&#xA;     * is assumed to be in the specified encoding.&#xA;     *&#xA;     * &lt;p> This method was added to version 1.4 of the Java 2 Platform&#xA;     * Standard Edition. In order to maintain backwards compatibility with&#xA;     * existing service providers, this method cannot be &lt;code>abstract&lt;/code>&#xA;     * and by default throws an &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param inStream an &lt;code>InputStream&lt;/code> containing the data&#xA;     * @param encoding the encoding used for the data&#xA;     * @return a &lt;code>CertPath&lt;/code> initialized with the data from the&#xA;     *   &lt;code>InputStream&lt;/code>&#xA;     * @exception CertificateException if an exception occurs while decoding or&#xA;     *   the encoding requested is not supported&#xA;     * @exception UnsupportedOperationException if the method is not supported&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="engineGenerateCertPath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertPath.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="certificates">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="Certificate.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../../util/List.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a &lt;code>CertPath&lt;/code> object and initializes it with&#xA;     * a &lt;code>List&lt;/code> of &lt;code>Certificate&lt;/code>s.&#xA;     * &lt;p>&#xA;     * The certificates supplied must be of a type supported by the&#xA;     * &lt;code>CertificateFactory&lt;/code>. They will be copied out of the supplied&#xA;     * &lt;code>List&lt;/code> object.&#xA;     *&#xA;     * &lt;p> This method was added to version 1.4 of the Java 2 Platform&#xA;     * Standard Edition. In order to maintain backwards compatibility with&#xA;     * existing service providers, this method cannot be &lt;code>abstract&lt;/code>&#xA;     * and by default throws an &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @param certificates a &lt;code>List&lt;/code> of &lt;code>Certificate&lt;/code>s&#xA;     * @return a &lt;code>CertPath&lt;/code> initialized with the supplied list of&#xA;     *   certificates&#xA;     * @exception CertificateException if an exception occurs&#xA;     * @exception UnsupportedOperationException if the method is not supported&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="engineGetCertPathEncodings">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an iteration of the &lt;code>CertPath&lt;/code> encodings supported &#xA;     * by this certificate factory, with the default encoding first. See &#xA;     * Appendix A in the &#xA;     * &lt;a href=&quot;../../../../guide/security/certpath/CertPathProgGuide.html#AppA&quot;>&#xA;     * Java Certification Path API Programmer's Guide&lt;/a>&#xA;     * for information about standard encoding names.&#xA;     * &lt;p>&#xA;     * Attempts to modify the returned &lt;code>Iterator&lt;/code> via its&#xA;     * &lt;code>remove&lt;/code> method result in an&#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * &lt;p> This method was added to version 1.4 of the Java 2 Platform&#xA;     * Standard Edition. In order to maintain backwards compatibility with&#xA;     * existing service providers, this method cannot be &lt;code>abstract&lt;/code>&#xA;     * and by default throws an &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @return an &lt;code>Iterator&lt;/code> over the names of the supported&#xA;     *         &lt;code>CertPath&lt;/code> encodings (as &lt;code>String&lt;/code>s)&#xA;     * @exception UnsupportedOperationException if the method is not supported&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="engineGenerateCertificates">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:ExtendsTypeArgument">
            <extendTypes xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="Certificate.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </extendTypes>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a (possibly empty) collection view of the certificates read&#xA;     * from the given input stream &lt;code>inStream&lt;/code>.&#xA;     *&#xA;     * &lt;p>In order to take advantage of the specialized certificate format&#xA;     * supported by this certificate factory, each element in&#xA;     * the returned collection view can be typecast to the corresponding&#xA;     * certificate class. For example, if this certificate&#xA;     * factory implements X.509 certificates, the elements in the returned&#xA;     * collection can be typecast to the &lt;code>X509Certificate&lt;/code> class.&#xA;     *&#xA;     * &lt;p>In the case of a certificate factory for X.509 certificates,&#xA;     * &lt;code>inStream&lt;/code> may contain a single DER-encoded certificate&#xA;     * in the formats described for &#xA;     * {@link CertificateFactory#generateCertificate(java.io.InputStream) &#xA;     * generateCertificate}.&#xA;     * In addition, &lt;code>inStream&lt;/code> may contain a PKCS#7 certificate&#xA;     * chain. This is a PKCS#7 &lt;i>SignedData&lt;/i> object, with the only&#xA;     * significant field being &lt;i>certificates&lt;/i>. In particular, the&#xA;     * signature and the contents are ignored. This format allows multiple&#xA;     * certificates to be downloaded at once. If no certificates are present,&#xA;     * an empty collection is returned.&#xA;     *&#xA;     * &lt;p>Note that if the given input stream does not support&#xA;     * {@link java.io.InputStream#mark(int) mark} and&#xA;     * {@link java.io.InputStream#reset() reset}, this method will&#xA;     * consume the entire input stream.&#xA;     *&#xA;     * @param inStream the input stream with the certificates.&#xA;     *&#xA;     * @return a (possibly empty) collection view of&#xA;     * java.security.cert.Certificate objects&#xA;     * initialized with the data from the input stream.&#xA;     *&#xA;     * @exception CertificateException on parsing errors.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="engineGenerateCRL">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CRL.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CRLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a certificate revocation list (CRL) object and initializes it&#xA;     * with the data read from the input stream &lt;code>inStream&lt;/code>.&#xA;     *&#xA;     * &lt;p>In order to take advantage of the specialized CRL format&#xA;     * supported by this certificate factory,&#xA;     * the returned CRL object can be typecast to the corresponding&#xA;     * CRL class. For example, if this certificate&#xA;     * factory implements X.509 CRLs, the returned CRL object&#xA;     * can be typecast to the &lt;code>X509CRL&lt;/code> class.&#xA;     *&#xA;     * &lt;p>Note that if the given input stream does not support&#xA;     * {@link java.io.InputStream#mark(int) mark} and&#xA;     * {@link java.io.InputStream#reset() reset}, this method will&#xA;     * consume the entire input stream. Otherwise, each call to this&#xA;     * method consumes one CRL and the read position of the input stream&#xA;     * is positioned to the next available byte after the the inherent&#xA;     * end-of-CRL marker. If the data in the&#xA;     * input stream does not contain an inherent end-of-CRL marker (other&#xA;     * than EOF) and there is trailing data after the CRL is parsed, a&#xA;     * &lt;code>CRLException&lt;/code> is thrown.&#xA;     *&#xA;     * @param inStream an input stream with the CRL data.&#xA;     *&#xA;     * @return a CRL object initialized with the data&#xA;     * from the input stream.&#xA;     *&#xA;     * @exception CRLException on parsing errors.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="engineGenerateCRLs">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:ExtendsTypeArgument">
            <extendTypes xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="CRL.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </extendTypes>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CRLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a (possibly empty) collection view of the CRLs read&#xA;     * from the given input stream &lt;code>inStream&lt;/code>.&#xA;     *&#xA;     * &lt;p>In order to take advantage of the specialized CRL format&#xA;     * supported by this certificate factory, each element in&#xA;     * the returned collection view can be typecast to the corresponding&#xA;     * CRL class. For example, if this certificate&#xA;     * factory implements X.509 CRLs, the elements in the returned&#xA;     * collection can be typecast to the &lt;code>X509CRL&lt;/code> class.&#xA;     *&#xA;     * &lt;p>In the case of a certificate factory for X.509 CRLs,&#xA;     * &lt;code>inStream&lt;/code> may contain a single DER-encoded CRL.&#xA;     * In addition, &lt;code>inStream&lt;/code> may contain a PKCS#7 CRL&#xA;     * set. This is a PKCS#7 &lt;i>SignedData&lt;/i> object, with the only&#xA;     * significant field being &lt;i>crls&lt;/i>. In particular, the&#xA;     * signature and the contents are ignored. This format allows multiple&#xA;     * CRLs to be downloaded at once. If no CRLs are present,&#xA;     * an empty collection is returned.&#xA;     *&#xA;     * &lt;p>Note that if the given input stream does not support&#xA;     * {@link java.io.InputStream#mark(int) mark} and&#xA;     * {@link java.io.InputStream#reset() reset}, this method will&#xA;     * consume the entire input stream.&#xA;     *&#xA;     * @param inStream the input stream with the CRLs.&#xA;     *&#xA;     * @return a (possibly empty) collection view of&#xA;     * java.security.cert.CRL objects initialized with the data from the input&#xA;     * stream.&#xA;     *&#xA;     * @exception CRLException on parsing errors.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This class defines the &lt;i>Service Provider Interface&lt;/i> (&lt;b>SPI&lt;/b>)&#xA; * for the &lt;code>CertificateFactory&lt;/code> class.&#xA; * All the abstract methods in this class must be implemented by each&#xA; * cryptographic service provider who wishes to supply the implementation&#xA; * of a certificate factory for a particular certificate type, e.g., X.509.&#xA; *&#xA; * &lt;p>Certificate factories are used to generate certificate, certification path&#xA; * (&lt;code>CertPath&lt;/code>) and certificate revocation list (CRL) objects from &#xA; * their encodings.&#xA; *&#xA; * &lt;p>A certificate factory for X.509 must return certificates that are an&#xA; * instance of &lt;code>java.security.cert.X509Certificate&lt;/code>, and CRLs&#xA; * that are an instance of &lt;code>java.security.cert.X509CRL&lt;/code>.&#xA; *&#xA; * @author Hemma Prafullchandra&#xA; * @author Jan Luehe&#xA; * @author Sean Mullan&#xA; *&#xA; * @version 1.19, 05/05/04&#xA; *&#xA; * @see CertificateFactory&#xA; * @see Certificate&#xA; * @see X509Certificate&#xA; * @see CertPath&#xA; * @see CRL&#xA; * @see X509CRL&#xA; *&#xA; * @since 1.2&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
