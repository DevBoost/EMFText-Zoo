<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="CertificateFactory.java">
  <comments>/*&#xA; * @(#)CertificateFactory.java&#x9;1.28 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>security</namespaces>
  <namespaces>cert</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../util/Collection.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../util/Iterator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../util/List.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../Provider.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../AccessController.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../PrivilegedAction.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../NoSuchAlgorithmException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Class" href="../NoSuchProviderException.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>sun</namespaces>
    <namespaces>security</namespaces>
    <namespaces>jca</namespaces>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>security</namespaces>
    <namespaces>jca</namespaces>
    <namespaces>GetInstance</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/security/jca/GetInstance$Instance.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="CertificateFactory">
    <members xsi:type="members:Field" name="type">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// The certificate type</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="provider">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../Provider.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// The provider</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="certFacSpi">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateFactorySpi.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>// The provider implementation</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="CertificateFactory">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3/@parameters.2"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="certFacSpi">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="CertificateFactorySpi.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="provider">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Provider.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Creates a CertificateFactory object of the given type, and encapsulates&#xA;     * the given provider implementation (SPI object) in it.&#xA;     *&#xA;     * @param certFacSpi the provider implementation.&#xA;     * @param provider the provider.&#xA;     * @param type the certificate type.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a certificate factory object that implements the&#xA;     * specified certificate type. If the default provider package&#xA;     * provides an implementation of the requested certificate type,&#xA;     * an instance of certificate factory containing that&#xA;     * implementation is returned.&#xA;     * If the type is not available in the default&#xA;     * package, other packages are searched.&#xA;     *&#xA;     * @param type the name of the requested certificate type.&#xA;     * See Appendix A in the &lt;a href=&#xA;     * &quot;../../../../guide/security/CryptoSpec.html#AppA&quot;>&#xA;     * Java Cryptography Architecture API Specification &amp;amp; Reference &lt;/a>&#xA;     * for information about standard certificate types.&#xA;     *&#xA;     * @return a certificate factory object for the specified type.&#xA;     *&#xA;     * @exception CertificateException if the requested certificate type is&#xA;     * not available in the default provider package or any of the other&#xA;     * provider packages that were searched.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="instance">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../sun/security/jca/GetInstance$Instance.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../sun/security/jca/GetInstance.class.xmi#//@classifiers.0/@members.7"/>
                <arguments xsi:type="references:StringReference" value="CertificateFactory"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:ReflectiveClassReference"/>
                  <target xsi:type="classifiers:Class" href="CertificateFactorySpi.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../sun/security/jca/GetInstance.class.xmi#//@classifiers.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="CertificateFactorySpi.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@statements.0/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../../../sun/security/jca/GetInstance$Instance.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </child>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@statements.0/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../../../sun/security/jca/GetInstance$Instance.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@parameters.0"/>
                <children xsi:type="references:StringReference" value=" not found"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4/@statements.0/@catcheBlocks.0/@parameter"/>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../NoSuchAlgorithmException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="provider">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../NoSuchProviderException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a certificate factory object for the specified&#xA;     * certificate type from the specified provider.&#xA;     *&#xA;     * @param type the certificate type&#xA;     * @param provider the name of the provider.&#xA;     *&#xA;     * @return a certificate factory object for the specified type.&#xA;     *&#xA;     * @exception CertificateException if the certificate type is&#xA;     * not available from the specified provider.&#xA;     *&#xA;     * @exception NoSuchProviderException if the provider has not been&#xA;     * configured.&#xA;     *&#xA;     * @see Provider&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="instance">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../sun/security/jca/GetInstance$Instance.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../sun/security/jca/GetInstance.class.xmi#//@classifiers.0/@members.9"/>
                <arguments xsi:type="references:StringReference" value="CertificateFactory"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:ReflectiveClassReference"/>
                  <target xsi:type="classifiers:Class" href="CertificateFactorySpi.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../sun/security/jca/GetInstance.class.xmi#//@classifiers.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="CertificateFactorySpi.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.0/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../../../sun/security/jca/GetInstance$Instance.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </child>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.0/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../../../sun/security/jca/GetInstance$Instance.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
                <children xsi:type="references:StringReference" value=" not found"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.0/@catcheBlocks.0/@parameter"/>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../NoSuchAlgorithmException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="type">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="provider">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Provider.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a certificate factory object for the specified&#xA;     * certificate type from the specified provider.&#xA;     * Note: the &lt;code>provider&lt;/code> doesn't have to be registered.&#xA;     *&#xA;     * @param type the certificate type&#xA;     * @param provider the provider&#xA;     *&#xA;     * @return a certificate factory object for the specified type.&#xA;     *&#xA;     * @exception CertificateException if the certificate type is&#xA;     * not available from the specified provider.&#xA;     *&#xA;     * @exception IllegalArgumentException if the &lt;code>provider&lt;/code> is&#xA;     * null.&#xA;     *&#xA;     * @see Provider&#xA;     *&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:LocalVariableStatement">
          <variable name="instance">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../sun/security/jca/GetInstance$Instance.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <initialValue xsi:type="references:IdentifierReference">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../sun/security/jca/GetInstance.class.xmi#//@classifiers.0/@members.11"/>
                <arguments xsi:type="references:StringReference" value="CertificateFactory"/>
                <arguments xsi:type="references:IdentifierReference">
                  <next xsi:type="references:ReflectiveClassReference"/>
                  <target xsi:type="classifiers:Class" href="CertificateFactorySpi.class.xmi#//@classifiers.0"/>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="../../../sun/security/jca/GetInstance.class.xmi#//@classifiers.0"/>
            </initialValue>
          </variable>
        </statements>
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <arguments xsi:type="expressions:CastExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="CertificateFactorySpi.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="../../../sun/security/jca/GetInstance$Instance.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </child>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@statements.0/@variable">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../../../sun/security/jca/GetInstance$Instance.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@parameters.0"/>
                <children xsi:type="references:StringReference" value=" not found"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6/@statements.0/@catcheBlocks.0/@parameter"/>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../NoSuchAlgorithmException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getProvider">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../Provider.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the provider of this certificate factory.&#xA;     *&#xA;     * @return the provider of this certificate factory.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getType">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the name of the certificate type associated with this&#xA;     * certificate factory.&#xA;     *&#xA;     * @return the name of the certificate type associated with this&#xA;     * certificate factory.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:SelfReference">
          <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <self xsi:type="literals:This"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="generateCertificate">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Certificate.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a certificate object and initializes it with&#xA;     * the data read from the input stream &lt;code>inStream&lt;/code>.&#xA;     *&#xA;     * &lt;p>In order to take advantage of the specialized certificate format&#xA;     * supported by this certificate factory,&#xA;     * the returned certificate object can be typecast to the corresponding&#xA;     * certificate class. For example, if this certificate&#xA;     * factory implements X.509 certificates, the returned certificate object&#xA;     * can be typecast to the &lt;code>X509Certificate&lt;/code> class.&#xA;     *&#xA;     * &lt;p>In the case of a certificate factory for X.509 certificates, the&#xA;     * certificate provided in &lt;code>inStream&lt;/code> must be DER-encoded and&#xA;     * may be supplied in binary or printable (Base64) encoding. If the&#xA;     * certificate is provided in Base64 encoding, it must be bounded at&#xA;     * the beginning by -----BEGIN CERTIFICATE-----, and must be bounded at&#xA;     * the end by -----END CERTIFICATE-----.&#xA;     *&#xA;     * &lt;p>Note that if the given input stream does not support&#xA;     * {@link java.io.InputStream#mark(int) mark} and&#xA;     * {@link java.io.InputStream#reset() reset}, this method will&#xA;     * consume the entire input stream. Otherwise, each call to this &#xA;     * method consumes one certificate and the read position of the&#xA;     * input stream is positioned to the next available byte after&#xA;     * the inherent end-of-certificate marker. If the data in the input stream&#xA;     * does not contain an inherent end-of-certificate marker (other&#xA;     * than EOF) and there is trailing data after the certificate is parsed, a &#xA;     * &lt;code>CertificateException&lt;/code> is thrown.&#xA;     *&#xA;     * @param inStream an input stream with the certificate data.&#xA;     *&#xA;     * @return a certificate object initialized with the data&#xA;     * from the input stream.&#xA;     *&#xA;     * @exception CertificateException on parsing errors.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="CertificateFactorySpi.class.xmi#//@classifiers.0/@members.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCertPathEncodings">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Iterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an iteration of the &lt;code>CertPath&lt;/code> encodings supported &#xA;     * by this certificate factory, with the default encoding first. See &#xA;     * Appendix A in the &#xA;     * &lt;a href=&quot;../../../../guide/security/certpath/CertPathProgGuide.html#AppA&quot;>&#xA;     * Java Certification Path API Programmer's Guide&lt;/a> for information about &#xA;     * standard encoding names and their formats. &#xA;     * &lt;p>&#xA;     * Attempts to modify the returned &lt;code>Iterator&lt;/code> via its &#xA;     * &lt;code>remove&lt;/code> method result in an &#xA;     * &lt;code>UnsupportedOperationException&lt;/code>.&#xA;     *&#xA;     * @return an &lt;code>Iterator&lt;/code> over the names of the supported&#xA;     *         &lt;code>CertPath&lt;/code> encodings (as &lt;code>String&lt;/code>s)&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="CertificateFactorySpi.class.xmi#//@classifiers.0/@members.5"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="generateCertPath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertPath.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a &lt;code>CertPath&lt;/code> object and initializes it with&#xA;     * the data read from the &lt;code>InputStream&lt;/code> inStream. The data&#xA;     * is assumed to be in the default encoding. The name of the default&#xA;     * encoding is the first element of the &lt;code>Iterator&lt;/code> returned by&#xA;     * the {@link #getCertPathEncodings getCertPathEncodings} method.&#xA;     *&#xA;     * @param inStream an &lt;code>InputStream&lt;/code> containing the data&#xA;     * @return a &lt;code>CertPath&lt;/code> initialized with the data from the&#xA;     *   &lt;code>InputStream&lt;/code>&#xA;     * @exception CertificateException if an exception occurs while decoding&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="CertificateFactorySpi.class.xmi#//@classifiers.0/@members.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11/@parameters.0"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="generateCertPath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertPath.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="encoding">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a &lt;code>CertPath&lt;/code> object and initializes it with&#xA;     * the data read from the &lt;code>InputStream&lt;/code> inStream. The data&#xA;     * is assumed to be in the specified encoding. See Appendix A in the &#xA;     * &lt;a href=&quot;../../../../guide/security/certpath/CertPathProgGuide.html#AppA&quot;>&#xA;     * Java Certification Path API Programmer's Guide&lt;/a>&#xA;     * for information about standard encoding names and their formats.&#xA;     *&#xA;     * @param inStream an &lt;code>InputStream&lt;/code> containing the data&#xA;     * @param encoding the encoding used for the data&#xA;     * @return a &lt;code>CertPath&lt;/code> initialized with the data from the&#xA;     *   &lt;code>InputStream&lt;/code>&#xA;     * @exception CertificateException if an exception occurs while decoding or&#xA;     *   the encoding requested is not supported&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="CertificateFactorySpi.class.xmi#//@classifiers.0/@members.3"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.1"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="generateCertPath">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertPath.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="certificates">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:ExtendsTypeArgument">
              <extendTypes xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="Certificate.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </extendTypes>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="../../util/List.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a &lt;code>CertPath&lt;/code> object and initializes it with&#xA;     * a &lt;code>List&lt;/code> of &lt;code>Certificate&lt;/code>s.&#xA;     * &lt;p>&#xA;     * The certificates supplied must be of a type supported by the&#xA;     * &lt;code>CertificateFactory&lt;/code>. They will be copied out of the supplied&#xA;     * &lt;code>List&lt;/code> object.&#xA;     *&#xA;     * @param certificates a &lt;code>List&lt;/code> of &lt;code>Certificate&lt;/code>s&#xA;     * @return a &lt;code>CertPath&lt;/code> initialized with the supplied list of&#xA;     *   certificates&#xA;     * @exception CertificateException if an exception occurs&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="CertificateFactorySpi.class.xmi#//@classifiers.0/@members.4"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
            </next>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="generateCertificates">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:ExtendsTypeArgument">
            <extendTypes xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="Certificate.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </extendTypes>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a (possibly empty) collection view of the certificates read&#xA;     * from the given input stream &lt;code>inStream&lt;/code>.&#xA;     *&#xA;     * &lt;p>In order to take advantage of the specialized certificate format&#xA;     * supported by this certificate factory, each element in&#xA;     * the returned collection view can be typecast to the corresponding&#xA;     * certificate class. For example, if this certificate&#xA;     * factory implements X.509 certificates, the elements in the returned&#xA;     * collection can be typecast to the &lt;code>X509Certificate&lt;/code> class.&#xA;     *&#xA;     * &lt;p>In the case of a certificate factory for X.509 certificates,&#xA;     * &lt;code>inStream&lt;/code> may contain a sequence of DER-encoded certificates&#xA;     * in the formats described for&#xA;     * {@link #generateCertificate(java.io.InputStream) generateCertificate}.&#xA;     * In addition, &lt;code>inStream&lt;/code> may contain a PKCS#7 certificate&#xA;     * chain. This is a PKCS#7 &lt;i>SignedData&lt;/i> object, with the only&#xA;     * significant field being &lt;i>certificates&lt;/i>. In particular, the&#xA;     * signature and the contents are ignored. This format allows multiple&#xA;     * certificates to be downloaded at once. If no certificates are present,&#xA;     * an empty collection is returned.&#xA;     *&#xA;     * &lt;p>Note that if the given input stream does not support&#xA;     * {@link java.io.InputStream#mark(int) mark} and&#xA;     * {@link java.io.InputStream#reset() reset}, this method will&#xA;     * consume the entire input stream.&#xA;     *&#xA;     * @param inStream the input stream with the certificates.&#xA;     *&#xA;     * @return a (possibly empty) collection view of&#xA;     * java.security.cert.Certificate objects&#xA;     * initialized with the data from the input stream.&#xA;     *&#xA;     * @exception CertificateException on parsing errors.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="CertificateFactorySpi.class.xmi#//@classifiers.0/@members.6"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="generateCRL">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CRL.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CRLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Generates a certificate revocation list (CRL) object and initializes it&#xA;     * with the data read from the input stream &lt;code>inStream&lt;/code>.&#xA;     *&#xA;     * &lt;p>In order to take advantage of the specialized CRL format&#xA;     * supported by this certificate factory,&#xA;     * the returned CRL object can be typecast to the corresponding&#xA;     * CRL class. For example, if this certificate&#xA;     * factory implements X.509 CRLs, the returned CRL object&#xA;     * can be typecast to the &lt;code>X509CRL&lt;/code> class.&#xA;     *&#xA;     * &lt;p>Note that if the given input stream does not support&#xA;     * {@link java.io.InputStream#mark(int) mark} and&#xA;     * {@link java.io.InputStream#reset() reset}, this method will&#xA;     * consume the entire input stream. Otherwise, each call to this &#xA;     * method consumes one CRL and the read position of the input stream&#xA;     * is positioned to the next available byte after the the inherent &#xA;     * end-of-CRL marker. If the data in the&#xA;     * input stream does not contain an inherent end-of-CRL marker (other&#xA;     * than EOF) and there is trailing data after the CRL is parsed, a &#xA;     * &lt;code>CRLException&lt;/code> is thrown.&#xA;     *&#xA;     * @param inStream an input stream with the CRL data.&#xA;     *&#xA;     * @return a CRL object initialized with the data&#xA;     * from the input stream.&#xA;     *&#xA;     * @exception CRLException on parsing errors.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="CertificateFactorySpi.class.xmi#//@classifiers.0/@members.7"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="generateCRLs">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:ExtendsTypeArgument">
            <extendTypes xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="CRL.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </extendTypes>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="inStream">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../io/InputStream.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CRLException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a (possibly empty) collection view of the CRLs read&#xA;     * from the given input stream &lt;code>inStream&lt;/code>.&#xA;     *&#xA;     * &lt;p>In order to take advantage of the specialized CRL format&#xA;     * supported by this certificate factory, each element in&#xA;     * the returned collection view can be typecast to the corresponding&#xA;     * CRL class. For example, if this certificate&#xA;     * factory implements X.509 CRLs, the elements in the returned&#xA;     * collection can be typecast to the &lt;code>X509CRL&lt;/code> class.&#xA;     *&#xA;     * &lt;p>In the case of a certificate factory for X.509 CRLs,&#xA;     * &lt;code>inStream&lt;/code> may contain a sequence of DER-encoded CRLs.&#xA;     * In addition, &lt;code>inStream&lt;/code> may contain a PKCS#7 CRL&#xA;     * set. This is a PKCS#7 &lt;i>SignedData&lt;/i> object, with the only&#xA;     * significant field being &lt;i>crls&lt;/i>. In particular, the&#xA;     * signature and the contents are ignored. This format allows multiple&#xA;     * CRLs to be downloaded at once. If no CRLs are present,&#xA;     * an empty collection is returned.&#xA;     *&#xA;     * &lt;p>Note that if the given input stream does not support&#xA;     * {@link java.io.InputStream#mark(int) mark} and&#xA;     * {@link java.io.InputStream#reset() reset}, this method will&#xA;     * consume the entire input stream.&#xA;     *&#xA;     * @param inStream the input stream with the CRLs.&#xA;     *&#xA;     * @return a (possibly empty) collection view of&#xA;     * java.security.cert.CRL objects initialized with the data from the input&#xA;     * stream.&#xA;     *&#xA;     * @exception CRLException on parsing errors.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="CertificateFactorySpi.class.xmi#//@classifiers.0/@members.8"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This class defines the functionality of a certificate factory, which is&#xA; * used to generate certificate, certification path (&lt;code>CertPath&lt;/code>)&#xA; * and certificate revocation list (CRL) objects from their encodings.&#xA; *&#xA; * &lt;p>For encodings consisting of multiple certificates, use&#xA; * &lt;code>generateCertificates&lt;/code> when you want to&#xA; * parse a collection of possibly unrelated certificates. Otherwise,&#xA; * use &lt;code>generateCertPath&lt;/code> when you want to generate&#xA; * a &lt;code>CertPath&lt;/code> (a certificate chain) and subsequently&#xA; * validate it with a &lt;code>CertPathValidator&lt;/code>.&#xA; *&#xA; * &lt;p>A certificate factory for X.509 must return certificates that are an&#xA; * instance of &lt;code>java.security.cert.X509Certificate&lt;/code>, and CRLs&#xA; * that are an instance of &lt;code>java.security.cert.X509CRL&lt;/code>.&#xA; *&#xA; * &lt;p>The following example reads a file with Base64 encoded certificates,&#xA; * which are each bounded at the beginning by -----BEGIN CERTIFICATE-----, and&#xA; * bounded at the end by -----END CERTIFICATE-----. We convert the&#xA; * &lt;code>FileInputStream&lt;/code> (which does not support &lt;code>mark&lt;/code>&#xA; * and &lt;code>reset&lt;/code>) to a &lt;code>BufferedInputStream&lt;/code> (which&#xA; * supports those methods), so that each call to&#xA; * &lt;code>generateCertificate&lt;/code> consumes only one certificate, and the&#xA; * read position of the input stream is positioned to the next certificate in&#xA; * the file:&lt;p>&#xA; *&#xA; * &lt;pre>&#xA; * FileInputStream fis = new FileInputStream(filename);&#xA; * BufferedInputStream bis = new BufferedInputStream(fis);&#xA; *&#xA; * CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);&#xA; *&#xA; * while (bis.available() > 0) {&#xA; *    Certificate cert = cf.generateCertificate(bis);&#xA; *    System.out.println(cert.toString());&#xA; * }&#xA; * &lt;/pre>&#xA; *&#xA; * &lt;p>The following example parses a PKCS#7-formatted certificate reply stored&#xA; * in a file and extracts all the certificates from it:&lt;p>&#xA; *&#xA; * &lt;pre>&#xA; * FileInputStream fis = new FileInputStream(filename);&#xA; * CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);&#xA; * Collection c = cf.generateCertificates(fis);&#xA; * Iterator i = c.iterator();&#xA; * while (i.hasNext()) {&#xA; *    Certificate cert = (Certificate)i.next();&#xA; *    System.out.println(cert);&#xA; * }&#xA; * &lt;/pre>&#xA; *&#xA; * @author Hemma Prafullchandra&#xA; * @author Jan Luehe&#xA; * @author Sean Mullan&#xA; *&#xA; * @version 1.28, 05/05/04&#xA; *&#xA; * @see Certificate&#xA; * @see X509Certificate&#xA; * @see CertPath&#xA; * @see CRL&#xA; * @see X509CRL&#xA; *&#xA; * @since 1.2&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
