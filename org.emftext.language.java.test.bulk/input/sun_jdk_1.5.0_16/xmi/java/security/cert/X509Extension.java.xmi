<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/types ../../../java.ecore#/16" name="X509Extension.java">
  <comments>/*&#xA; * @(#)X509Extension.java&#x9;1.22 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>security</namespaces>
  <namespaces>cert</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../util/Set.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="X509Extension">
    <members xsi:type="members:InterfaceMethod" name="hasUnsupportedCriticalExtension">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Check if there is a critical extension that is not supported.&#xA;     * &#xA;     * @return &lt;tt>true&lt;/tt> if a critical extension is found that is&#xA;     * not supported, otherwise &lt;tt>false&lt;/tt>.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getCriticalExtensionOIDs">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Set.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets a Set of the OID strings for the extension(s) marked&#xA;     * CRITICAL in the certificate/CRL managed by the object&#xA;     * implementing this interface.&#xA;     *&#xA;     * Here is sample code to get a Set of critical extensions from an&#xA;     * X509Certificate and print the OIDs:&#xA;     * &lt;pre>&lt;code>&#xA;     * InputStream inStrm = new FileInputStream(&quot;DER-encoded-Cert&quot;);&#xA;     * CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);&#xA;     * X509Certificate cert = (X509Certificate)cf.generateCertificate(inStrm);&#xA;     * inStrm.close();&lt;p>&#xA;     *&#xA;     * Set critSet = cert.getCriticalExtensionOIDs();&#xA;     * if (critSet != null &amp;&amp; !critSet.isEmpty()) {&#xA;     *     System.out.println(&quot;Set of critical extensions:&quot;);&#xA;     *     for (Iterator i = critSet.iterator(); i.hasNext();) {&#xA;     *         String oid = (String)i.next();&#xA;     *         System.out.println(oid);&#xA;     *     }&#xA;     * }&#xA;     * &lt;/code>&lt;/pre>&#xA;     * @return a Set (or an empty Set if none are marked critical) of&#xA;     * the extension OID strings for extensions that are marked critical.&#xA;     * If there are no extensions present at all, then this method returns&#xA;     * null.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNonCriticalExtensionOIDs">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Set.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets a Set of the OID strings for the extension(s) marked&#xA;     * NON-CRITICAL in the certificate/CRL managed by the object&#xA;     * implementing this interface.&#xA;     *&#xA;     * Here is sample code to get a Set of non-critical extensions from an&#xA;     * X509CRL revoked certificate entry and print the OIDs:&#xA;     * &lt;pre>&lt;code>&#xA;     * InputStream inStrm = new FileInputStream(&quot;DER-encoded-CRL&quot;);&#xA;     * CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);&#xA;     * X509CRL crl = (X509CRL)cf.generateCRL(inStrm);&#xA;     * inStrm.close();&lt;p>&#xA;     *&#xA;     * byte[] certData = &amp;lt;DER-encoded certificate data&amp;gt;&#xA;     * ByteArrayInputStream bais = new ByteArrayInputStream(certData);&#xA;     * X509Certificate cert = (X509Certificate)cf.generateCertificate(bais);&#xA;     * bais.close();&#xA;     * X509CRLEntry badCert =&#xA;     *              crl.getRevokedCertificate(cert.getSerialNumber());&lt;p>&#xA;     *&#xA;     * if (badCert != null) {&#xA;     *     Set nonCritSet = badCert.getNonCriticalExtensionOIDs();&lt;p>&#xA;     *     if (nonCritSet != null)&#xA;     *         for (Iterator i = nonCritSet.iterator(); i.hasNext();) {&#xA;     *             String oid = (String)i.next();&#xA;     *             System.out.println(oid);&#xA;     *         }&#xA;     * }&#xA;     * &lt;/code>&lt;/pre>&#xA;     *&#xA;     * @return a Set (or an empty Set if none are marked non-critical) of&#xA;     * the extension OID strings for extensions that are marked non-critical.&#xA;     * If there are no extensions present at all, then this method returns&#xA;     * null.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getExtensionValue">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="oid">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the DER-encoded OCTET string for the extension value&#xA;     * (&lt;em>extnValue&lt;/em>) identified by the passed-in &lt;code>oid&lt;/code>&#xA;     * String.&#xA;     * The &lt;code>oid&lt;/code> string is&#xA;     * represented by a set of nonnegative whole numbers separated&#xA;     * by periods.&#xA;     *&#xA;     * &lt;p>For example:&lt;br>&#xA;     * &lt;table border=groove summary=&quot;Examples of OIDs and extension names&quot;>&#xA;     * &lt;tr>&#xA;     * &lt;th>OID &lt;em>(Object Identifier)&lt;/em>&lt;/th>&#xA;     * &lt;th>Extension Name&lt;/th>&lt;/tr>&#xA;     * &lt;tr>&lt;td>2.5.29.14&lt;/td>&#xA;     * &lt;td>SubjectKeyIdentifier&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>2.5.29.15&lt;/td>&#xA;     * &lt;td>KeyUsage&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>2.5.29.16&lt;/td>&#xA;     * &lt;td>PrivateKeyUsage&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>2.5.29.17&lt;/td>&#xA;     * &lt;td>SubjectAlternativeName&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>2.5.29.18&lt;/td>&#xA;     * &lt;td>IssuerAlternativeName&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>2.5.29.19&lt;/td>&#xA;     * &lt;td>BasicConstraints&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>2.5.29.30&lt;/td>&#xA;     * &lt;td>NameConstraints&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>2.5.29.33&lt;/td>&#xA;     * &lt;td>PolicyMappings&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>2.5.29.35&lt;/td>&#xA;     * &lt;td>AuthorityKeyIdentifier&lt;/td>&lt;/tr>&#xA;     * &lt;tr>&lt;td>2.5.29.36&lt;/td>&#xA;     * &lt;td>PolicyConstraints&lt;/td>&lt;/tr>&#xA;     * &lt;/table>&#xA;     *&#xA;     * @param oid the Object Identifier value for the extension.&#xA;     * @return the DER-encoded octet string of the extension value or&#xA;     * null if it is not present.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Interface for an X.509 extension.&#xA; *&#xA; * &lt;p>The extensions defined for X.509 v3&#xA; * {@link X509Certificate Certificates} and v2&#xA; * {@link X509CRL CRLs} (Certificate Revocation&#xA; * Lists) provide methods&#xA; * for associating additional attributes with users or public keys,&#xA; * for managing the certification hierarchy, and for managing CRL&#xA; * distribution. The X.509 extensions format also allows communities&#xA; * to define private extensions to carry information unique to those&#xA; * communities.&#xA; *&#xA; * &lt;p>Each extension in a certificate/CRL may be designated as&#xA; * critical or non-critical.  A certificate/CRL-using system (an application&#xA; * validating a certificate/CRL) must reject the certificate/CRL if it&#xA; * encounters a critical extension it does not recognize.  A non-critical&#xA; * extension may be ignored if it is not recognized.&#xA; * &lt;p>&#xA; * The ASN.1 definition for this is:&#xA; * &lt;pre>&#xA; * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension&#xA; *&#xA; * Extension  ::=  SEQUENCE  {&#xA; *     extnId        OBJECT IDENTIFIER,&#xA; *     critical      BOOLEAN DEFAULT FALSE,&#xA; *     extnValue     OCTET STRING&#xA; *                   -- contains a DER encoding of a value&#xA; *                   -- of the type registered for use with&#xA; *                   -- the extnId object identifier value&#xA; * }&#xA; * &lt;/pre>&#xA; * Since not all extensions are known, the &lt;code>getExtensionValue&lt;/code>&#xA; * method returns the DER-encoded OCTET STRING of the&#xA; * extension value (i.e., the &lt;code>extnValue&lt;/code>). This can then&#xA; * be handled by a &lt;em>Class&lt;/em> that understands the extension.&#xA; *&#xA; * @author Hemma Prafullchandra&#xA; * @version 1.22 03/12/19&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
