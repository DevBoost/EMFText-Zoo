<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/generics ../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="X509Certificate.java">
  <comments>/*&#xA; * @(#)X509Certificate.java&#x9;1.39 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>security</namespaces>
  <namespaces>cert</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>math</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../math/BigInteger.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Principal.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../PublicKey.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../util/Collection.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../util/Date.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../../util/List.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>javax</namespaces>
    <namespaces>security</namespaces>
    <namespaces>auth</namespaces>
    <namespaces>x500</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../javax/security/auth/x500/X500Principal.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>security</namespaces>
    <namespaces>x509</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/security/x509/X509CertImpl.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="X509Certificate">
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="expressions:UnaryExpression">
        <operators xsi:type="operators:Subtraction"/>
        <child xsi:type="literals:DecimalLongLiteral" decimalValue="2491127588187038216"/>
      </initialValue>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="subjectX500Principal">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../javax/security/auth/x500/X500Principal.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Transient"/>
      <additionalFields name="issuerX500Principal"/>
    </members>
    <members xsi:type="members:Constructor" name="X509Certificate">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:StringReference" value="X.509"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Constructor for X.509 certificates.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="checkValidity">
      <typeReference xsi:type="types:Void"/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateExpiredException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateNotYetValidException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Checks that the certificate is currently valid. It is if&#xA;     * the current date and time are within the validity period given in the&#xA;     * certificate.&#xA;     * &lt;p>&#xA;     * The validity period consists of two date/time values: &#xA;     * the first and last dates (and times) on which the certificate &#xA;     * is valid. It is defined in&#xA;     * ASN.1 as:&#xA;     * &lt;pre>&#xA;     * validity             Validity&lt;p>&#xA;     * Validity ::= SEQUENCE {&#xA;     *     notBefore      CertificateValidityDate,&#xA;     *     notAfter       CertificateValidityDate }&lt;p>&#xA;     * CertificateValidityDate ::= CHOICE {&#xA;     *     utcTime        UTCTime,&#xA;     *     generalTime    GeneralizedTime }&#xA;     * &lt;/pre>&#xA;     * &#xA;     * @exception CertificateExpiredException if the certificate has expired.&#xA;     * @exception CertificateNotYetValidException if the certificate is not&#xA;     * yet valid.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="checkValidity">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="date">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../util/Date.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateExpiredException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateNotYetValidException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Checks that the given date is within the certificate's&#xA;     * validity period. In other words, this determines whether the &#xA;     * certificate would be valid at the given date/time.&#xA;     *&#xA;     * @param date the Date to check against to see if this certificate&#xA;     *        is valid at that date/time.&#xA;     *&#xA;     * @exception CertificateExpiredException if the certificate has expired&#xA;     * with respect to the &lt;code>date&lt;/code> supplied.&#xA;     * @exception CertificateNotYetValidException if the certificate is not&#xA;     * yet valid with respect to the &lt;code>date&lt;/code> supplied.&#xA;     * &#xA;     * @see #checkValidity()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getVersion">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the &lt;code>version&lt;/code> (version number) value from the&#xA;     * certificate.&#xA;     * The ASN.1 definition for this is:&#xA;     * &lt;pre>&#xA;     * version  [0] EXPLICIT Version DEFAULT v1&lt;p>&#xA;     * Version ::=  INTEGER  {  v1(0), v2(1), v3(2)  }&#xA;     * &lt;/pre>&#xA;     * @return the version number, i.e. 1, 2 or 3.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSerialNumber">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../math/BigInteger.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the &lt;code>serialNumber&lt;/code> value from the certificate.&#xA;     * The serial number is an integer assigned by the certification&#xA;     * authority to each certificate. It must be unique for each&#xA;     * certificate issued by a given CA (i.e., the issuer name and&#xA;     * serial number identify a unique certificate).&#xA;     * The ASN.1 definition for this is:&#xA;     * &lt;pre>&#xA;     * serialNumber     CertificateSerialNumber&lt;p>&#xA;     * &#xA;     * CertificateSerialNumber  ::=  INTEGER&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @return the serial number.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getIssuerDN">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../Principal.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;strong>Denigrated&lt;/strong>, replaced by {@linkplain&#xA;     * #getIssuerX500Principal()}. This method returns the &lt;code>issuer&lt;/code>&#xA;     * as an implementation specific Principal object, which should not be&#xA;     * relied upon by portable code.&#xA;     *&#xA;     * &lt;p>&#xA;     * Gets the &lt;code>issuer&lt;/code> (issuer distinguished name) value from &#xA;     * the certificate. The issuer name identifies the entity that signed (and&#xA;     * issued) the certificate. &#xA;     * &#xA;     * &lt;p>The issuer name field contains an&#xA;     * X.500 distinguished name (DN).&#xA;     * The ASN.1 definition for this is:&#xA;     * &lt;pre>&#xA;     * issuer    Name&lt;p>&#xA;     *&#xA;     * Name ::= CHOICE { RDNSequence }&#xA;     * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName&#xA;     * RelativeDistinguishedName ::=&#xA;     *     SET OF AttributeValueAssertion&#xA;     *&#xA;     * AttributeValueAssertion ::= SEQUENCE {&#xA;     *                               AttributeType,&#xA;     *                               AttributeValue }&#xA;     * AttributeType ::= OBJECT IDENTIFIER&#xA;     * AttributeValue ::= ANY&#xA;     * &lt;/pre>&#xA;     * The &lt;code>Name&lt;/code> describes a hierarchical name composed of&#xA;     * attributes,&#xA;     * such as country name, and corresponding values, such as US.&#xA;     * The type of the &lt;code>AttributeValue&lt;/code> component is determined by&#xA;     * the &lt;code>AttributeType&lt;/code>; in general it will be a &#xA;     * &lt;code>directoryString&lt;/code>. A &lt;code>directoryString&lt;/code> is usually &#xA;     * one of &lt;code>PrintableString&lt;/code>,&#xA;     * &lt;code>TeletexString&lt;/code> or &lt;code>UniversalString&lt;/code>.&#xA;     * &#xA;     * @return a Principal whose name is the issuer distinguished name.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getIssuerX500Principal">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../javax/security/auth/x500/X500Principal.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the issuer (issuer distinguished name) value from the&#xA;     * certificate as an &lt;code>X500Principal&lt;/code>. &#xA;     * &lt;p>&#xA;     * It is recommended that subclasses override this method.&#xA;     *&#xA;     * @return an &lt;code>X500Principal&lt;/code> representing the issuer&#xA;     *&#x9;&#x9;distinguished name&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@additionalFields.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../sun/security/x509/X509CertImpl.class.xmi#//@classifiers.0/@members.103"/>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../../../sun/security/x509/X509CertImpl.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@additionalFields.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@additionalFields.0"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSubjectDN">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="../Principal.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;strong>Denigrated&lt;/strong>, replaced by {@linkplain&#xA;     * #getSubjectX500Principal()}. This method returns the &lt;code>subject&lt;/code>&#xA;     * as an implementation specific Principal object, which should not be&#xA;     * relied upon by portable code.&#xA;     *&#xA;     * &lt;p>&#xA;     * Gets the &lt;code>subject&lt;/code> (subject distinguished name) value &#xA;     * from the certificate.  If the &lt;code>subject&lt;/code> value is empty,&#xA;     * then the &lt;code>getName()&lt;/code> method of the returned&#xA;     * &lt;code>Principal&lt;/code> object returns an empty string (&quot;&quot;).&#xA;     *&#xA;     * &lt;p> The ASN.1 definition for this is:&#xA;     * &lt;pre>&#xA;     * subject    Name&#xA;     * &lt;/pre>&#xA;     * &#xA;     * &lt;p>See {@link #getIssuerDN() getIssuerDN} for &lt;code>Name&lt;/code> &#xA;     * and other relevant definitions.&#xA;     * &#xA;     * @return a Principal whose name is the subject name.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getSubjectX500Principal">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../javax/security/auth/x500/X500Principal.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the subject (subject distinguished name) value from the&#xA;     * certificate as an &lt;code>X500Principal&lt;/code>.  If the subject value&#xA;     * is empty, then the &lt;code>getName()&lt;/code> method of the returned&#xA;     * &lt;code>X500Principal&lt;/code> object returns an empty string (&quot;&quot;).&#xA;     * &lt;p>&#xA;     * It is recommended that subclasses override this method.&#xA;     *&#xA;     * @return an &lt;code>X500Principal&lt;/code> representing the subject&#xA;     *&#x9;&#x9;distinguished name&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../../../sun/security/x509/X509CertImpl.class.xmi#//@classifiers.0/@members.102"/>
                  <arguments xsi:type="references:SelfReference">
                    <self xsi:type="literals:This"/>
                  </arguments>
                </next>
                <target xsi:type="classifiers:Class" href="../../../sun/security/x509/X509CertImpl.class.xmi#//@classifiers.0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNotBefore">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../util/Date.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the &lt;code>notBefore&lt;/code> date from the validity period of &#xA;     * the certificate.&#xA;     * The relevant ASN.1 definitions are:&#xA;     * &lt;pre>&#xA;     * validity             Validity&lt;p>&#xA;     * &#xA;     * Validity ::= SEQUENCE {&#xA;     *     notBefore      CertificateValidityDate,&#xA;     *     notAfter       CertificateValidityDate }&lt;p>&#xA;     * CertificateValidityDate ::= CHOICE {&#xA;     *     utcTime        UTCTime,&#xA;     *     generalTime    GeneralizedTime }&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @return the start date of the validity period.&#xA;     * @see #checkValidity&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNotAfter">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../util/Date.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the &lt;code>notAfter&lt;/code> date from the validity period of &#xA;     * the certificate. See {@link #getNotBefore() getNotBefore}&#xA;     * for relevant ASN.1 definitions.&#xA;     *&#xA;     * @return the end date of the validity period.&#xA;     * @see #checkValidity&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTBSCertificate">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateEncodingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the DER-encoded certificate information, the&#xA;     * &lt;code>tbsCertificate&lt;/code> from this certificate.&#xA;     * This can be used to verify the signature independently.&#xA;     *&#xA;     * @return the DER-encoded certificate information.&#xA;     * @exception CertificateEncodingException if an encoding error occurs.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSignature">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the &lt;code>signature&lt;/code> value (the raw signature bits) from &#xA;     * the certificate.&#xA;     * The ASN.1 definition for this is:&#xA;     * &lt;pre>&#xA;     * signature     BIT STRING  &#xA;     * &lt;/pre>&#xA;     *&#xA;     * @return the signature.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSigAlgName">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the signature algorithm name for the certificate&#xA;     * signature algorithm. An example is the string &quot;SHA-1/DSA&quot;.&#xA;     * The ASN.1 definition for this is:&#xA;     * &lt;pre>&#xA;     * signatureAlgorithm   AlgorithmIdentifier&lt;p>&#xA;     * AlgorithmIdentifier  ::=  SEQUENCE  {&#xA;     *     algorithm               OBJECT IDENTIFIER,&#xA;     *     parameters              ANY DEFINED BY algorithm OPTIONAL  }&#xA;     *                             -- contains a value of the type&#xA;     *                             -- registered for use with the&#xA;     *                             -- algorithm object identifier value&#xA;     * &lt;/pre>&#xA;     * &#xA;     * &lt;p>The algorithm name is determined from the &lt;code>algorithm&lt;/code>&#xA;     * OID string.&#xA;     *&#xA;     * @return the signature algorithm name.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSigAlgOID">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the signature algorithm OID string from the certificate.&#xA;     * An OID is represented by a set of nonnegative whole numbers separated&#xA;     * by periods.&#xA;     * For example, the string &quot;1.2.840.10040.4.3&quot; identifies the SHA-1&#xA;     * with DSA signature algorithm, as per RFC 2459.&#xA;     * &#xA;     * &lt;p>See {@link #getSigAlgName() getSigAlgName} for &#xA;     * relevant ASN.1 definitions.&#xA;     *&#xA;     * @return the signature algorithm OID string.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSigAlgParams">
      <typeReference xsi:type="types:Byte"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the DER-encoded signature algorithm parameters from this&#xA;     * certificate's signature algorithm. In most cases, the signature&#xA;     * algorithm parameters are null; the parameters are usually&#xA;     * supplied with the certificate's public key.&#xA;     * If access to individual parameter values is needed then use&#xA;     * {@link java.security.AlgorithmParameters AlgorithmParameters}&#xA;     * and instantiate with the name returned by&#xA;     * {@link #getSigAlgName() getSigAlgName}.&#xA;     * &#xA;     * &lt;p>See {@link #getSigAlgName() getSigAlgName} for &#xA;     * relevant ASN.1 definitions.&#xA;     *&#xA;     * @return the DER-encoded signature algorithm parameters, or&#xA;     *         null if no parameters are present.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getIssuerUniqueID">
      <typeReference xsi:type="types:Boolean"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the &lt;code>issuerUniqueID&lt;/code> value from the certificate.&#xA;     * The issuer unique identifier is present in the certificate&#xA;     * to handle the possibility of reuse of issuer names over time.&#xA;     * RFC 2459 recommends that names not be reused and that&#xA;     * conforming certificates not make use of unique identifiers.&#xA;     * Applications conforming to that profile should be capable of&#xA;     * parsing unique identifiers and making comparisons.&#xA;     * &#xA;     * &lt;p>The ASN.1 definition for this is:&#xA;     * &lt;pre>&#xA;     * issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL&lt;p>&#xA;     * UniqueIdentifier  ::=  BIT STRING&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @return the issuer unique identifier or null if it is not&#xA;     * present in the certificate.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSubjectUniqueID">
      <typeReference xsi:type="types:Boolean"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the &lt;code>subjectUniqueID&lt;/code> value from the certificate.&#xA;     * &#xA;     * &lt;p>The ASN.1 definition for this is:&#xA;     * &lt;pre>&#xA;     * subjectUniqueID  [2]  IMPLICIT UniqueIdentifier OPTIONAL&lt;p>&#xA;     * UniqueIdentifier  ::=  BIT STRING&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @return the subject unique identifier or null if it is not&#xA;     * present in the certificate.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getKeyUsage">
      <typeReference xsi:type="types:Boolean"/>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets a boolean array representing bits of&#xA;     * the &lt;code>KeyUsage&lt;/code> extension, (OID = 2.5.29.15).&#xA;     * The key usage extension defines the purpose (e.g., encipherment,&#xA;     * signature, certificate signing) of the key contained in the&#xA;     * certificate.&#xA;     * The ASN.1 definition for this is:&#xA;     * &lt;pre>&#xA;     * KeyUsage ::= BIT STRING {&#xA;     *     digitalSignature        (0),&#xA;     *     nonRepudiation          (1),&#xA;     *     keyEncipherment         (2),&#xA;     *     dataEncipherment        (3),&#xA;     *     keyAgreement            (4),&#xA;     *     keyCertSign             (5),&#xA;     *     cRLSign                 (6),&#xA;     *     encipherOnly            (7),&#xA;     *     decipherOnly            (8) }&#xA;     * &lt;/pre>&#xA;     * RFC 2459 recommends that when used, this be marked&#xA;     * as a critical extension.&#xA;     *&#xA;     * @return the KeyUsage extension of this certificate, represented as&#xA;     * an array of booleans. The order of KeyUsage values in the array is&#xA;     * the same as in the above ASN.1 definition. The array will contain a&#xA;     * value for each KeyUsage defined above. If the KeyUsage list encoded&#xA;     * in the certificate is longer than the above list, it will not be&#xA;     * truncated. Returns null if this certificate does not&#xA;     * contain a KeyUsage extension.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getExtendedKeyUsage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/List.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateParsingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets an unmodifiable list of Strings representing the OBJECT&#xA;     * IDENTIFIERs of the &lt;code>ExtKeyUsageSyntax&lt;/code> field of the&#xA;     * extended key usage extension, (OID = 2.5.29.37).  It indicates&#xA;     * one or more purposes for which the certified public key may be&#xA;     * used, in addition to or in place of the basic purposes&#xA;     * indicated in the key usage extension field.  The ASN.1&#xA;     * definition for this is:&#xA;     * &lt;pre>&#xA;     * ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId&lt;p>&#xA;     *&#xA;     * KeyPurposeId ::= OBJECT IDENTIFIER&lt;p>&#xA;     * &lt;/pre>&#xA;     *&#xA;     * Key purposes may be defined by any organization with a&#xA;     * need. Object identifiers used to identify key purposes shall be&#xA;     * assigned in accordance with IANA or ITU-T Rec. X.660 |&#xA;     * ISO/IEC/ITU 9834-1.&#xA;     * &lt;p>&#xA;     * This method was added to version 1.4 of the Java 2 Platform Standard &#xA;     * Edition. In order to maintain backwards compatibility with existing &#xA;     * service providers, this method is not &lt;code>abstract&lt;/code>&#xA;     * and it provides a default implementation. Subclasses&#xA;     * should override this method with a correct implementation.&#xA;     *&#xA;     * @return the ExtendedKeyUsage extension of this certificate,&#xA;     *         as an unmodifiable list of object identifiers represented&#xA;     *         as Strings. Returns null if this certificate does not&#xA;     *         contain an ExtendedKeyUsage extension.&#xA;     * @throws CertificateParsingException if the extension cannot be decoded&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../sun/security/x509/X509CertImpl.class.xmi#//@classifiers.0/@members.91"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="../../../sun/security/x509/X509CertImpl.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBasicConstraints">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the certificate constraints path length from the&#xA;     * critical &lt;code>BasicConstraints&lt;/code> extension, (OID = 2.5.29.19).&#xA;     * &lt;p>&#xA;     * The basic constraints extension identifies whether the subject&#xA;     * of the certificate is a Certificate Authority (CA) and &#xA;     * how deep a certification path may exist through that CA. The &#xA;     * &lt;code>pathLenConstraint&lt;/code> field (see below) is meaningful&#xA;     * only if &lt;code>cA&lt;/code> is set to TRUE. In this case, it gives the&#xA;     * maximum number of CA certificates that may follow this certificate in a&#xA;     * certification path. A value of zero indicates that only an end-entity&#xA;     * certificate may follow in the path.&#xA;     * &lt;p>&#xA;     * Note that for RFC 2459 this extension is always marked&#xA;     * critical if &lt;code>cA&lt;/code> is TRUE, meaning this certificate belongs&#xA;     * to a Certificate Authority.&#xA;     * &lt;p>&#xA;     * The ASN.1 definition for this is:&#xA;     * &lt;pre>&#xA;     * BasicConstraints ::= SEQUENCE {&#xA;     *     cA                  BOOLEAN DEFAULT FALSE,&#xA;     *     pathLenConstraint   INTEGER (0..MAX) OPTIONAL }&#xA;     * &lt;/pre>&#xA;     *&#xA;     * @return the value of &lt;code>pathLenConstraint&lt;/code> if the&#xA;     * BasicConstraints extension is present in the certificate and the&#xA;     * subject of the certificate is a CA, otherwise -1.&#xA;     * If the subject of the certificate is a CA and&#xA;     * &lt;code>pathLenConstraint&lt;/code> does not appear,&#xA;     * &lt;code>Integer.MAX_VALUE&lt;/code> is returned to indicate that there is no&#xA;     * limit to the allowed length of the certification path.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getSubjectAlternativeNames">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <typeArguments xsi:type="generics:UnknownTypeArgument"/>
                <target xsi:type="classifiers:Interface" href="../../util/List.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateParsingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets an immutable collection of subject alternative names from the&#xA;     * &lt;code>SubjectAltName&lt;/code> extension, (OID = 2.5.29.17).&#xA;     * &lt;p>&#xA;     * The ASN.1 definition of the &lt;code>SubjectAltName&lt;/code> extension is:&#xA;     * &lt;pre>&#xA;     * SubjectAltName ::= GeneralNames&#xA;     *&#xA;     * GeneralNames :: = SEQUENCE SIZE (1..MAX) OF GeneralName&#xA;     *&#xA;     * GeneralName ::= CHOICE {&#xA;     *      otherName                       [0]     OtherName,&#xA;     *      rfc822Name                      [1]     IA5String,&#xA;     *      dNSName                         [2]     IA5String,&#xA;     *      x400Address                     [3]     ORAddress,&#xA;     *      directoryName                   [4]     Name,&#xA;     *      ediPartyName                    [5]     EDIPartyName,&#xA;     *      uniformResourceIdentifier       [6]     IA5String,&#xA;     *      iPAddress                       [7]     OCTET STRING,&#xA;     *      registeredID                    [8]     OBJECT IDENTIFIER}&#xA;     * &lt;/pre>&#xA;     * &lt;p>&#xA;     * If this certificate does not contain a &lt;code>SubjectAltName&lt;/code>&#xA;     * extension, &lt;code>null&lt;/code> is returned. Otherwise, a &#xA;     * &lt;code>Collection&lt;/code> is returned with an entry representing each &#xA;     * &lt;code>GeneralName&lt;/code> included in the extension. Each entry is a &#xA;     * &lt;code>List&lt;/code> whose first entry is an &lt;code>Integer&lt;/code> &#xA;     * (the name type, 0-8) and whose second entry is a &lt;code>String&lt;/code> &#xA;     * or a byte array (the name, in string or ASN.1 DER encoded form, &#xA;     * respectively).&#xA;     * &lt;p>&#xA;     * RFC 822, DNS, and URI names are returned as &lt;code>String&lt;/code>s, &#xA;     * using the well-established string formats for those types (subject to&#xA;     * the restrictions included in RFC 2459). IPv4 address names are &#xA;     * returned using dotted quad notation. IPv6 address names are returned&#xA;     * in the form &quot;a1:a2:...:a8&quot;, where a1-a8 are hexadecimal values &#xA;     * representing the eight 16-bit pieces of the address. OID names are &#xA;     * returned as &lt;code>String&lt;/code>s represented as a series of nonnegative &#xA;     * integers separated by periods. And directory names (distinguished names) &#xA;     * are returned in RFC 2253 string format. No standard string format is &#xA;     * defined for otherNames, X.400 names, EDI party names, or any &#xA;     * other type of names. They are returned as byte arrays &#xA;     * containing the ASN.1 DER encoded form of the name.&#xA;     * &lt;p>&#xA;     * Note that the &lt;code>Collection&lt;/code> returned may contain more&#xA;     * than one name of the same type. Also, note that the returned&#xA;     * &lt;code>Collection&lt;/code> is immutable and any entries containing byte &#xA;     * arrays are cloned to protect against subsequent modifications.&#xA;     * &lt;p>&#xA;     * This method was added to version 1.4 of the Java 2 Platform Standard &#xA;     * Edition. In order to maintain backwards compatibility with existing &#xA;     * service providers, this method is not &lt;code>abstract&lt;/code>&#xA;     * and it provides a default implementation. Subclasses&#xA;     * should override this method with a correct implementation.&#xA;     *&#xA;     * @return an immutable &lt;code>Collection&lt;/code> of subject alternative &#xA;     * names (or &lt;code>null&lt;/code>)&#xA;     * @throws CertificateParsingException if the extension cannot be decoded&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../sun/security/x509/X509CertImpl.class.xmi#//@classifiers.0/@members.96"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="../../../sun/security/x509/X509CertImpl.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getIssuerAlternativeNames">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <typeArguments xsi:type="generics:UnknownTypeArgument"/>
                <target xsi:type="classifiers:Interface" href="../../util/List.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Interface" href="../../util/Collection.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="CertificateParsingException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets an immutable collection of issuer alternative names from the&#xA;     * &lt;code>IssuerAltName&lt;/code> extension, (OID = 2.5.29.18).&#xA;     * &lt;p>&#xA;     * The ASN.1 definition of the &lt;code>IssuerAltName&lt;/code> extension is:&#xA;     * &lt;pre>&#xA;     * IssuerAltName ::= GeneralNames&#xA;     * &lt;/pre>&#xA;     * The ASN.1 definition of &lt;code>GeneralNames&lt;/code> is defined&#xA;     * in {@link #getSubjectAlternativeNames getSubjectAlternativeNames}.&#xA;     * &lt;p>&#xA;     * If this certificate does not contain an &lt;code>IssuerAltName&lt;/code>&#xA;     * extension, &lt;code>null&lt;/code> is returned. Otherwise, a &#xA;     * &lt;code>Collection&lt;/code> is returned with an entry representing each &#xA;     * &lt;code>GeneralName&lt;/code> included in the extension. Each entry is a &#xA;     * &lt;code>List&lt;/code> whose first entry is an &lt;code>Integer&lt;/code> &#xA;     * (the name type, 0-8) and whose second entry is a &lt;code>String&lt;/code> &#xA;     * or a byte array (the name, in string or ASN.1 DER encoded form, &#xA;     * respectively). For more details about the formats used for each&#xA;     * name type, see the &lt;code>getSubjectAlternativeNames&lt;/code> method.&#xA;     * &lt;p>&#xA;     * Note that the &lt;code>Collection&lt;/code> returned may contain more&#xA;     * than one name of the same type. Also, note that the returned&#xA;     * &lt;code>Collection&lt;/code> is immutable and any entries containing byte &#xA;     * arrays are cloned to protect against subsequent modifications.&#xA;     * &lt;p>&#xA;     * This method was added to version 1.4 of the Java 2 Platform Standard &#xA;     * Edition. In order to maintain backwards compatibility with existing &#xA;     * service providers, this method is not &lt;code>abstract&lt;/code>&#xA;     * and it provides a default implementation. Subclasses&#xA;     * should override this method with a correct implementation.&#xA;     *&#xA;     * @return an immutable &lt;code>Collection&lt;/code> of issuer alternative &#xA;     * names (or &lt;code>null&lt;/code>)&#xA;     * @throws CertificateParsingException if the extension cannot be decoded&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../sun/security/x509/X509CertImpl.class.xmi#//@classifiers.0/@members.98"/>
            <arguments xsi:type="references:SelfReference">
              <self xsi:type="literals:This"/>
            </arguments>
          </next>
          <target xsi:type="classifiers:Class" href="../../../sun/security/x509/X509CertImpl.class.xmi#//@classifiers.0"/>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;p>&#xA; * Abstract class for X.509 certificates. This provides a standard&#xA; * way to access all the attributes of an X.509 certificate.&#xA; * &lt;p>&#xA; * In June of 1996, the basic X.509 v3 format was completed by&#xA; * ISO/IEC and ANSI X9, which is described below in ASN.1:&#xA; * &lt;pre>&#xA; * Certificate  ::=  SEQUENCE  {&#xA; *     tbsCertificate       TBSCertificate,&#xA; *     signatureAlgorithm   AlgorithmIdentifier,&#xA; *     signature            BIT STRING  }&#xA; * &lt;/pre>&#xA; * &lt;p>&#xA; * These certificates are widely used to support authentication and&#xA; * other functionality in Internet security systems. Common applications&#xA; * include Privacy Enhanced Mail (PEM), Transport Layer Security (SSL),&#xA; * code signing for trusted software distribution, and Secure Electronic&#xA; * Transactions (SET).&#xA; * &lt;p>&#xA; * These certificates are managed and vouched for by &lt;em>Certificate&#xA; * Authorities&lt;/em> (CAs). CAs are services which create certificates by&#xA; * placing data in the X.509 standard format and then digitally signing&#xA; * that data. CAs act as trusted third parties, making introductions&#xA; * between principals who have no direct knowledge of each other.&#xA; * CA certificates are either signed by themselves, or by some other&#xA; * CA such as a &quot;root&quot; CA.&#xA; * &lt;p>&#xA; * More information can be found in RFC 2459,&#xA; * &quot;Internet X.509 Public Key Infrastructure Certificate and CRL&#xA; * Profile&quot; at &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2459.txt&quot;> &#xA; * http://www.ietf.org/rfc/rfc2459.txt &lt;/A>.&#xA; * &lt;p>&#xA; * The ASN.1 definition of &lt;code>tbsCertificate&lt;/code> is:&#xA; * &lt;pre>&#xA; * TBSCertificate  ::=  SEQUENCE  {&#xA; *     version         [0]  EXPLICIT Version DEFAULT v1,&#xA; *     serialNumber         CertificateSerialNumber,&#xA; *     signature            AlgorithmIdentifier,&#xA; *     issuer               Name,&#xA; *     validity             Validity,&#xA; *     subject              Name,&#xA; *     subjectPublicKeyInfo SubjectPublicKeyInfo,&#xA; *     issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,&#xA; *                          -- If present, version must be v2 or v3&#xA; *     subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,&#xA; *                          -- If present, version must be v2 or v3&#xA; *     extensions      [3]  EXPLICIT Extensions OPTIONAL&#xA; *                          -- If present, version must be v3&#xA; *     }&#xA; * &lt;/pre>&#xA; * &lt;p>&#xA; * Certificates are instantiated using a certificate factory. The following is&#xA; * an example of how to instantiate an X.509 certificate:&#xA; * &lt;pre> &#xA; * InputStream inStream = new FileInputStream(&quot;fileName-of-cert&quot;);&#xA; * CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);&#xA; * X509Certificate cert = (X509Certificate)cf.generateCertificate(inStream);&#xA; * inStream.close();&#xA; * &lt;/pre>&#xA; *&#xA; * @author Hemma Prafullchandra&#xA; *&#xA; * @version 1.39&#xA; *&#xA; * @see Certificate&#xA; * @see CertificateFactory&#xA; * @see X509Extension&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="X509Extension.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Certificate.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
