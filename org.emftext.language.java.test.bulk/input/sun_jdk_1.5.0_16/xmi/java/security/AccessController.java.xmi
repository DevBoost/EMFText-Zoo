<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="AccessController.java">
  <comments>/*&#xA; * @(#)AccessController.java&#x9;1.55 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>security</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>security</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/security/util/Debug.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="AccessController">
    <members xsi:type="members:Constructor" name="AccessController">
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/** &#xA;     * Don't allow anyone to instantiate an AccessController&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="doPrivileged">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.1/@typeParameters.0"/>
      </typeReference>
      <typeParameters name="T"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="action">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.1/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="PrivilegedAction.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Performs the specified &lt;code>PrivilegedAction&lt;/code> with privileges&#xA;     * enabled. The action is performed with &lt;i>all&lt;/i> of the permissions &#xA;     * possessed by the caller's protection domain.&#xA;     * &lt;p>&#xA;     * If the action's &lt;code>run&lt;/code> method throws an (unchecked) exception,&#xA;     * it will propagate through this method.&#xA;     *&#xA;     * @param action the action to be performed.&#xA;     *&#xA;     * @return the value returned by the action's &lt;code>run&lt;/code> method.&#xA;     *&#xA;     * @exception NullPointerException if the action is &lt;code>null&lt;/code>&#xA;     *&#xA;     * @see #doPrivileged(PrivilegedAction,AccessControlContext)&#xA;     * @see #doPrivileged(PrivilegedExceptionAction)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="doPrivileged">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.2/@typeParameters.0"/>
      </typeReference>
      <typeParameters name="T"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="action">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.2/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="PrivilegedAction.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="context">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="AccessControlContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Performs the specified &lt;code>PrivilegedAction&lt;/code> with privileges&#xA;     * enabled and restricted by the specified&#xA;     * &lt;code>AccessControlContext&lt;/code>.&#xA;     * The action is performed with the intersection of the permissions&#xA;     * possessed by the caller's protection domain, and those possessed&#xA;     * by the domains represented by the specified&#xA;     * &lt;code>AccessControlContext&lt;/code>.&#xA;     * &lt;p>&#xA;     * If the action's &lt;code>run&lt;/code> method throws an (unchecked) exception,&#xA;     * it will propagate through this method.&#xA;     *&#xA;     * @param action the action to be performed.&#xA;     * @param context an &lt;i>access control context&lt;/i>&#xA;     *                representing the restriction to be applied to the&#xA;     *                caller's domain's privileges before performing&#xA;     *                the specified action.  If the context is&#xA;     *                &lt;code>null&lt;/code>,&#xA;     *                then no additional restriction is applied.&#xA;     *&#xA;     * @return the value returned by the action's &lt;code>run&lt;/code> method.&#xA;     *&#xA;     * @exception NullPointerException if the action is &lt;code>null&lt;/code>&#xA;     * &#xA;     * @see #doPrivileged(PrivilegedAction)&#xA;     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="doPrivileged">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.3/@typeParameters.0"/>
      </typeReference>
      <typeParameters name="T"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="action">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.3/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="PrivilegedExceptionAction.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="PrivilegedActionException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Performs the specified &lt;code>PrivilegedExceptionAction&lt;/code> with&#xA;     * privileges enabled.  The action is performed with &lt;i>all&lt;/i> of the &#xA;     * permissions possessed by the caller's protection domain.&#xA;     * &lt;p>&#xA;     * If the action's &lt;code>run&lt;/code> method throws an &lt;i>unchecked&lt;/i>&#xA;     * exception, it will propagate through this method.&#xA;     *&#xA;     * @param action the action to be performed&#xA;     *&#xA;     * @return the value returned by the action's &lt;code>run&lt;/code> method&#xA;     *&#xA;     * @exception PrivilegedActionException if the specified action's&#xA;     *         &lt;code>run&lt;/code> method threw a &lt;i>checked&lt;/i> exception&#xA;     * @exception NullPointerException if the action is &lt;code>null&lt;/code>&#xA;     * &#xA;     * @see #doPrivileged(PrivilegedAction)&#xA;     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="doPrivileged">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0/@members.4/@typeParameters.0"/>
      </typeReference>
      <typeParameters name="T"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="action">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:QualifiedTypeArgument">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0/@members.4/@typeParameters.0"/>
              </typeReference>
            </typeArguments>
            <target xsi:type="classifiers:Interface" href="PrivilegedExceptionAction.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="context">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="AccessControlContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="PrivilegedActionException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Performs the specified &lt;code>PrivilegedExceptionAction&lt;/code> with &#xA;     * privileges enabled and restricted by the specified&#xA;     * &lt;code>AccessControlContext&lt;/code>.  The action is performed with the&#xA;     * intersection of the the permissions possessed by the caller's&#xA;     * protection domain, and those possessed by the domains represented by the&#xA;     * specified &lt;code>AccessControlContext&lt;/code>.&#xA;     * &lt;p>&#xA;     * If the action's &lt;code>run&lt;/code> method throws an &lt;i>unchecked&lt;/i>&#xA;     * exception, it will propagate through this method.&#xA;     *&#xA;     * @param action the action to be performed&#xA;     * @param context an &lt;i>access control context&lt;/i>&#xA;     *                representing the restriction to be applied to the&#xA;     *                caller's domain's privileges before performing&#xA;     *                the specified action.  If the context is&#xA;     *                &lt;code>null&lt;/code>,&#xA;     *                then no additional restriction is applied.&#xA;     *&#xA;     * @return the value returned by the action's &lt;code>run&lt;/code> method&#xA;     *&#xA;     * @exception PrivilegedActionException if the specified action's&#xA;     *         &lt;code>run&lt;/code> method&#xA;     *&#x9;       threw a &lt;i>checked&lt;/i> exception&#xA;     * @exception NullPointerException if the action is &lt;code>null&lt;/code>&#xA;     * &#xA;     * @see #doPrivileged(PrivilegedAction)&#xA;     * @see #doPrivileged(PrivilegedExceptionAction,AccessControlContext)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getStackAccessControlContext">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="AccessControlContext.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private">
        <comments>/**&#xA;     * Returns the AccessControl context. i.e., it gets &#xA;     * the protection domains of all the callers on the stack,&#xA;     * starting at the first class with a non-null &#xA;     * ProtectionDomain. &#xA;     *&#xA;     * @return the access control context based on the current stack or&#xA;     *         null if there was only privileged system code.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getInheritedAccessControlContext">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="AccessControlContext.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * Returns the &quot;inherited&quot; AccessControl context. This is the context&#xA;     * that existed when the thread was created. Package private so &#xA;     * AccessControlContext can use it.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getContext">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="AccessControlContext.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * This method takes a &quot;snapshot&quot; of the current calling context, which&#xA;     * includes the current Thread's inherited AccessControlContext,&#xA;     * and places it in an AccessControlContext object. This context may then&#xA;     * be checked at a later point, possibly in another thread.&#xA;     *&#xA;     * @see AccessControlContext&#xA;     *&#xA;     * @return the AccessControlContext based on the current context.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="acc">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="AccessControlContext.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.5"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <comments>// all we had was privileged system code. We don't want</comments>
            <comments>// to return null though, so we construct a real ACC.</comments>
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="AccessControlContext.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="literals:NullLiteral"/>
              <arguments xsi:type="literals:BooleanLiteral" value="true"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@statements.0/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="AccessControlContext.class.xmi#//@classifiers.0/@members.13"/>
              </next>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="checkPermission">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="perm">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Permission.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="AccessControlException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Determines whether the access request indicated by the&#xA;     * specified permission should be allowed or denied, based on&#xA;     * the security policy currently in effect. &#xA;     * This method quietly returns if the access request&#xA;     * is permitted, or throws a suitable AccessControlException otherwise. &#xA;     *&#xA;     * @param perm the requested permission.&#xA;     * &#xA;     * @exception AccessControlException if the specified permission&#xA;     *            is not permitted, based on the current security policy.&#xA;     * @exception NullPointerException if the specified permission&#xA;     *            is &lt;code>null&lt;/code> and is checked based on the&#xA;     *            security policy currently in effect.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="stack">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>//System.err.println(&quot;checkPermission &quot;+perm);</comments>
              <comments>//Thread.currentThread().dumpStack();</comments>
              <target xsi:type="classifiers:Class" href="AccessControlContext.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.5"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// if context is null, we had privileged system code on the stack.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="debug">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../sun/security/util/Debug.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="AccessControlContext.class.xmi#//@classifiers.0/@members.6"/>
                </next>
                <target xsi:type="classifiers:Class" href="AccessControlContext.class.xmi#//@classifiers.0"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:ExpressionStatement">
                  <expression xsi:type="references:IdentifierReference">
                    <next xsi:type="references:MethodCall">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.71"/>
                      </next>
                      <target xsi:type="members:ClassMethod" href="../lang/Thread.class.xmi#//@classifiers.0/@members.33"/>
                    </next>
                    <target xsi:type="classifiers:Class" href="../lang/Thread.class.xmi#//@classifiers.0"/>
                  </expression>
                </statement>
                <condition xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../sun/security/util/Debug.class.xmi#//@classifiers.0/@members.6"/>
                    <arguments xsi:type="references:StringReference" value="stack"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../../sun/security/util/Debug.class.xmi#//@classifiers.0"/>
                </condition>
              </statements>
              <statements xsi:type="statements:Condition">
                <statement xsi:type="statements:Block">
                  <statements xsi:type="statements:ExpressionStatement">
                    <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@statement/@statements.0/@variable">
                      <next xsi:type="references:MethodCall">
                        <target xsi:type="members:ClassMethod" href="../../sun/security/util/Debug.class.xmi#//@classifiers.0/@members.7"/>
                        <arguments xsi:type="references:StringReference" value="domain (context is null)"/>
                      </next>
                    </expression>
                  </statements>
                </statement>
                <condition xsi:type="references:IdentifierReference">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../sun/security/util/Debug.class.xmi#//@classifiers.0/@members.6"/>
                    <arguments xsi:type="references:StringReference" value="domain"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="../../sun/security/util/Debug.class.xmi#//@classifiers.0"/>
                </condition>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@statement/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="../../sun/security/util/Debug.class.xmi#//@classifiers.0/@members.7"/>
                    <arguments xsi:type="expressions:AdditiveExpression">
                      <children xsi:type="references:StringReference" value="access allowed "/>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
                      <additiveOperators xsi:type="operators:Addition"/>
                    </arguments>
                  </next>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:NotEqual"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.1/@statement/@statements.0/@variable"/>
              <children xsi:type="literals:NullLiteral"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="acc">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="AccessControlContext.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="AccessControlContext.class.xmi#//@classifiers.0/@members.13"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@statements.2/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="AccessControlContext.class.xmi#//@classifiers.0/@members.12"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
          </next>
        </expression>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/** &#xA; * &lt;p> The AccessController class is used for access control operations&#xA; * and decisions.&#xA; * &#xA; * &lt;p> More specifically, the AccessController class is used for &#xA; * three purposes:&#xA; * &#xA; * &lt;ul>&#xA; * &lt;li> to decide whether an access to a critical system&#xA; * resource is to be allowed or denied, based on the security policy&#xA; * currently in effect,&lt;p> &#xA; * &lt;li>to mark code as being &quot;privileged&quot;, thus affecting subsequent&#xA; * access determinations, and&lt;p>&#xA; * &lt;li>to obtain a &quot;snapshot&quot; of the current calling context so&#xA; * access-control decisions from a different context can be made with&#xA; * respect to the saved context. &lt;/ul>&#xA; * &#xA; * &lt;p> The {@link #checkPermission(Permission) checkPermission} method&#xA; * determines whether the access request indicated by a specified&#xA; * permission should be granted or denied. A sample call appears&#xA; * below. In this example, &lt;code>checkPermission&lt;/code> will determine &#xA; * whether or not to grant &quot;read&quot; access to the file named &quot;testFile&quot; in &#xA; * the &quot;/temp&quot; directory.&#xA; * &#xA; * &lt;pre>&#xA; * &#xA; *    FilePermission perm = new FilePermission(&quot;/temp/testFile&quot;, &quot;read&quot;);&#xA; *    AccessController.checkPermission(perm);&#xA; * &#xA; * &lt;/pre>&#xA; *&#xA; * &lt;p> If a requested access is allowed, &#xA; * &lt;code>checkPermission&lt;/code> returns quietly. If denied, an &#xA; * AccessControlException is&#xA; * thrown. AccessControlException can also be thrown if the requested&#xA; * permission is of an incorrect type or contains an invalid value.&#xA; * Such information is given whenever possible.&#xA; * &#xA; * Suppose the current thread traversed m callers, in the order of caller 1 &#xA; * to caller 2 to caller m. Then caller m invoked the &#xA; * &lt;code>checkPermission&lt;/code> method.&#xA; * The &lt;code>checkPermission &lt;/code>method determines whether access &#xA; * is granted or denied based on the following algorithm:&#xA; * &#xA; * &lt;pre>&#xA; * i = m;&#xA; * &#xA; * while (i > 0) {&#xA; * &#xA; *      if (caller i's domain does not have the permission)&#xA; *              throw AccessControlException&#xA; * &#xA; *      else if (caller i is marked as privileged) {&#xA; *              if (a context was specified in the call to doPrivileged) &#xA; *                 context.checkPermission(permission)&#xA; *              return;&#xA; *      }&#xA; *      i = i - 1;&#xA; * };&#xA; *&#xA; *    // Next, check the context inherited when&#xA; *    // the thread was created. Whenever a new thread is created, the&#xA; *    // AccessControlContext at that time is&#xA; *    // stored and associated with the new thread, as the &quot;inherited&quot;&#xA; *    // context.&#xA; * &#xA; * inheritedContext.checkPermission(permission);&#xA; * &lt;/pre>&#xA; * &#xA; * &lt;p> A caller can be marked as being &quot;privileged&quot; &#xA; * (see {@link #doPrivileged(PrivilegedAction) doPrivileged} and below). &#xA; * When making access control decisions, the &lt;code>checkPermission&lt;/code>&#xA; * method stops checking if it reaches a caller that &#xA; * was marked as &quot;privileged&quot; via a &lt;code>doPrivileged&lt;/code> &#xA; * call without a context argument (see below for information about a&#xA; * context argument). If that caller's domain has the&#xA; * specified permission, no further checking is done and &#xA; * &lt;code>checkPermission&lt;/code>&#xA; * returns quietly, indicating that the requested access is allowed.&#xA; * If that domain does not have the specified permission, an exception&#xA; * is thrown, as usual.&#xA; * &#xA; * &lt;p> The normal use of the &quot;privileged&quot; feature is as follows. If you&#xA; * don't need to return a value from within the &quot;privileged&quot; block, do &#xA; * the following:&#xA; *&#xA; * &lt;pre>&#xA; *   somemethod() {&#xA; *        ...normal code here...&#xA; *        AccessController.doPrivileged(new PrivilegedAction() {&#xA; *            public Object run() {&#xA; *                // privileged code goes here, for example:&#xA; *                System.loadLibrary(&quot;awt&quot;);&#xA; *                return null; // nothing to return&#xA; *            }&#xA; *        });&#xA;  *       ...normal code here...&#xA; *  }&#xA; * &lt;/pre>&#xA; *&#xA; * &lt;p>&#xA; * PrivilegedAction is an interface with a single method, named&#xA; * &lt;code>run&lt;/code>, that returns an Object.&#xA; * The above example shows creation of an implementation&#xA; * of that interface; a concrete implementation of the&#xA; * &lt;code>run&lt;/code> method is supplied.&#xA; * When the call to &lt;code>doPrivileged&lt;/code> is made, an &#xA; * instance of the PrivilegedAction implementation is passed&#xA; * to it. The &lt;code>doPrivileged&lt;/code> method calls the&#xA; * &lt;code>run&lt;/code> method from the PrivilegedAction &#xA; * implementation after enabling privileges, and returns the &#xA; * &lt;code>run&lt;/code> method's return value as the &#xA; * &lt;code>doPrivileged&lt;/code> return value (which is&#xA; * ignored in this example).&#xA; *&#xA; * &lt;p> If you need to return a value, you can do something like the following:&#xA; *&#xA; * &lt;pre>&#xA; *   somemethod() {&#xA; *        ...normal code here...&#xA; *        String user = (String) AccessController.doPrivileged(&#xA; *          new PrivilegedAction() {&#xA; *            public Object run() {&#xA; *                return System.getProperty(&quot;user.name&quot;);&#xA; *            }&#xA; *          }&#xA; *        );&#xA; *        ...normal code here...&#xA; *  }&#xA; * &lt;/pre>&#xA; *&#xA; * &lt;p>If the action performed in your &lt;code>run&lt;/code> method could&#xA; * throw a &quot;checked&quot; exception (those listed in the &lt;code>throws&lt;/code> clause&#xA; * of a method), then you need to use the &#xA; * &lt;code>PrivilegedExceptionAction&lt;/code> interface instead of the&#xA; * &lt;code>PrivilegedAction&lt;/code> interface:&#xA; * &#xA; * &lt;pre>&#xA; *   somemethod() throws FileNotFoundException {&#xA; *        ...normal code here...&#xA; *      try {&#xA; *        FileInputStream fis = (FileInputStream) AccessController.doPrivileged(&#xA; *          new PrivilegedExceptionAction() {&#xA; *            public Object run() throws FileNotFoundException {&#xA; *                return new FileInputStream(&quot;someFile&quot;);&#xA; *            }&#xA; *          }&#xA; *        );&#xA; *      } catch (PrivilegedActionException e) {&#xA; *        // e.getException() should be an instance of FileNotFoundException,&#xA; *        // as only &quot;checked&quot; exceptions will be &quot;wrapped&quot; in a&#xA; *        // &lt;code>PrivilegedActionException&lt;/code>.&#xA; *        throw (FileNotFoundException) e.getException();&#xA; *      }&#xA; *        ...normal code here...&#xA; *  }&#xA; * &lt;/pre>&#xA; * &#xA; * &lt;p> Be *very* careful in your use of the &quot;privileged&quot; construct, and &#xA; * always remember to make the privileged code section as small as possible.&#xA; * &#xA; * &lt;p> Note that &lt;code>checkPermission&lt;/code> always performs security checks&#xA; * within the context of the currently executing thread.&#xA; * Sometimes a security check that should be made within a given context&#xA; * will actually need to be done from within a&#xA; * &lt;i>different&lt;/i> context (for example, from within a worker thread).&#xA; * The {@link #getContext() getContext} method and &#xA; * AccessControlContext class are provided &#xA; * for this situation. The &lt;code>getContext&lt;/code> method takes a &quot;snapshot&quot;&#xA; * of the current calling context, and places&#xA; * it in an AccessControlContext object, which it returns. A sample call is&#xA; * the following:&#xA; * &#xA; * &lt;pre>&#xA; * &#xA; *   AccessControlContext acc = AccessController.getContext()&#xA; * &#xA; * &lt;/pre>&#xA; * &#xA; * &lt;p>&#xA; * AccessControlContext itself has a &lt;code>checkPermission&lt;/code> method&#xA; * that makes access decisions based on the context &lt;i>it&lt;/i> encapsulates,&#xA; * rather than that of the current execution thread.&#xA; * Code within a different context can thus call that method on the&#xA; * previously-saved AccessControlContext object. A sample call is the&#xA; * following:&#xA; * &#xA; * &lt;pre>&#xA; * &#xA; *   acc.checkPermission(permission)&#xA; * &#xA; * &lt;/pre> &#xA; *&#xA; * &lt;p> There are also times where you don't know a priori which permissions&#xA; * to check the context against. In these cases you can use the&#xA; * doPrivileged method that takes a context:&#xA; * &#xA; * &lt;pre>&#xA; *   somemethod() {&#xA; *         AccessController.doPrivileged(new PrivilegedAction() {&#xA; *              public Object run() {&#xA; *                 // Code goes here. Any permission checks within this&#xA; *                 // run method will require that the intersection of the&#xA; *                 // callers protection domain and the snapshot's&#xA; *                 // context have the desired permission.&#xA; *              }&#xA; *         }, acc);&#xA; *         ...normal code here...&#xA; *   }&#xA; * &lt;/pre>&#xA; * &#xA; * @see AccessControlContext&#xA; *&#xA; * @version 1.55 04/05/05&#xA; * @author Li Gong &#xA; * @author Roland Schemers&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
  </classifiers>
</containers:CompilationUnit>
