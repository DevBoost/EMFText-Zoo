<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="SecurityPermission.java">
  <comments>/*&#xA; * @(#)SecurityPermission.java&#x9;1.27 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>security</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>security</namespaces>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../util/Enumeration.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/Hashtable.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../util/StringTokenizer.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="SecurityPermission">
    <members xsi:type="members:Field" name="serialVersionUID">
      <initialValue xsi:type="literals:DecimalLongLiteral" decimalValue="5236109936224050470"/>
      <typeReference xsi:type="types:Long"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Constructor" name="SecurityPermission">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new SecurityPermission with the specified name.&#xA;     * The name is the symbolic name of the SecurityPermission. An asterisk&#xA;     * may appear at the end of the name, following a &quot;.&quot;, or by itself, to&#xA;     * signify a wildcard match.&#xA;     *&#xA;     * @param name the name of the SecurityPermission&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="SecurityPermission">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
          <callTarget xsi:type="literals:Super"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="actions">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new SecurityPermission object with the specified name.&#xA;     * The name is the symbolic name of the SecurityPermission, and the&#xA;     * actions String is currently unused and should be null.&#xA;     *&#xA;     * @param name the name of the SecurityPermission&#xA;     * @param actions should be null.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This class is for security permissions.&#xA; * A SecurityPermission contains a name (also referred to as a &quot;target name&quot;)&#xA; * but no actions list; you either have the named permission&#xA; * or you don't.&#xA; * &lt;P>&#xA; * The target name is the name of a security configuration parameter (see below).&#xA; * Currently the SecurityPermission object is used to guard access&#xA; * to the Policy, Security, Provider, Signer, and Identity&#xA; * objects.&#xA; * &lt;P>&#xA; * The following table lists all the possible SecurityPermission target names,&#xA; * and for each provides a description of what the permission allows&#xA; * and a discussion of the risks of granting code the permission.&#xA; * &lt;P>&#xA; *&#xA; * &lt;table border=1 cellpadding=5 summary=&quot;target name,what the permission allows, and associated risks&quot;>&#xA; * &lt;tr>&#xA; * &lt;th>Permission Target Name&lt;/th>&#xA; * &lt;th>What the Permission Allows&lt;/th>&#xA; * &lt;th>Risks of Allowing this Permission&lt;/th>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>createAccessControlContext&lt;/td>&#xA; *   &lt;td>Creation of an AccessControlContext&lt;/td>&#xA; *   &lt;td>This allows someone to instantiate an AccessControlContext&#xA; * with a &lt;code>DomainCombiner&lt;/code>.  Since DomainCombiners are given&#xA; * a reference to the ProtectionDomains currently on the stack,&#xA; * this could potentially lead to a privacy leak if the DomainCombiner&#xA; * is malicious.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>getDomainCombiner&lt;/td>&#xA; *   &lt;td>Retrieval of an AccessControlContext's DomainCombiner&lt;/td>&#xA; *   &lt;td>This allows someone to retrieve an AccessControlContext's&#xA; * &lt;code>DomainCombiner&lt;/code>.  Since DomainCombiners may contain&#xA; * sensitive information, this could potentially lead to a privacy leak.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>getPolicy&lt;/td>&#xA; *   &lt;td>Retrieval of the system-wide security policy (specifically, of the&#xA; * currently-installed Policy object)&lt;/td>&#xA; *   &lt;td>This allows someone to query the policy via the&#xA; * &lt;code>getPermissions&lt;/code> call,&#xA; * which discloses which permissions would be granted to a given CodeSource.&#xA; * While revealing the policy does not compromise the security of&#xA; * the system, it does provide malicious code with additional information&#xA; * which it may use to better aim an attack. It is wise&#xA; * not to divulge more information than necessary.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>setPolicy&lt;/td>&#xA; *   &lt;td>Setting of the system-wide security policy (specifically,&#xA; * the Policy object)&lt;/td>&#xA; *   &lt;td>Granting this permission is extremely dangerous, as malicious&#xA; * code may grant itself all the necessary permissions it needs&#xA; * to successfully mount an attack on the system.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>getProperty.{key}&lt;/td>&#xA; *   &lt;td>Retrieval of the security property with the specified key&lt;/td>&#xA; *   &lt;td>Depending on the particular key for which access has&#xA; * been granted, the code may have access to the list of security&#xA; * providers, as well as the location of the system-wide and user&#xA; * security policies.  while revealing this information does not&#xA; * compromise the security of the system, it does provide malicious&#xA; * code with additional information which it may use to better aim&#xA; * an attack.&#xA;&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>setProperty.{key}&lt;/td>&#xA; *   &lt;td>Setting of the security property with the specified key&lt;/td>&#xA; *   &lt;td>This could include setting a security provider or defining&#xA; * the location of the the system-wide security policy.  Malicious&#xA; * code that has permission to set a new security provider may&#xA; * set a rogue provider that steals confidential information such&#xA; * as cryptographic private keys. In addition, malicious code with&#xA; * permission to set the location of the system-wide security policy&#xA; * may point it to a security policy that grants the attacker&#xA; * all the necessary permissions it requires to successfully mount&#xA; * an attack on the system.&#xA;&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>insertProvider.{provider name}&lt;/td>&#xA; *   &lt;td>Addition of a new provider, with the specified name&lt;/td>&#xA; *   &lt;td>This would allow somebody to introduce a possibly&#xA; * malicious provider (e.g., one that discloses the private keys passed&#xA; * to it) as the highest-priority provider. This would be possible&#xA; * because the Security object (which manages the installed providers)&#xA; * currently does not check the integrity or authenticity of a provider&#xA; * before attaching it.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>removeProvider.{provider name}&lt;/td>&#xA; *   &lt;td>Removal of the specified provider&lt;/td>&#xA; *   &lt;td>This may change the behavior or disable execution of other&#xA; * parts of the program. If a provider subsequently requested by the&#xA; * program has been removed, execution may fail. Also, if the removed&#xA; * provider is not explicitly requested by the rest of the program, but&#xA; * it would normally be the provider chosen when a cryptography service&#xA; * is requested (due to its previous order in the list of providers),&#xA; * a different provider will be chosen instead, or no suitable provider&#xA; * will be found, thereby resulting in program failure.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>setSystemScope&lt;/td>&#xA; *   &lt;td>Setting of the system identity scope&lt;/td>&#xA; *   &lt;td>This would allow an attacker to configure the system identity scope with&#xA; * certificates that should not be trusted, thereby granting applet or&#xA; * application code signed with those certificates privileges that&#xA; * would have been denied by the system's original identity scope&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>setIdentityPublicKey&lt;/td>&#xA; *   &lt;td>Setting of the public key for an Identity&lt;/td>&#xA; *   &lt;td>If the identity is marked as &quot;trusted&quot;, this allows an attacker to&#xA; * introduce a different public key (e.g., its own) that is not trusted&#xA; * by the system's identity scope, thereby granting applet or&#xA; * application code signed with that public key privileges that&#xA; * would have been denied otherwise.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>setIdentityInfo&lt;/td>&#xA; *   &lt;td>Setting of a general information string for an Identity&lt;/td>&#xA; *   &lt;td>This allows attackers to set the general description for&#xA; * an identity.  This may trick applications into using a different&#xA; * identity than intended or may prevent applications from finding a&#xA; * particular identity.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>addIdentityCertificate&lt;/td>&#xA; *   &lt;td>Addition of a certificate for an Identity&lt;/td>&#xA; *   &lt;td>This allows attackers to set a certificate for&#xA; * an identity's public key.  This is dangerous because it affects&#xA; * the trust relationship across the system. This public key suddenly&#xA; * becomes trusted to a wider audience than it otherwise would be.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>removeIdentityCertificate&lt;/td>&#xA; *   &lt;td>Removal of a certificate for an Identity&lt;/td>&#xA; *   &lt;td>This allows attackers to remove a certificate for&#xA; * an identity's public key. This is dangerous because it affects&#xA; * the trust relationship across the system. This public key suddenly&#xA; * becomes considered less trustworthy than it otherwise would be.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *  &lt;td>printIdentity&lt;/td>&#xA; *  &lt;td>Viewing the name of a principal&#xA; * and optionally the scope in which it is used, and whether&#xA; * or not it is considered &quot;trusted&quot; in that scope&lt;/td>&#xA; *  &lt;td>The scope that is printed out may be a filename, in which case&#xA; * it may convey local system information. For example, here's a sample&#xA; * printout of an identity named &quot;carol&quot;, who is&#xA; * marked not trusted in the user's identity database:&lt;br>&#xA; *   carol[/home/luehe/identitydb.obj][not trusted]&lt;/td>&#xA; *&lt;/tr>&#xA; * &#xA; * &lt;tr>&#xA; *   &lt;td>clearProviderProperties.{provider name}&lt;/td>&#xA; *   &lt;td>&quot;Clearing&quot; of a Provider so that it no longer contains the properties&#xA; * used to look up services implemented by the provider&lt;/td>&#xA; *   &lt;td>This disables the lookup of services implemented by the provider.&#xA; * This may thus change the behavior or disable execution of other&#xA; * parts of the program that would normally utilize the Provider, as&#xA; * described under the &quot;removeProvider.{provider name}&quot; permission.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>putProviderProperty.{provider name}&lt;/td>&#xA; *   &lt;td>Setting of properties for the specified Provider&lt;/td>&#xA; *   &lt;td>The provider properties each specify the name and location&#xA; * of a particular service implemented by the provider. By granting&#xA; * this permission, you let code replace the service specification&#xA; * with another one, thereby specifying a different implementation.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>removeProviderProperty.{provider name}&lt;/td>&#xA; *   &lt;td>Removal of properties from the specified Provider&lt;/td>&#xA; *   &lt;td>This disables the lookup of services implemented by the&#xA; * provider. They are no longer accessible due to removal of the properties&#xA; * specifying their names and locations. This&#xA; * may change the behavior or disable execution of other&#xA; * parts of the program that would normally utilize the Provider, as&#xA; * described under the &quot;removeProvider.{provider name}&quot; permission.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>getSignerPrivateKey&lt;/td>&#xA; *   &lt;td>Retrieval of a Signer's private key&lt;/td>&#xA; *   &lt;td>It is very dangerous to allow access to a private key; private&#xA; * keys are supposed to be kept secret. Otherwise, code can use the&#xA; * private key to sign various files and claim the signature came from&#xA; * the Signer.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;tr>&#xA; *   &lt;td>setSignerKeyPair&lt;/td>&#xA; *   &lt;td>Setting of the key pair (public key and private key) for a Signer&lt;/td>&#xA; *   &lt;td>This would allow an attacker to replace somebody else's (the &quot;target's&quot;)&#xA; * keypair with a possibly weaker keypair (e.g., a keypair of a smaller&#xA; * keysize).  This also would allow the attacker to listen in on encrypted&#xA; * communication between the target and its peers. The target's peers&#xA; * might wrap an encryption session key under the target's &quot;new&quot; public&#xA; * key, which would allow the attacker (who possesses the corresponding&#xA; * private key) to unwrap the session key and decipher the communication&#xA; * data encrypted under that session key.&lt;/td>&#xA; * &lt;/tr>&#xA; *&#xA; * &lt;/table>&#xA; *&#xA; * @see java.security.BasicPermission&#xA; * @see java.security.Permission&#xA; * @see java.security.Permissions&#xA; * @see java.security.PermissionCollection&#xA; * @see java.lang.SecurityManager&#xA; *&#xA; * @version 1.27 03/12/19&#xA; *&#xA; * @author Marianne Mueller&#xA; * @author Roland Schemers&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="BasicPermission.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
