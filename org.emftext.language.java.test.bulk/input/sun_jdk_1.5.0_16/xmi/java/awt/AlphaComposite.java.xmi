<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="AlphaComposite.java">
  <comments>/*&#xA; * @(#)AlphaComposite.java&#x9;1.47 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="image/ColorModel.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>java2d</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../sun/java2d/SunCompositeContext.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="AlphaComposite">
    <members xsi:type="members:Field" name="CLEAR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Both the color and the alpha of the destination are cleared&#xA;     * (Porter-Duff Clear rule).&#xA;     * Neither the source nor the destination is used as input.&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = 0 and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = 0, thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = 0&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = 0&#xA;     *&lt;/pre>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SRC">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The source is copied to the destination&#xA;     * (Porter-Duff Source rule).&#xA;     * The destination is not used as input.&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = 1 and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = 0, thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>s&lt;/sub>&lt;/em>&#xA;     *&lt;/pre>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DST">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="9"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The destination is left untouched&#xA;     * (Porter-Duff Destination rule).&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = 0 and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = 1, thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>d&lt;/sub>&lt;/em>&#xA;     *&lt;/pre>&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SRC_OVER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="3"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Note that DST was added in 1.4 so it is numbered out of order...</comments>
        <comments>/**&#xA;     * The source is composited over the destination&#xA;     * (Porter-Duff Source Over Destination rule).&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = 1 and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = (1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>), thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em> + &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>)&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>s&lt;/sub>&lt;/em> + &lt;em>C&lt;sub>d&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>)&#xA;     *&lt;/pre>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DST_OVER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The destination is composited over the source and&#xA;     * the result replaces the destination&#xA;     * (Porter-Duff Destination Over Source rule).&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = (1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>) and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = 1, thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>) + &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>s&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>) + &lt;em>C&lt;sub>d&lt;/sub>&lt;/em>&#xA;     *&lt;/pre>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SRC_IN">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="5"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The part of the source lying inside of the destination replaces&#xA;     * the destination&#xA;     * (Porter-Duff Source In Destination rule).&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>d&lt;/sub>&lt;/em> and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = 0, thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>*&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>s&lt;/sub>&lt;/em>*&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>&#xA;     *&lt;/pre>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DST_IN">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="6"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The part of the destination lying inside of the source&#xA;     * replaces the destination&#xA;     * (Porter-Duff Destination In Source rule).&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = 0 and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>, thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>*&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>d&lt;/sub>&lt;/em>*&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>&#xA;     *&lt;/pre>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SRC_OUT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="7"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The part of the source lying outside of the destination&#xA;     * replaces the destination&#xA;     * (Porter-Duff Source Held Out By Destination rule).&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = (1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>) and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = 0, thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>)&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>s&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>)&#xA;     *&lt;/pre>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DST_OUT">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The part of the destination lying outside of the source&#xA;     * replaces the destination&#xA;     * (Porter-Duff Destination Held Out By Source rule).&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = 0 and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = (1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>), thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>)&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>d&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>)&#xA;     *&lt;/pre>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SRC_ATOP">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="10"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>// Rule 9 is DST which is defined above where it fits into the</comments>
        <comments>// list logically, rather than numerically</comments>
        <comments>//</comments>
        <comments>// public static final int&#x9;DST&#x9;&#x9;= 9;</comments>
        <comments>/**&#xA;     * The part of the source lying inside of the destination&#xA;     * is composited onto the destination&#xA;     * (Porter-Duff Source Atop Destination rule).&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>d&lt;/sub>&lt;/em> and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = (1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>), thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>*&lt;em>A&lt;sub>d&lt;/sub>&lt;/em> + &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>) = &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>s&lt;/sub>&lt;/em>*&lt;em>A&lt;sub>d&lt;/sub>&lt;/em> + &lt;em>C&lt;sub>d&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>)&#xA;     *&lt;/pre>&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DST_ATOP">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="11"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The part of the destination lying inside of the source&#xA;     * is composited over the source and replaces the destination&#xA;     * (Porter-Duff Destination Atop Source rule).&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = (1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>) and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>, thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>) + &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>*&lt;em>A&lt;sub>s&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>s&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>) + &lt;em>C&lt;sub>d&lt;/sub>&lt;/em>*&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>&#xA;     *&lt;/pre>&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="XOR">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="12"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * The part of the source that lies outside of the destination&#xA;     * is combined with the part of the destination that lies outside&#xA;     * of the source&#xA;     * (Porter-Duff Source Xor Destination rule).&#xA;     *&lt;p>&#xA;     * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = (1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>) and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = (1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>), thus:&#xA;     *&lt;pre>&#xA;     * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>) + &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>)&#xA;     * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>s&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>) + &lt;em>C&lt;sub>d&lt;/sub>&lt;/em>*(1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>)&#xA;     *&lt;/pre>&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="Clear">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque CLEAR rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #CLEAR&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="Src">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque SRC rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #SRC&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="Dst">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque DST rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #DST&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SrcOver">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque SRC_OVER rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #SRC_OVER&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DstOver">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque DST_OVER rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #DST_OVER&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SrcIn">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque SRC_IN rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #SRC_IN&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DstIn">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque DST_IN rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #DST_IN&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SrcOut">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque SRC_OUT rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #SRC_OUT&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DstOut">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque DST_OUT rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #DST_OUT&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="SrcAtop">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque SRC_ATOP rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #SRC_ATOP&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="DstAtop">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque DST_ATOP rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #DST_ATOP&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="Xor">
      <initialValue xsi:type="instantiations:NewConstructorCall">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
        <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
      </initialValue>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * &lt;code>AlphaComposite&lt;/code> object that implements the opaque XOR rule&#xA;     * with an alpha of 1.0f.&#xA;     * @see #XOR&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MIN_RULE">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="MAX_RULE">
      <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:Field" name="extraAlpha">
      <typeReference xsi:type="types:Float"/>
    </members>
    <members xsi:type="members:Field" name="rule">
      <typeReference xsi:type="types:Int"/>
    </members>
    <members xsi:type="members:Constructor" name="AlphaComposite">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
          <arguments xsi:type="literals:DecimalFloatLiteral" decimalValue="1.0"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rule">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Constructor" name="AlphaComposite">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="alpha value out of range"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.1"/>
            <children xsi:type="literals:DecimalFloatLiteral"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.1"/>
            <children xsi:type="literals:DecimalFloatLiteral" decimalValue="1.0"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="unknown composite rule"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25"/>
            <relationOperators xsi:type="operators:GreaterThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.29/@parameters.1"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rule">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="alpha">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rule">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an &lt;code>AlphaComposite&lt;/code> object with the specified rule.&#xA;     * @param rule the compositing rule&#xA;     * @throws IllegalArgumentException if &lt;code>rule&lt;/code> is not one of &#xA;     *         the following:  {@link #CLEAR}, {@link #SRC}, {@link #DST},&#xA;     *         {@link #SRC_OVER}, {@link #DST_OVER}, {@link #SRC_IN}, &#xA;     *         {@link #DST_IN}, {@link #SRC_OUT}, {@link #DST_OUT},&#xA;     *         {@link #SRC_ATOP}, {@link #DST_ATOP}, or {@link #XOR}&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Switch">
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23"/>
          </statements>
          <condition xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.11"/>
        </cases>
        <cases xsi:type="statements:DefaultSwitchCase">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="unknown composite rule"/>
            </throwable>
          </statements>
        </cases>
        <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.30/@parameters.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rule">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="alpha">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates an &lt;code>AlphaComposite&lt;/code> object with the specified rule and&#xA;     * the constant alpha to multiply with the alpha of the source.&#xA;     * The source is multiplied with the specified alpha before being composited&#xA;     * with the destination.&#xA;     * @param rule the compositing rule&#xA;     * @param alpha the constant alpha to be multiplied with the alpha of&#xA;     * the source. &lt;code>alpha&lt;/code> must be a floating point number in the&#xA;     * inclusive range [0.0,&amp;nbsp;1.0]. &#xA;     * @throws IllegalArgumentException if &#xA;     *         &lt;code>alpha&lt;/code> is less than 0.0 or greater than 1.0, or if&#xA;     *         &lt;code>rule&lt;/code> is not one of &#xA;     *         the following:  {@link #CLEAR}, {@link #SRC}, {@link #DST},&#xA;     *         {@link #SRC_OVER}, {@link #DST_OVER}, {@link #SRC_IN}, &#xA;     *         {@link #DST_IN}, {@link #SRC_OUT}, {@link #DST_OUT},&#xA;     *         {@link #SRC_ATOP}, {@link #DST_ATOP}, or {@link #XOR}&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.30">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.1"/>
          <children xsi:type="literals:DecimalFloatLiteral" decimalValue="1.0"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.31/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createContext">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="CompositeContext.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="srcColorModel">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="image/ColorModel.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dstColorModel">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="image/ColorModel.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hints">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="RenderingHints.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a context for the compositing operation.&#xA;     * The context contains state that is used in performing&#xA;     * the compositing operation.&#xA;     * @param srcColorModel  the {@link ColorModel} of the source&#xA;     * @param dstColorModel  the &lt;code>ColorModel&lt;/code> of the destination&#xA;     * @return the &lt;code>CompositeContext&lt;/code> object to be used to perform&#xA;     * compositing operations.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../sun/java2d/SunCompositeContext.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAlpha">
      <typeReference xsi:type="types:Float"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the alpha value of this &lt;code>AlphaComposite&lt;/code>.  If this&#xA;     * &lt;code>AlphaComposite&lt;/code> does not have an alpha value, 1.0 is returned.&#xA;     * @return the alpha value of this &lt;code>AlphaComposite&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getRule">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the compositing rule of this &lt;code>AlphaComposite&lt;/code>.&#xA;     * @return the compositing rule of this &lt;code>AlphaComposite&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hashCode">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the hashcode for this composite.&#xA;     * @return      a hash code for this composite.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:NestedExpression">
          <expression xsi:type="expressions:AdditiveExpression">
            <children xsi:type="expressions:MultiplicativeExpression">
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="../lang/Float.class.xmi#//@classifiers.0/@members.30"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26"/>
                </next>
                <target xsi:type="classifiers:Class" href="../lang/Float.class.xmi#//@classifiers.0"/>
              </children>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="31"/>
              <multiplicativeOperators xsi:type="operators:Multiplication"/>
            </children>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </expression>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="equals">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obj">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether the specified object is equal to this &#xA;     * &lt;code>AlphaComposite&lt;/code>.&#xA;     * &lt;p>&#xA;     * The result is &lt;code>true&lt;/code> if and only if&#xA;     * the argument is not &lt;code>null&lt;/code> and is an&#xA;     * &lt;code>AlphaComposite&lt;/code> object that has the same&#xA;     * compositing rule and alpha value as this object.&#xA;     *&#xA;     * @param obj the &lt;code>Object&lt;/code> to test for equality&#xA;     * @return &lt;code>true&lt;/code> if &lt;code>obj&lt;/code> equals this&#xA;     * &lt;code>AlphaComposite&lt;/code>; &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:InstanceOfExpression">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences target="//@classifiers.0"/>
              </typeReference>
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
            </expression>
          </child>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ac">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@statements.1/@variable">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>AlphaComposite&lt;/code> class implements basic alpha &#xA; * compositing rules for combining source and destination colors&#xA; * to achieve blending and transparency effects with graphics and&#xA; * images.&#xA; * The specific rules implemented by this class are the basic set&#xA; * of 12 rules described in&#xA; * T. Porter and T. Duff, &quot;Compositing Digital Images&quot;, SIGGRAPH 84,&#xA; * 253-259.&#xA; * The rest of this documentation assumes some familiarity with the&#xA; * definitions and concepts outlined in that paper.&#xA; *&#xA; * &lt;p>&#xA; * This class extends the standard equations defined by Porter and&#xA; * Duff to include one additional factor.&#xA; * An instance of the &lt;code>AlphaComposite&lt;/code> class can contain&#xA; * an alpha value that is used to modify the opacity or coverage of&#xA; * every source pixel before it is used in the blending equations.&#xA; *&#xA; * &lt;p>&#xA; * It is important to note that the equations defined by the Porter&#xA; * and Duff paper are all defined to operate on color components&#xA; * that are premultiplied by their corresponding alpha components.&#xA; * Since the &lt;code>ColorModel&lt;/code> and &lt;code>Raster&lt;/code> classes&#xA; * allow the storage of pixel data in either premultiplied or&#xA; * non-premultiplied form, all input data must be normalized into&#xA; * premultiplied form before applying the equations and all results&#xA; * might need to be adjusted back to the form required by the destination&#xA; * before the pixel values are stored.&#xA; *&#xA; * &lt;p>&#xA; * Also note that this class defines only the equations&#xA; * for combining color and alpha values in a purely mathematical&#xA; * sense. The accurate application of its equations depends&#xA; * on the way the data is retrieved from its sources and stored&#xA; * in its destinations.&#xA; * See &lt;a href=&quot;#caveats&quot;>Implementation Caveats&lt;/a> &#xA; * for further information.&#xA; *&#xA; * &lt;p>&#xA; * The following factors are used in the description of the blending&#xA; * equation in the Porter and Duff paper:&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;table summary=&quot;layout&quot;>&#xA; * &lt;tr>&lt;th align=left>Factor&amp;nbsp;&amp;nbsp;&lt;th align=left>Definition&#xA; * &lt;tr>&lt;td>&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>&lt;td>the alpha component of the source pixel&#xA; * &lt;tr>&lt;td>&lt;em>C&lt;sub>s&lt;/sub>&lt;/em>&lt;td>a color component of the source pixel in premultiplied form&#xA; * &lt;tr>&lt;td>&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>&lt;td>the alpha component of the destination pixel&#xA; * &lt;tr>&lt;td>&lt;em>C&lt;sub>d&lt;/sub>&lt;/em>&lt;td>a color component of the destination pixel in premultiplied form&#xA; * &lt;tr>&lt;td>&lt;em>F&lt;sub>s&lt;/sub>&lt;/em>&lt;td>the fraction of the source pixel that contributes to the output&#xA; * &lt;tr>&lt;td>&lt;em>F&lt;sub>d&lt;/sub>&lt;/em>&lt;td>the fraction of the destination pixel that contributes&#xA; * to the output&#xA; * &lt;tr>&lt;td>&lt;em>A&lt;sub>r&lt;/sub>&lt;/em>&lt;td>the alpha component of the result&#xA; * &lt;tr>&lt;td>&lt;em>C&lt;sub>r&lt;/sub>&lt;/em>&lt;td>a color component of the result in premultiplied form&#xA; * &lt;/table>&#xA; * &lt;/blockquote>&#xA; *&#xA; * &lt;p>&#xA; * Using these factors, Porter and Duff define 12 ways of choosing&#xA; * the blending factors &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> to&#xA; * produce each of 12 desirable visual effects.&#xA; * The equations for determining &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em>&#xA; * are given in the descriptions of the 12 static fields&#xA; * that specify visual effects.&#xA; * For example, &#xA; * the description for &#xA; * &lt;a href=&quot;#SRC_OVER&quot;>&lt;code>SRC_OVER&lt;/code>&lt;/a>&#xA; * specifies that &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = 1 and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = (1-&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>).&#xA; * Once a set of equations for determining the blending factors is&#xA; * known they can then be applied to each pixel to produce a result&#xA; * using the following set of equations:&#xA; *&#xA; * &lt;pre>&#xA; * &#x9;&lt;em>F&lt;sub>s&lt;/sub>&lt;/em> = &lt;em>f&lt;/em>(&lt;em>A&lt;sub>d&lt;/sub>&lt;/em>)&#xA; * &#x9;&lt;em>F&lt;sub>d&lt;/sub>&lt;/em> = &lt;em>f&lt;/em>(&lt;em>A&lt;sub>s&lt;/sub>&lt;/em>)&#xA; * &#x9;&lt;em>A&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>*&lt;em>F&lt;sub>s&lt;/sub>&lt;/em> + &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>*&lt;em>F&lt;sub>d&lt;/sub>&lt;/em>&#xA; * &#x9;&lt;em>C&lt;sub>r&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>s&lt;/sub>&lt;/em>*&lt;em>F&lt;sub>s&lt;/sub>&lt;/em> + &lt;em>C&lt;sub>d&lt;/sub>&lt;/em>*&lt;em>F&lt;sub>d&lt;/sub>&lt;/em>&lt;/pre>&#xA; *&#xA; * &lt;p>&#xA; * The following factors will be used to discuss our extensions to&#xA; * the blending equation in the Porter and Duff paper:&#xA; *&#xA; * &lt;blockquote>&#xA; * &lt;table summary=&quot;layout&quot;>&#xA; * &lt;tr>&lt;th align=left>Factor&amp;nbsp;&amp;nbsp;&lt;th align=left>Definition&#xA; * &lt;tr>&lt;td>&lt;em>C&lt;sub>sr&lt;/sub>&lt;/em> &lt;td>one of the raw color components of the source pixel&#xA; * &lt;tr>&lt;td>&lt;em>C&lt;sub>dr&lt;/sub>&lt;/em> &lt;td>one of the raw color components of the destination pixel&#xA; * &lt;tr>&lt;td>&lt;em>A&lt;sub>ac&lt;/sub>&lt;/em>  &lt;td>the &quot;extra&quot; alpha component from the AlphaComposite instance&#xA; * &lt;tr>&lt;td>&lt;em>A&lt;sub>sr&lt;/sub>&lt;/em> &lt;td>the raw alpha component of the source pixel&#xA; * &lt;tr>&lt;td>&lt;em>A&lt;sub>dr&lt;/sub>&lt;/em>&lt;td>the raw alpha component of the destination pixel&#xA; * &lt;tr>&lt;td>&lt;em>A&lt;sub>df&lt;/sub>&lt;/em> &lt;td>the final alpha component stored in the destination&#xA; * &lt;tr>&lt;td>&lt;em>C&lt;sub>df&lt;/sub>&lt;/em> &lt;td>the final raw color component stored in the destination&#xA; * &lt;/table>&#xA; *&lt;/blockquote>&#xA; *&#xA; * &lt;h3>Preparing Inputs&lt;/h3>&#xA; *&#xA; * &lt;p>&#xA; * The &lt;code>AlphaComposite&lt;/code> class defines an additional alpha&#xA; * value that is applied to the source alpha.&#xA; * This value is applied as if an implicit SRC_IN rule were first&#xA; * applied to the source pixel against a pixel with the indicated&#xA; * alpha by multiplying both the raw source alpha and the raw&#xA; * source colors by the alpha in the &lt;code>AlphaComposite&lt;/code>.&#xA; * This leads to the following equation for producing the alpha&#xA; * used in the Porter and Duff blending equation:&#xA; *&#xA; * &lt;pre>&#xA; * &#x9;&lt;em>A&lt;sub>s&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>sr&lt;/sub>&lt;/em> * &lt;em>A&lt;sub>ac&lt;/sub>&lt;/em> &lt;/pre>&#xA; *&#xA; * All of the raw source color components need to be multiplied&#xA; * by the alpha in the &lt;code>AlphaComposite&lt;/code> instance.&#xA; * Additionally, if the source was not in premultiplied form&#xA; * then the color components also need to be multiplied by the&#xA; * source alpha.&#xA; * Thus, the equation for producing the source color components&#xA; * for the Porter and Duff equation depends on whether the source&#xA; * pixels are premultiplied or not:&#xA; *&#xA; * &lt;pre>&#xA; * &#x9;&lt;em>C&lt;sub>s&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>sr&lt;/sub>&lt;/em> * &lt;em>A&lt;sub>sr&lt;/sub>&lt;/em> * &lt;em>A&lt;sub>ac&lt;/sub>&lt;/em>     (if source is not premultiplied)&#xA; * &#x9;&lt;em>C&lt;sub>s&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>sr&lt;/sub>&lt;/em> * &lt;em>A&lt;sub>ac&lt;/sub>&lt;/em>           (if source is premultiplied) &lt;/pre>&#xA; *&#xA; * No adjustment needs to be made to the destination alpha:&#xA; *&#xA; * &lt;pre>&#xA; * &#x9;&lt;em>A&lt;sub>d&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>dr&lt;/sub>&lt;/em> &lt;/pre>&#xA; *&#xA; * &lt;p>&#xA; * The destination color components need to be adjusted only if&#xA; * they are not in premultiplied form:&#xA; *&#xA; * &lt;pre>&#xA; * &#x9;&lt;em>C&lt;sub>d&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>dr&lt;/sub>&lt;/em> * &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>    (if destination is not premultiplied) &#xA; * &#x9;&lt;em>C&lt;sub>d&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>dr&lt;/sub>&lt;/em>         (if destination is premultiplied) &lt;/pre>&#xA; *&#xA; * &lt;h3>Applying the Blending Equation&lt;/h3>&#xA; *&#xA; * &lt;p>&#xA; * The adjusted &lt;em>A&lt;sub>s&lt;/sub>&lt;/em>, &lt;em>A&lt;sub>d&lt;/sub>&lt;/em>,&#xA; * &lt;em>C&lt;sub>s&lt;/sub>&lt;/em>, and &lt;em>C&lt;sub>d&lt;/sub>&lt;/em> are used in the standard&#xA; * Porter and Duff equations to calculate the blending factors&#xA; * &lt;em>F&lt;sub>s&lt;/sub>&lt;/em> and &lt;em>F&lt;sub>d&lt;/sub>&lt;/em> and then the resulting&#xA; * premultiplied components &lt;em>A&lt;sub>r&lt;/sub>&lt;/em> and &lt;em>C&lt;sub>r&lt;/sub>&lt;/em>.&#xA; *&#xA; * &lt;p>&#xA; * &lt;h3>Preparing Results&lt;/h3>&#xA; *&#xA; * &lt;p>&#xA; * The results only need to be adjusted if they are to be stored&#xA; * back into a destination buffer that holds data that is not&#xA; * premultiplied, using the following equations:&#xA; *&#xA; * &lt;pre>&#xA; * &#x9;&lt;em>A&lt;sub>df&lt;/sub>&lt;/em> = &lt;em>A&lt;sub>r&lt;/sub>&lt;/em>&#xA; * &#x9;&lt;em>C&lt;sub>df&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>r&lt;/sub>&lt;/em>                 (if dest is premultiplied)&#xA; * &#x9;&lt;em>C&lt;sub>df&lt;/sub>&lt;/em> = &lt;em>C&lt;sub>r&lt;/sub>&lt;/em> / &lt;em>A&lt;sub>r&lt;/sub>&lt;/em>            (if dest is not premultiplied) &lt;/pre>&#xA; *&#xA; * Note that since the division is undefined if the resulting alpha&#xA; * is zero, the division in that case is omitted to avoid the &quot;divide&#xA; * by zero&quot; and the color components are left as&#xA; * all zeros.&#xA; *&#xA; * &lt;p>&#xA; * &lt;h3>Performance Considerations&lt;/h3>&#xA; *&#xA; * &lt;p>&#xA; * For performance reasons, it is preferrable that &#xA; * &lt;code>Raster&lt;/code> objects passed to the &lt;code>compose&lt;/code>&#xA; * method of a {@link CompositeContext} object created by the &#xA; * &lt;code>AlphaComposite&lt;/code> class have premultiplied data.&#xA; * If either the source &lt;code>Raster&lt;/code>&#xA; * or the destination &lt;code>Raster&lt;/code>&#xA; * is not premultiplied, however,&#xA; * appropriate conversions are performed before and after the compositing&#xA; * operation.&#xA; *&#xA; * &lt;h3>&lt;a name=&quot;caveats&quot;>Implementation Caveats&lt;/a>&lt;/h3>&#xA; *&#xA; * &lt;ul>&#xA; * &lt;li>&#xA; * Many sources, such as some of the opaque image types listed&#xA; * in the &lt;code>BufferedImage&lt;/code> class, do not store alpha values&#xA; * for their pixels.  Such sources supply an alpha of 1.0 for&#xA; * all of their pixels.&#xA; *&#xA; * &lt;p>&#xA; * &lt;li>&#xA; * Many destinations also have no place to store the alpha values&#xA; * that result from the blending calculations performed by this class.&#xA; * Such destinations thus implicitly discard the resulting&#xA; * alpha values that this class produces.&#xA; * It is recommended that such destinations should treat their stored&#xA; * color values as non-premultiplied and divide the resulting color&#xA; * values by the resulting alpha value before storing the color&#xA; * values and discarding the alpha value.&#xA; *&#xA; * &lt;p>&#xA; * &lt;li>&#xA; * The accuracy of the results depends on the manner in which pixels&#xA; * are stored in the destination.&#xA; * An image format that provides at least 8 bits of storage per color&#xA; * and alpha component is at least adequate for use as a destination&#xA; * for a sequence of a few to a dozen compositing operations.&#xA; * An image format with fewer than 8 bits of storage per component&#xA; * is of limited use for just one or two compositing operations&#xA; * before the rounding errors dominate the results.&#xA; * An image format&#xA; * that does not separately store &#xA; * color components is not a&#xA; * good candidate for any type of translucent blending.&#xA; * For example, &lt;code>BufferedImage.TYPE_BYTE_INDEXED&lt;/code>&#xA; * should not be used as a destination for a blending operation&#xA; * because every operation &#xA; * can introduce large errors, due to&#xA; * the need to choose a pixel from a limited palette to match the&#xA; * results of the blending equations.&#xA; *&#xA; * &lt;p>&#xA; * &lt;li>&#xA; * Nearly all formats store pixels as discrete integers rather than&#xA; * the floating point values used in the reference equations above.&#xA; * The implementation can either scale the integer pixel&#xA; * values into floating point values in the range 0.0 to 1.0 or &#xA; * use slightly modified versions of the equations&#xA; * that operate entirely in the integer domain and yet produce&#xA; * analogous results to the reference equations.&#xA; *&#xA; * &lt;p>&#xA; * Typically the integer values are related to the floating point&#xA; * values in such a way that the integer 0 is equated&#xA; * to the floating point value 0.0 and the integer&#xA; * 2^&lt;em>n&lt;/em>-1 (where &lt;em>n&lt;/em> is the number of bits&#xA; * in the representation) is equated to 1.0.&#xA; * For 8-bit representations, this means that 0x00&#xA; * represents 0.0 and 0xff represents&#xA; * 1.0.&#xA; *&#xA; * &lt;p>&#xA; * &lt;li>&#xA; * The internal implementation can approximate some of the equations&#xA; * and it can also eliminate some steps to avoid unnecessary operations.&#xA; * For example, consider a discrete integer image with non-premultiplied&#xA; * alpha values that uses 8 bits per component for storage.&#xA; * The stored values for a&#xA; * nearly transparent darkened red might be:&#xA; *&#xA; * &lt;pre>&#xA; *    (A, R, G, B) = (0x01, 0xb0, 0x00, 0x00)&lt;/pre>&#xA; *&#xA; * &lt;p>&#xA; * If integer math were being used and this value were being&#xA; * composited in&#xA; * &lt;a href=&quot;#SRC&quot;>&lt;code>SRC&lt;/code>&lt;/a>&#xA; * mode with no extra alpha, then the math would&#xA; * indicate that the results were (in integer format):&#xA; *&#xA; * &lt;pre>&#xA; *    (A, R, G, B) = (0x01, 0x01, 0x00, 0x00)&lt;/pre>&#xA; *&#xA; * &lt;p>&#xA; * Note that the intermediate values, which are always in premultiplied&#xA; * form, would only allow the integer red component to be either 0x00&#xA; * or 0x01.  When we try to store this result back into a destination&#xA; * that is not premultiplied, dividing out the alpha will give us&#xA; * very few choices for the non-premultiplied red value.&#xA; * In this case an implementation that performs the math in integer&#xA; * space without shortcuts is likely to end up with the final pixel&#xA; * values of:&#xA; *&#xA; * &lt;pre>&#xA; *    (A, R, G, B) = (0x01, 0xff, 0x00, 0x00)&lt;/pre>&#xA; *&#xA; * &lt;p>&#xA; * (Note that 0x01 divided by 0x01 gives you 1.0, which is equivalent&#xA; * to the value 0xff in an 8-bit storage format.)&#xA; *&#xA; * &lt;p>&#xA; * Alternately, an implementation that uses floating point math&#xA; * might produce more accurate results and end up returning to the&#xA; * original pixel value with little, if any, roundoff error.&#xA; * Or, an implementation using integer math might decide that since&#xA; * the equations boil down to a virtual NOP on the color values&#xA; * if performed in a floating point space, it can transfer the&#xA; * pixel untouched to the destination and avoid all the math entirely.&#xA; *&#xA; * &lt;p>&#xA; * These implementations all attempt to honor the&#xA; * same equations, but use different tradeoffs of integer and&#xA; * floating point math and reduced or full equations.&#xA; * To account for such differences, it is probably best to&#xA; * expect only that the premultiplied form of the results to&#xA; * match between implementations and image formats.  In this&#xA; * case both answers, expressed in premultiplied form would&#xA; * equate to:&#xA; *&#xA; * &lt;pre>&#xA; *    (A, R, G, B) = (0x01, 0x01, 0x00, 0x00)&lt;/pre>&#xA; *&#xA; * &lt;p>&#xA; * and thus they would all match.&#xA; *&#xA; * &lt;p>&#xA; * &lt;li>&#xA; * Because of the technique of simplifying the equations for&#xA; * calculation efficiency, some implementations might perform&#xA; * differently when encountering result alpha values of 0.0&#xA; * on a non-premultiplied destination.&#xA; * Note that the simplification of removing the divide by alpha&#xA; * in the case of the SRC rule is technically not valid if the&#xA; * denominator (alpha) is 0.&#xA; * But, since the results should only be expected to be accurate&#xA; * when viewed in premultiplied form, a resulting alpha of 0&#xA; * essentially renders the resulting color components irrelevant&#xA; * and so exact behavior in this case should not be expected.&#xA; * &lt;/ul>&#xA; * @see Composite&#xA; * @see CompositeContext&#xA; * @version 10 Feb 1997&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Final"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="Composite.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
