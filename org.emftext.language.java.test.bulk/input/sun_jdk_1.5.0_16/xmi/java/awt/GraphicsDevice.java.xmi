<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="GraphicsDevice.java">
  <comments>/*&#xA; * @(#)GraphicsDevice.java&#x9;1.30 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="image/ColorModel.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="GraphicsDevice">
    <members xsi:type="members:Field" name="fullScreenWindow">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Window.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Field" name="windowedModeBounds">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Rectangle.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
    </members>
    <members xsi:type="members:Constructor" name="GraphicsDevice">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * This is an abstract class that cannot be instantiated directly.&#xA;     * Instances must be obtained from a suitable factory or query method.&#xA;     * @see GraphicsEnvironment#getScreenDevices&#xA;     * @see GraphicsEnvironment#getDefaultScreenDevice&#xA;     * @see GraphicsConfiguration#getDevice&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="TYPE_RASTER_SCREEN">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Device is a raster screen.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="TYPE_PRINTER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Device is a printer.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="TYPE_IMAGE_BUFFER">
      <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Device is an image buffer.  This buffer can reside in device&#xA;     * or system memory but it is not physically viewable by the user.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getType">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the type of this &lt;code>GraphicsDevice&lt;/code>.&#xA;     * @return the type of this &lt;code>GraphicsDevice&lt;/code>, which can&#xA;     * either be TYPE_RASTER_SCREEN, TYPE_PRINTER or TYPE_IMAGE_BUFFER.&#xA;     * @see #TYPE_RASTER_SCREEN&#xA;     * @see #TYPE_PRINTER&#xA;     * @see #TYPE_IMAGE_BUFFER&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getIDstring">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the identification string associated with this &#xA;     * &lt;code>GraphicsDevice&lt;/code>.&#xA;     * &lt;p>&#xA;     * A particular program might use more than one &#xA;     * &lt;code>GraphicsDevice&lt;/code> in a &lt;code>GraphicsEnvironment&lt;/code>.&#xA;     * This method returns a &lt;code>String&lt;/code> identifying a&#xA;     * particular &lt;code>GraphicsDevice&lt;/code> in the local&#xA;     * &lt;code>GraphicsEnvironment&lt;/code>.  Although there is&#xA;     * no public method to set this &lt;code>String&lt;/code>, a programmer can&#xA;     * use the &lt;code>String&lt;/code> for debugging purposes.  Vendors of &#xA;     * the Java&lt;sup>&lt;font size=-2>TM&lt;/font>&lt;/sup> Runtime Environment can&#xA;     * format the return value of the &lt;code>String&lt;/code>.  To determine &#xA;     * how to interpret the value of the &lt;code>String&lt;/code>, contact the&#xA;     * vendor of your Java Runtime.  To find out who the vendor is, from&#xA;     * your program, call the &#xA;     * {@link System#getProperty(String) getProperty} method of the&#xA;     * System class with &quot;java.vendor&quot;.&#xA;     * @return a &lt;code>String&lt;/code> that is the identification&#xA;     * of this &lt;code>GraphicsDevice&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getConfigurations">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GraphicsConfiguration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns all of the &lt;code>GraphicsConfiguration&lt;/code>&#xA;     * objects associated with this &lt;code>GraphicsDevice&lt;/code>.&#xA;     * @return an array of &lt;code>GraphicsConfiguration&lt;/code>&#xA;     * objects that are associated with this &#xA;     * &lt;code>GraphicsDevice&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDefaultConfiguration">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GraphicsConfiguration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the default &lt;code>GraphicsConfiguration&lt;/code>&#xA;     * associated with this &lt;code>GraphicsDevice&lt;/code>.&#xA;     * @return the default &lt;code>GraphicsConfiguration&lt;/code>&#xA;     * of this &lt;code>GraphicsDevice&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getBestConfiguration">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GraphicsConfiguration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="gct">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="GraphicsConfigTemplate.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &quot;best&quot; configuration possible that passes the&#xA;     * criteria defined in the {@link GraphicsConfigTemplate}.&#xA;     * @param gct the &lt;code>GraphicsConfigTemplate&lt;/code> object&#xA;     * used to obtain a valid &lt;code>GraphicsConfiguration&lt;/code>&#xA;     * @return a &lt;code>GraphicsConfiguration&lt;/code> that passes&#xA;     * the criteria defined in the specified&#xA;     * &lt;code>GraphicsConfigTemplate&lt;/code>.&#xA;     * @see GraphicsConfigTemplate&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="configs">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="GraphicsConfiguration.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.8"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@parameters.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="GraphicsConfigTemplate.class.xmi#//@classifiers.0/@members.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10/@statements.0/@variable"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isFullScreenSupported">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if this &lt;code>GraphicsDevice&lt;/code>&#xA;     * supports full-screen exclusive mode.&#xA;     * @return whether full-screen exclusive mode is available for&#xA;     * this graphics device&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setFullScreenWindow">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Window.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enter full-screen mode, or return to windowed mode.&#xA;     * &lt;p>&#xA;     * If &lt;code>isFullScreenSupported&lt;/code> returns &lt;code>true&lt;/code>, full&#xA;     * screen mode is considered to be &lt;i>exclusive&lt;/i>, which implies:&#xA;     * &lt;ul>&#xA;     * &lt;li>Windows cannot overlap the full-screen window.  All other application&#xA;     * windows will always appear beneath the full-screen window in the Z-order.&#xA;     * &lt;li>Input method windows are disabled.  It is advisable to call&#xA;     * &lt;code>Component.enableInputMethods(false)&lt;/code> to make a component&#xA;     * a non-client of the input method framework.&#xA;     * &lt;/ul>&#xA;     * &lt;p>&#xA;     * If &lt;code>isFullScreenSupported&lt;/code> returns&#xA;     * &lt;code>false&lt;/code>, full-screen exclusive mode is simulated by resizing&#xA;     * the window to the size of the screen and positioning it at (0,0).&#xA;     * &lt;p>&#xA;     * When entering full-screen exclusive mode, if the window to be used as the &#xA;     * full-screen window is not visible, this method will make it visible. &#xA;     * It will remain visible when returning to windowed mode.  &#xA;     * &lt;p>&#xA;     * When returning to windowed mode from an exclusive full-screen window, any&#xA;     * display changes made by calling &lt;code>setDisplayMode&lt;/code> are&#xA;     * automatically restored to their original state.&#xA;     *&#xA;     * @param w a window to use as the full-screen window; &lt;code>null&lt;/code>&#xA;     * if returning to windowed mode.  Some platforms expect the&#xA;     * fullscreen window to be a top-level component (i.e., a Frame);&#xA;     * therefore it is preferable to use a Frame here rather than a&#xA;     * Window. &#xA;     * @see #isFullScreenSupported&#xA;     * @see #getFullScreenWindow&#xA;     * @see #setDisplayMode&#xA;     * @see Component#enableInputMethods&#xA;     * @see Component#setVisible&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dm">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Get display mode before changing the full screen window</comments>
              <target xsi:type="classifiers:Class" href="DisplayMode.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:NullLiteral"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:MethodCall" target="//@classifiers.0/@members.16"/>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Component.class.xmi#//@classifiers.0/@members.165"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <comments>// Set the full screen window</comments>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="Component.class.xmi#//@classifiers.0/@members.158"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Window.class.xmi#//@classifiers.0/@members.115"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="DisplayMode.class.xmi#//@classifiers.0/@members.7"/>
                  </next>
                </arguments>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.12/@statements.0/@variable">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="DisplayMode.class.xmi#//@classifiers.0/@members.6"/>
                  </next>
                </arguments>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Component.class.xmi#//@classifiers.0/@members.125"/>
                <arguments xsi:type="literals:BooleanLiteral" value="true"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Window.class.xmi#//@classifiers.0/@members.49"/>
              </next>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getFullScreenWindow">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Window.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>Window&lt;/code> object representing the &#xA;     * full-screen window if the device is in full-screen mode.&#xA;     * &#xA;     * @return the full-screen window, or &lt;code>null&lt;/code> if the device is&#xA;     * not in full-screen mode.&#xA;     * @see #setFullScreenWindow(Window)&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="isDisplayChangeSupported">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns &lt;code>true&lt;/code> if this &lt;code>GraphicsDevice&lt;/code>&#xA;     * supports low-level display changes.&#xA;     * @return whether low-level display changes are supported for this&#xA;     * graphics device.  Note that this may or may not be dependent on&#xA;     * full-screen exclusive mode.&#xA;     * @see #setDisplayMode&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setDisplayMode">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dm">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DisplayMode.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the display mode of this graphics device.  This may only be allowed&#xA;     * in full-screen, exclusive mode.&#xA;     * @param dm the new display mode of this graphics device&#xA;     * @exception IllegalArgumentException if the &lt;code>DisplayMode&lt;/code>&#xA;     * supplied is &lt;code>null&lt;/code>, or is not available in the array returned&#xA;     * by &lt;code>getDisplayModes&lt;/code>&#xA;     * @exception UnsupportedOperationException if&#xA;     * &lt;code>isDisplayChangeSupported&lt;/code> returns &lt;code>false&lt;/code>&#xA;     * @see #getDisplayMode&#xA;     * @see #getDisplayModes&#xA;     * @see #isDisplayChangeSupported&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Throw">
        <throwable xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../lang/UnsupportedOperationException.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:StringReference" value="Cannot change display mode"/>
        </throwable>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDisplayMode">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DisplayMode.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current display mode of this &#xA;     * &lt;code>GraphicsDevice&lt;/code>.&#xA;     * @return the current display mode of this graphics device.&#xA;     * @see #setDisplayMode(DisplayMode)&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="gc">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="GraphicsConfiguration.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.9"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="r">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Rectangle.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="GraphicsConfiguration.class.xmi#//@classifiers.0/@members.14"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="cm">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="image/ColorModel.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="GraphicsConfiguration.class.xmi#//@classifiers.0/@members.10"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DisplayMode.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.1/@variable">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Rectangle.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.1/@variable">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Rectangle.class.xmi#//@classifiers.0/@members.3"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.2/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="image/ColorModel.class.xmi#//@classifiers.0/@members.31"/>
            </next>
          </arguments>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDisplayModes">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DisplayMode.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns all display modes available for this      &#xA;     * &lt;code>GraphicsDevice&lt;/code>.&#xA;     * @return all of the display modes available for this graphics device.&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="arrays:ArrayInstantiationByValues">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DisplayMode.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arrayDimensionsBefore/>
          <arrayInitializer>
            <initialValues xsi:type="references:MethodCall" target="//@classifiers.0/@members.16"/>
          </arrayInitializer>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getAvailableAcceleratedMemory">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * This method returns the number of bytes available in&#xA;     * accelerated memory on this device.&#xA;     * Some images are created or cached&#xA;     * in accelerated memory on a first-come,&#xA;     * first-served basis.  On some operating systems,&#xA;     * this memory is a finite resource.  Calling this method&#xA;     * and scheduling the creation and flushing of images carefully may&#xA;     * enable applications to make the most efficient use of&#xA;     * that finite resource.&#xA;     * &lt;br>&#xA;     * Note that the number returned is a snapshot of how much&#xA;     * memory is available; some images may still have problems&#xA;     * being allocated into that memory.  For example, depending&#xA;     * on operating system, driver, memory configuration, and&#xA;     * thread situations, the full extent of the size reported&#xA;     * may not be available for a given image.  There are further&#xA;     * inquiry methods on the {@link ImageCapabilities} object&#xA;     * associated with a VolatileImage that can be used to determine&#xA;     * whether a particular VolatileImage has been created in accelerated&#xA;     * memory.&#xA;     * @return number of bytes available in accelerated memory.&#xA;     * A negative return value indicates that accelerated memory&#xA;     * is unlimited.&#xA;     * @see java.awt.image.VolatileImage#flush&#xA;     * @see ImageCapabilities#isAccelerated&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Subtraction"/>
          <child xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>GraphicsDevice&lt;/code> class describes the graphics devices&#xA; * that might be available in a particular graphics environment.  These&#xA; * include screen and printer devices. Note that there can be many screens&#xA; * and many printers in an instance of {@link GraphicsEnvironment}. Each&#xA; * graphics device has one or more {@link GraphicsConfiguration} objects&#xA; * associated with it.  These objects specify the different configurations&#xA; * in which the &lt;code>GraphicsDevice&lt;/code> can be used.&#xA; * &lt;p>  &#xA; * In a multi-screen environment, the &lt;code>GraphicsConfiguration&lt;/code>&#xA; * objects can be used to render components on multiple screens.  The &#xA; * following code sample demonstrates how to create a &lt;code>JFrame&lt;/code>&#xA; * object for each &lt;code>GraphicsConfiguration&lt;/code> on each screen&#xA; * device in the &lt;code>GraphicsEnvironment&lt;/code>:&#xA; * &lt;pre>&#xA; *   GraphicsEnvironment ge = GraphicsEnvironment.&#xA; *   getLocalGraphicsEnvironment();&#xA; *   GraphicsDevice[] gs = ge.getScreenDevices();&#xA; *   for (int j = 0; j &lt; gs.length; j++) { &#xA; *      GraphicsDevice gd = gs[j];&#xA; *      GraphicsConfiguration[] gc =&#xA; * &#x9;gd.getConfigurations();&#xA; *      for (int i=0; i &lt; gc.length; i++) {&#xA; *         JFrame f = new&#xA; *         JFrame(gs[j].getDefaultConfiguration());&#xA; *         Canvas c = new Canvas(gc[i]); &#xA; *         Rectangle gcBounds = gc[i].getBounds();&#xA; *         int xoffs = gcBounds.x;&#xA; *         int yoffs = gcBounds.y;&#xA; *&#x9;   f.getContentPane().add(c);&#xA; *&#x9;   f.setLocation((i*50)+xoffs, (i*60)+yoffs);&#xA; *         f.show();&#xA; *      }&#xA; *   }&#xA; * &lt;/pre>                           &#xA; * @see GraphicsEnvironment&#xA; * @see GraphicsConfiguration&#xA; * @version 1.30, 12/19/03&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
