<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/generics ../../../../java.ecore#/6 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/references ../../../../java.ecore#/14 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="RenderableImage.java">
  <comments>/*&#xA; * @(#)RenderableImage.java&#x9;1.15 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/* ********************************************************************&#xA; **********************************************************************&#xA; **********************************************************************&#xA; *** COPYRIGHT (c) Eastman Kodak Company, 1997                      ***&#xA; *** As  an unpublished  work pursuant to Title 17 of the United    ***&#xA; *** States Code.  All rights reserved.                             ***&#xA; **********************************************************************&#xA; **********************************************************************&#xA; **********************************************************************/</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <namespaces>image</namespaces>
  <namespaces>renderable</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../util/Vector.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../RenderingHints.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="RenderableImage">
    <members xsi:type="members:Field" name="HINTS_OBSERVED">
      <initialValue xsi:type="references:StringReference" value="HINTS_OBSERVED"/>
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Static">
        <comments>/**&#xA;     * String constant that can be used to identify a property on&#xA;     * a RenderedImage obtained via the createRendering or&#xA;     * createScaledRendering methods.  If such a property exists,&#xA;     * the value of the propoery will be a RenderingHints object&#xA;     * specifying which hints were observed in creating the rendering.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Final"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getSources">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/** &#xA;     * Returns a vector of RenderableImages that are the sources of&#xA;     * image data for this RenderableImage. Note that this method may&#xA;     * return an empty vector, to indicate that the image has no sources,&#xA;     * or null, to indicate that no information is available.&#xA;     *&#xA;     * @return a (possibly empty) Vector of RenderableImages, or null.&#xA;     */</comments>
          <typeArguments xsi:type="generics:QualifiedTypeArgument">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences target="//@classifiers.0"/>
            </typeReference>
          </typeArguments>
          <target xsi:type="classifiers:Class" href="../../../util/Vector.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getProperty">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Gets a property from the property set of this image.&#xA;     * If the property name is not recognized, java.awt.Image.UndefinedProperty&#xA;     * will be returned.&#xA;     *&#xA;     * @param name the name of the property to get, as a String.&#xA;     * @return a reference to the property Object, or the value&#xA;     *         java.awt.Image.UndefinedProperty.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="name">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPropertyNames">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/** &#xA;     * Returns a list of names recognized by getProperty. &#xA;     * @return a list of property names.&#xA;     */</comments>
          <target xsi:type="classifiers:Class" href="../../../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <arrayDimensionsBefore/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isDynamic">
      <typeReference xsi:type="types:Boolean">
        <comments>/**&#xA;     * Returns true if successive renderings (that is, calls to&#xA;     * createRendering() or createScaledRendering()) with the same arguments&#xA;     * may produce different results.  This method may be used to&#xA;     * determine whether an existing rendering may be cached and&#xA;     * reused.  It is always safe to return true.&#xA;     * @return &lt;code>true&lt;/code> if successive renderings with the&#xA;     *         same arguments might produce different results;&#xA;     *         &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getWidth">
      <typeReference xsi:type="types:Float">
        <comments>/** &#xA;     * Gets the width in user coordinate space.  By convention, the&#xA;     * usual width of a RenderableImage is equal to the image's aspect&#xA;     * ratio (width divided by height).&#xA;     *&#xA;     * @return the width of the image in user coordinates.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getHeight">
      <typeReference xsi:type="types:Float">
        <comments>/**&#xA;     * Gets the height in user coordinate space.  By convention, the&#xA;     * usual height of a RenderedImage is equal to 1.0F.&#xA;     *&#xA;     * @return the height of the image in user coordinates.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMinX">
      <typeReference xsi:type="types:Float">
        <comments>/** &#xA;     * Gets the minimum X coordinate of the rendering-independent image data.&#xA;     * @return the minimum X coordinate of the rendering-independent image&#xA;     * data.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getMinY">
      <typeReference xsi:type="types:Float">
        <comments>/** &#xA;     * Gets the minimum Y coordinate of the rendering-independent image data.&#xA;     * @return the minimum Y coordinate of the rendering-independent image&#xA;     * data.&#xA;     */</comments>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createScaledRendering">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/**&#xA;     * Creates a RenderedImage instance of this image with width w, and&#xA;     * height h in pixels.  The RenderContext is built automatically&#xA;     * with an appropriate usr2dev transform and an area of interest&#xA;     * of the full image.  All the rendering hints come from hints&#xA;     * passed in.&#xA;     *&#xA;     * &lt;p> If w == 0, it will be taken to equal&#xA;     * Math.round(h*(getWidth()/getHeight())).&#xA;     * Similarly, if h == 0, it will be taken to equal&#xA;     * Math.round(w*(getHeight()/getWidth())).  One of&#xA;     * w or h must be non-zero or else an IllegalArgumentException &#xA;     * will be thrown.&#xA;     *&#xA;     * &lt;p> The created RenderedImage may have a property identified&#xA;     * by the String HINTS_OBSERVED to indicate which RenderingHints&#xA;     * were used to create the image.  In addition any RenderedImages&#xA;     * that are obtained via the getSources() method on the created&#xA;     * RenderedImage may have such a property.&#xA;     *&#xA;     * @param w the width of rendered image in pixels, or 0.&#xA;     * @param h the height of rendered image in pixels, or 0.&#xA;     * @param hints a RenderingHints object containg hints.&#xA;     * @return a RenderedImage containing the rendered data.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="../RenderedImage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hints">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../RenderingHints.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createDefaultRendering">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/** &#xA;     * Returnd a RenderedImage instance of this image with a default&#xA;     * width and height in pixels.  The RenderContext is built&#xA;     * automatically with an appropriate usr2dev transform and an area&#xA;     * of interest of the full image.  The rendering hints are&#xA;     * empty.  createDefaultRendering may make use of a stored&#xA;     * rendering for speed.&#xA;     *&#xA;     * @return a RenderedImage containing the rendered data.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="../RenderedImage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createRendering">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <comments>/** &#xA;     * Creates a RenderedImage that represented a rendering of this image&#xA;     * using a given RenderContext.  This is the most general way to obtain a&#xA;     * rendering of a RenderableImage.&#xA;     *&#xA;     * &lt;p> The created RenderedImage may have a property identified&#xA;     * by the String HINTS_OBSERVED to indicate which RenderingHints&#xA;     * (from the RenderContext) were used to create the image.&#xA;     * In addition any RenderedImages&#xA;     * that are obtained via the getSources() method on the created&#xA;     * RenderedImage may have such a property.&#xA;     *&#xA;     * @param renderContext the RenderContext to use to produce the rendering.&#xA;     * @return a RenderedImage containing the rendered data.&#xA;     */</comments>
          <target xsi:type="classifiers:Interface" href="../RenderedImage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="renderContext">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="RenderContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A RenderableImage is a common interface for rendering-independent&#xA; * images (a notion which subsumes resolution independence).  That is,&#xA; * images which are described and have operations applied to them&#xA; * independent of any specific rendering of the image.  For example, a&#xA; * RenderableImage can be rotated and cropped in&#xA; * resolution-independent terms.  Then, it can be rendered for various&#xA; * specific contexts, such as a draft preview, a high-quality screen&#xA; * display, or a printer, each in an optimal fashion.&#xA; * &#xA; * &lt;p> A RenderedImage is returned from a RenderableImage via the&#xA; * createRendering() method, which takes a RenderContext.  The&#xA; * RenderContext specifies how the RenderedImage should be&#xA; * constructed.  Note that it is not possible to extract pixels&#xA; * directly from a RenderableImage.&#xA; * &#xA; * &lt;p> The createDefaultRendering() and createScaledRendering() methods are&#xA; * convenience methods that construct an appropriate RenderContext&#xA; * internally.  All of the rendering methods may return a reference to a&#xA; * previously produced rendering.&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
