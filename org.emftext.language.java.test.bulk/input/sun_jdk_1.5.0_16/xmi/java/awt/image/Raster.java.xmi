<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:arrays="http://www.emftext.org/java/arrays" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xmlns:variables="http://www.emftext.org/java/variables" xsi:schemaLocation="http://www.emftext.org/java/arrays ../../../java.ecore#/1 http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16 http://www.emftext.org/java/variables ../../../java.ecore#/17" name="Raster.java">
  <comments>/*&#xA; * @(#)Raster.java&#x9;1.61 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <comments>/* ****************************************************************&#xA; ******************************************************************&#xA; ******************************************************************&#xA; *** COPYRIGHT (c) Eastman Kodak Company, 1997&#xA; *** As  an unpublished  work pursuant to Title 17 of the United&#xA; *** States Code.  All rights reserved.&#xA; ******************************************************************&#xA; ******************************************************************&#xA; ******************************************************************/</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <namespaces>image</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/awt/image/ByteInterleavedRaster.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/awt/image/ShortInterleavedRaster.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/awt/image/IntegerInterleavedRaster.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/awt/image/ByteBandedRaster.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/awt/image/ShortBandedRaster.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/awt/image/BytePackedRaster.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Raster">
    <members xsi:type="members:Field" name="sampleModel">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SampleModel.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The SampleModel that describes how pixels from this Raster&#xA;     * are stored in the DataBuffer.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="dataBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** The DataBuffer that stores the image data. */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="minX">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** The X coordinate of the upper-left pixel of this Raster. */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="minY">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** The Y coordinate of the upper-left pixel of this Raster. */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="width">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** The width of this Raster. */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="height">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** The height of this Raster. */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="sampleModelTranslateX">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The X translation from the coordinate space of the&#xA;     * Raster's SampleModel to that of the Raster.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="sampleModelTranslateY">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * The Y translation from the coordinate space of the&#xA;     * Raster's SampleModel to that of the Raster.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="numBands">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** The number of bands in the Raster. */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="numDataElements">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** The number of DataBuffer data elements per pixel. */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Field" name="parent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/** The parent of this Raster, or null. */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="initIDs">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Native"/>
    </members>
    <members xsi:type="statements:Block">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="ColorModel.class.xmi#//@classifiers.0/@members.23"/>
          </next>
          <target xsi:type="classifiers:Class" href="ColorModel.class.xmi#//@classifiers.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.11"/>
      </statements>
      <modifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:ClassMethod" name="createInterleavedRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bands">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a Raster based on a PixelInterleavedSampleModel with the&#xA;     * specified data type, width, height, and number of bands.&#xA;     *&#xA;     * &lt;p> The upper left corner of the Raster is given by the&#xA;     * location argument.  If location is null, (0, 0) will be used.&#xA;     * The dataType parameter should be one of the enumerated values&#xA;     * defined in the DataBuffer class.&#xA;     *&#xA;     * &lt;p> Note that interleaved &lt;code>DataBuffer.TYPE_INT&lt;/code>&#xA;     * Rasters are not supported.  To create a 1-band Raster of type&#xA;     * &lt;code>DataBuffer.TYPE_INT&lt;/code>, use&#xA;     * Raster.createPackedRaster().&#xA;     * &lt;p> The only dataTypes supported currently are TYPE_BYTE&#xA;     * and TYPE_USHORT.&#xA;     * @param dataType  the data type for storing samples&#xA;     * @param w         the width in pixels of the image data&#xA;     * @param h         the height in pixels of the image data&#xA;     * @param bands     the number of bands&#xA;     * @param location  the upper-left corner of the &lt;code>Raster&lt;/code>&#xA;     * @return a WritableRaster object with the specified data type,&#xA;     *         width, height and number of bands.&#xA;     * @throws RasterFormatException if &lt;code>w&lt;/code> or &lt;code>h&lt;/code>&#xA;     *         is less than or equal to zero, or computing either&#xA;     *         &lt;code>location.x + w&lt;/code> or&#xA;     *         &lt;code>location.y + h&lt;/code> results in integer&#xA;     *         overflow&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bandOffsets">
          <typeReference xsi:type="types:Int"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Int"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.3"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.1/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.1/@init"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.1/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.3"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.1/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.14">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.2"/>
          <arguments xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.3"/>
            <multiplicativeOperators xsi:type="operators:Multiplication"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.3"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@statements.0/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.13/@parameters.4"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createInterleavedRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scanlineStride">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pixelStride">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bandOffsets">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a Raster based on a PixelInterleavedSampleModel with the&#xA;     * specified data type, width, height, scanline stride, pixel&#xA;     * stride, and band offsets.  The number of bands is inferred from&#xA;     * bandOffsets.length.&#xA;     *&#xA;     * &lt;p> The upper left corner of the Raster is given by the&#xA;     * location argument.  If location is null, (0, 0) will be used.&#xA;     * The dataType parameter should be one of the enumerated values&#xA;     * defined in the DataBuffer class.&#xA;     *&#xA;     * &lt;p> Note that interleaved &lt;code>DataBuffer.TYPE_INT&lt;/code>&#xA;     * Rasters are not supported.  To create a 1-band Raster of type&#xA;     * &lt;code>DataBuffer.TYPE_INT&lt;/code>, use&#xA;     * Raster.createPackedRaster().&#xA;     * &lt;p> The only dataTypes supported currently are TYPE_BYTE&#xA;     * and TYPE_USHORT.&#xA;     * @param dataType  the data type for storing samples&#xA;     * @param w         the width in pixels of the image data&#xA;     * @param h         the height in pixels of the image data&#xA;     * @param scanlineStride the line stride of the image data&#xA;     * @param pixelStride the pixel stride of the image data&#xA;     * @param bandOffsets the offsets of all bands&#xA;     * @param location  the upper-left corner of the &lt;code>Raster&lt;/code>&#xA;     * @return a WritableRaster object with the specified data type,&#xA;     *         width, height, scanline stride, pixel stride and band&#xA;     *         offsets.&#xA;     * @throws RasterFormatException if &lt;code>w&lt;/code> or &lt;code>h&lt;/code>&#xA;     *         is less than or equal to zero, or computing either&#xA;     *         &lt;code>location.x + w&lt;/code> or&#xA;     *         &lt;code>location.y + h&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws IllegalArgumentException if &lt;code>dataType&lt;/code> is not&#xA;     *         one of the supported data types, which are&#xA;     *         &lt;code>DataBuffer.TYPE_BYTE&lt;/code>, or &#xA;     *         &lt;code>DataBuffer.TYPE_USHORT&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="d">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bands">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.5">
            <next xsi:type="references:IdentifierReference"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="maxBandOff">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.5">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.2/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.5">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.3/@init"/>
                    </arraySelectors>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.5">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.3/@init"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.2/@variable"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="size">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.2/@variable"/>
            <children xsi:type="expressions:MultiplicativeExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.3"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.2"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </expression>
              </children>
              <multiplicativeOperators xsi:type="operators:Multiplication"/>
            </children>
            <children xsi:type="expressions:MultiplicativeExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.4"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </expression>
              </children>
              <multiplicativeOperators xsi:type="operators:Multiplication"/>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Switch">
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="DataBufferByte.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.4/@variable"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="DataBufferUShort.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.4/@variable"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:DefaultSwitchCase">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Unsupported data type "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </cases>
        <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="raster">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.3"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.4"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.5"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.6"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.6/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0/@members.8"/>
            <arguments xsi:type="literals:BooleanLiteral"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@statements.6/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createBandedRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bands">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a Raster based on a BandedSampleModel with the&#xA;     * specified data type, width, height, and number of bands.&#xA;     *&#xA;     * &lt;p> The upper left corner of the Raster is given by the&#xA;     * location argument.  If location is null, (0, 0) will be used.&#xA;     * The dataType parameter should be one of the enumerated values&#xA;     * defined in the DataBuffer class.&#xA;     *&#xA;     * &lt;p> The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT,&#xA;     * and TYPE_INT.&#xA;     * @param dataType  the data type for storing samples&#xA;     * @param w         the width in pixels of the image data&#xA;     * @param h         the height in pixels of the image data&#xA;     * @param bands     the number of bands&#xA;     * @param location  the upper-left corner of the &lt;code>Raster&lt;/code>&#xA;     * @return a WritableRaster object with the specified data type,&#xA;     *         width, height and number of bands.&#xA;     * @throws RasterFormatException if &lt;code>w&lt;/code> or &lt;code>h&lt;/code>&#xA;     *         is less than or equal to zero, or computing either&#xA;     *         &lt;code>location.x + w&lt;/code> or&#xA;     *         &lt;code>location.y + h&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws ArrayIndexOutOfBoundsException if &lt;code>bands&lt;/code>&#xA;     *         is less than 1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Number of bands ("/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.3"/>
                <children xsi:type="references:StringReference" value=") must"/>
                <children xsi:type="references:StringReference" value=" be greater than 0"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.3"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bankIndices">
          <typeReference xsi:type="types:Int"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Int"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.3"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bandOffsets">
          <typeReference xsi:type="types:Int"/>
          <arrayDimensionsBefore/>
          <initialValue xsi:type="arrays:ArrayInstantiationBySize">
            <typeReference xsi:type="types:Int"/>
            <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.3"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.1/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@init"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.2/@variable">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@init"/>
                </arraySelectors>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.3"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.3/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.1/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@statements.2/@variable"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.4"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createBandedRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scanlineStride">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bankIndices">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bandOffsets">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a Raster based on a BandedSampleModel with the&#xA;     * specified data type, width, height, scanline stride, bank&#xA;     * indices and band offsets.  The number of bands is inferred from&#xA;     * bankIndices.length and bandOffsets.length, which must be the&#xA;     * same.&#xA;     *&#xA;     * &lt;p> The upper left corner of the Raster is given by the&#xA;     * location argument.  The dataType parameter should be one of the&#xA;     * enumerated values defined in the DataBuffer class.&#xA;     *&#xA;     * &lt;p> The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT,&#xA;     * and TYPE_INT.&#xA;     * @param dataType  the data type for storing samples&#xA;     * @param w         the width in pixels of the image data&#xA;     * @param h         the height in pixels of the image data&#xA;     * @param scanlineStride the line stride of the image data&#xA;     * @param bankIndices the bank indices for each band&#xA;     * @param bandOffsets the offsets of all bands&#xA;     * @param location  the upper-left corner of the &lt;code>Raster&lt;/code>&#xA;     * @return a WritableRaster object with the specified data type,&#xA;     *         width, height, scanline stride, bank indices and band&#xA;     *         offsets.&#xA;     * @throws RasterFormatException if &lt;code>w&lt;/code> or &lt;code>h&lt;/code>&#xA;     *         is less than or equal to zero, or computing either&#xA;     *         &lt;code>location.x + w&lt;/code> or&#xA;     *         &lt;code>location.y + h&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws IllegalArgumentException if &lt;code>dataType&lt;/code> is not&#xA;     *         one of the supported data types, which are&#xA;     *         &lt;code>DataBuffer.TYPE_BYTE&lt;/code>, &#xA;     *         &lt;code>DataBuffer.TYPE_USHORT&lt;/code> &#xA;     *         or &lt;code>DataBuffer.TYPE_INT&lt;/code>&#xA;     * @throws ArrayIndexOutOfBoundsException if &lt;code>bankIndices&lt;/code> &#xA;     *         or &lt;code>bandOffsets&lt;/code> is &lt;code>null&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="d">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bands">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.5">
            <next xsi:type="references:IdentifierReference"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Bank indices array is null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.4"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/ArrayIndexOutOfBoundsException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Band offsets array is null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.5"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="maxBank">
          <typeReference xsi:type="types:Int">
            <comments>// Figure out the #banks and the largest band offset</comments>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.4">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="maxBandOff">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.5">
            <arraySelectors>
              <position xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </arraySelectors>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ForLoop">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.4/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.4">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.6/@init"/>
                    </arraySelectors>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.4">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.6/@init"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.4/@variable"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.5/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.5">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.6/@init"/>
                    </arraySelectors>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.5">
                <arraySelectors>
                  <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.6/@init"/>
                </arraySelectors>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.5/@variable"/>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.6/@init"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.1/@variable"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
        <init xsi:type="variables:LocalVariable" name="i">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </init>
        <updates xsi:type="expressions:SuffixUnaryModificationExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.6/@init"/>
          <operator xsi:type="operators:PlusPlus"/>
        </updates>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="banks">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.4/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="size">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.5/@variable"/>
            <children xsi:type="expressions:MultiplicativeExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.3"/>
              <children xsi:type="expressions:NestedExpression">
                <expression xsi:type="expressions:AdditiveExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
                  <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                  <additiveOperators xsi:type="operators:Subtraction"/>
                </expression>
              </children>
              <multiplicativeOperators xsi:type="operators:Multiplication"/>
            </children>
            <children xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </expression>
            </children>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Switch">
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="DataBufferByte.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.8/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.7/@variable"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="DataBufferUShort.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.8/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.7/@variable"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="DataBufferInt.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.8/@variable"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.7/@variable"/>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.3"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:DefaultSwitchCase">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Unsupported data type "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </cases>
        <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="raster">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.20">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.3"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.4"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.5"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.6"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.10/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0/@members.8"/>
            <arguments xsi:type="literals:BooleanLiteral"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.10/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createPackedRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bandMasks">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a Raster based on a SinglePixelPackedSampleModel with&#xA;     * the specified data type, width, height, and band masks.&#xA;     * The number of bands is inferred from bandMasks.length.&#xA;     * &#xA;     * &lt;p> The upper left corner of the Raster is given by the&#xA;     * location argument.  If location is null, (0, 0) will be used.&#xA;     * The dataType parameter should be one of the enumerated values&#xA;     * defined in the DataBuffer class.&#xA;     *&#xA;     * &lt;p> The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT,&#xA;     * and TYPE_INT.&#xA;     * @param dataType  the data type for storing samples&#xA;     * @param w         the width in pixels of the image data&#xA;     * @param h         the height in pixels of the image data&#xA;     * @param bandMasks an array containing an entry for each band&#xA;     * @param location  the upper-left corner of the &lt;code>Raster&lt;/code>&#xA;     * @return a WritableRaster object with the specified data type,&#xA;     *         width, height, and band masks.&#xA;     * @throws RasterFormatException if &lt;code>w&lt;/code> or &lt;code>h&lt;/code>&#xA;     *         is less than or equal to zero, or computing either&#xA;     *         &lt;code>location.x + w&lt;/code> or&#xA;     *         &lt;code>location.y + h&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws IllegalArgumentException if &lt;code>dataType&lt;/code> is not&#xA;     *         one of the supported data types, which are&#xA;     *         &lt;code>DataBuffer.TYPE_BYTE&lt;/code>, &#xA;     *         &lt;code>DataBuffer.TYPE_USHORT&lt;/code> &#xA;     *         or &lt;code>DataBuffer.TYPE_INT&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="d">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Switch">
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="DataBufferByte.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:MultiplicativeExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.1"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.2"/>
                  <multiplicativeOperators xsi:type="operators:Multiplication"/>
                </arguments>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="DataBufferUShort.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:MultiplicativeExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.1"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.2"/>
                  <multiplicativeOperators xsi:type="operators:Multiplication"/>
                </arguments>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="DataBufferInt.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="expressions:MultiplicativeExpression">
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.1"/>
                  <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.2"/>
                  <multiplicativeOperators xsi:type="operators:Multiplication"/>
                </arguments>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:Break"/>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.3"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:DefaultSwitchCase">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Unsupported data type "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </cases>
        <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0"/>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="raster">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.21">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.3"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.4"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.2/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0/@members.8"/>
            <arguments xsi:type="literals:BooleanLiteral"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createPackedRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataType">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bands">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bitsPerBand">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a Raster based on a packed SampleModel with the&#xA;     * specified data type, width, height, number of bands, and bits&#xA;     * per band.  If the number of bands is one, the SampleModel will&#xA;     * be a MultiPixelPackedSampleModel.&#xA;     *&#xA;     * &lt;p> If the number of bands is more than one, the SampleModel&#xA;     * will be a SinglePixelPackedSampleModel, with each band having&#xA;     * bitsPerBand bits.  In either case, the requirements on dataType&#xA;     * and bitsPerBand imposed by the corresponding SampleModel must&#xA;     * be met.&#xA;     *&#xA;     * &lt;p> The upper left corner of the Raster is given by the&#xA;     * location argument.  If location is null, (0, 0) will be used.&#xA;     * The dataType parameter should be one of the enumerated values&#xA;     * defined in the DataBuffer class.&#xA;     *&#xA;     * &lt;p> The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT,&#xA;     * and TYPE_INT.&#xA;     * @param dataType  the data type for storing samples&#xA;     * @param w         the width in pixels of the image data&#xA;     * @param h         the height in pixels of the image data&#xA;     * @param bands     the number of bands&#xA;     * @param bitsPerBand the number of bits per band&#xA;     * @param location  the upper-left corner of the &lt;code>Raster&lt;/code>&#xA;     * @return a WritableRaster object with the specified data type,&#xA;     *         width, height, number of bands, and bits per band.&#xA;     * @throws RasterFormatException if &lt;code>w&lt;/code> or &lt;code>h&lt;/code>&#xA;     *         is less than or equal to zero, or computing either&#xA;     *         &lt;code>location.x + w&lt;/code> or&#xA;     *         &lt;code>location.y + h&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws IllegalArgumentException if the product of &#xA;     *         &lt;code>bitsPerBand&lt;/code> and &lt;code>bands&lt;/code> is &#xA;     *         greater than the number of bits held by &#xA;     *         &lt;code>dataType&lt;/code>&#xA;     * @throws IllegalArgumentException if &lt;code>bitsPerBand&lt;/code> or&#xA;     *         &lt;code>bands&lt;/code> is not greater than zero  &#xA;     * @throws IllegalArgumentException if &lt;code>dataType&lt;/code> is not&#xA;     *         one of the supported data types, which are&#xA;     *         &lt;code>DataBuffer.TYPE_BYTE&lt;/code>, &#xA;     *         &lt;code>DataBuffer.TYPE_USHORT&lt;/code> &#xA;     *         or &lt;code>DataBuffer.TYPE_INT&lt;/code>     &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="d">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Number of bands ("/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.3"/>
                <children xsi:type="references:StringReference" value=") must be greater than 0"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.3"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Bits per band ("/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.4"/>
                <children xsi:type="references:StringReference" value=") must be greater than 0"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.4"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          <relationOperators xsi:type="operators:LessThanOrEqual"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="masks">
              <typeReference xsi:type="types:Int"/>
              <arrayDimensionsBefore/>
              <initialValue xsi:type="arrays:ArrayInstantiationBySize">
                <typeReference xsi:type="types:Int"/>
                <sizes xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.3"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="mask">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:AdditiveExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ShiftExpression">
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.4"/>
                    <shiftOperators xsi:type="operators:LeftShift"/>
                  </expression>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="shift">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="expressions:MultiplicativeExpression">
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.3"/>
                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                  </expression>
                </children>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.4"/>
                <multiplicativeOperators xsi:type="operators:Multiplication"/>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:Condition">
            <comments>/* Make sure the total mask size will fit in the data type */</comments>
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="bitsPerBand("/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.4"/>
                    <children xsi:type="references:StringReference" value=") * bands is "/>
                    <children xsi:type="references:StringReference" value=" greater than data type "/>
                    <children xsi:type="references:StringReference" value="size."/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </throwable>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@statement/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.4"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </children>
              <children xsi:type="references:IdentifierReference">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="DataBuffer.class.xmi#//@classifiers.0/@members.13"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </condition>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <condition xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.3"/>
                </next>
                <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="Unsupported data type "/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </throwable>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
          </statements>
          <statements xsi:type="statements:ForLoop">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@statement/@statements.0/@variable">
                    <arraySelectors>
                      <position xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@statement/@statements.5/@init"/>
                    </arraySelectors>
                  </child>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:ShiftExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@statement/@statements.1/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@statement/@statements.2/@variable"/>
                    <shiftOperators xsi:type="operators:LeftShift"/>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@statement/@statements.2/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@statement/@statements.2/@variable"/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.4"/>
                    <additiveOperators xsi:type="operators:Subtraction"/>
                  </value>
                </expression>
              </statements>
            </statement>
            <condition xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@statement/@statements.5/@init"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.3"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </condition>
            <init xsi:type="variables:LocalVariable" name="i">
              <typeReference xsi:type="types:Int"/>
              <initialValue xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            </init>
            <updates xsi:type="expressions:SuffixUnaryModificationExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@statement/@statements.5/@init"/>
              <operator xsi:type="operators:PlusPlus"/>
            </updates>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.17">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@statement/@statements.0/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.5"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.3"/>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="fw">
              <typeReference xsi:type="types:Double"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
            </variable>
          </statements>
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="DataBufferByte.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="expressions:MultiplicativeExpression">
                      <children xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Int"/>
                        <child xsi:type="expressions:NestedExpression">
                          <expression xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../../lang/Math.class.xmi#//@classifiers.0/@members.20"/>
                              <arguments xsi:type="expressions:MultiplicativeExpression">
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@elseStatement/@statements.0/@variable"/>
                                <children xsi:type="expressions:NestedExpression">
                                  <expression xsi:type="expressions:MultiplicativeExpression">
                                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.4"/>
                                    <multiplicativeOperators xsi:type="operators:Division"/>
                                  </expression>
                                </children>
                                <multiplicativeOperators xsi:type="operators:Division"/>
                              </arguments>
                            </next>
                            <target xsi:type="classifiers:Class" href="../../lang/Math.class.xmi#//@classifiers.0"/>
                          </expression>
                        </child>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
                      <multiplicativeOperators xsi:type="operators:Multiplication"/>
                    </arguments>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="DataBufferUShort.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="expressions:MultiplicativeExpression">
                      <children xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Int"/>
                        <child xsi:type="expressions:NestedExpression">
                          <expression xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../../lang/Math.class.xmi#//@classifiers.0/@members.20"/>
                              <arguments xsi:type="expressions:MultiplicativeExpression">
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@elseStatement/@statements.0/@variable"/>
                                <children xsi:type="expressions:NestedExpression">
                                  <expression xsi:type="expressions:MultiplicativeExpression">
                                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="16"/>
                                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.4"/>
                                    <multiplicativeOperators xsi:type="operators:Division"/>
                                  </expression>
                                </children>
                                <multiplicativeOperators xsi:type="operators:Division"/>
                              </arguments>
                            </next>
                            <target xsi:type="classifiers:Class" href="../../lang/Math.class.xmi#//@classifiers.0"/>
                          </expression>
                        </child>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
                      <multiplicativeOperators xsi:type="operators:Multiplication"/>
                    </arguments>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:ExpressionStatement">
                <expression xsi:type="expressions:AssignmentExpression">
                  <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
                  <assignmentOperator xsi:type="operators:Assignment"/>
                  <value xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="DataBufferInt.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="expressions:MultiplicativeExpression">
                      <children xsi:type="expressions:CastExpression">
                        <typeReference xsi:type="types:Int"/>
                        <child xsi:type="expressions:NestedExpression">
                          <expression xsi:type="references:IdentifierReference">
                            <next xsi:type="references:MethodCall">
                              <target xsi:type="members:ClassMethod" href="../../lang/Math.class.xmi#//@classifiers.0/@members.20"/>
                              <arguments xsi:type="expressions:MultiplicativeExpression">
                                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@elseStatement/@statements.0/@variable"/>
                                <children xsi:type="expressions:NestedExpression">
                                  <expression xsi:type="expressions:MultiplicativeExpression">
                                    <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="32"/>
                                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.4"/>
                                    <multiplicativeOperators xsi:type="operators:Division"/>
                                  </expression>
                                </children>
                                <multiplicativeOperators xsi:type="operators:Division"/>
                              </arguments>
                            </next>
                            <target xsi:type="classifiers:Class" href="../../lang/Math.class.xmi#//@classifiers.0"/>
                          </expression>
                        </child>
                      </children>
                      <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
                      <multiplicativeOperators xsi:type="operators:Multiplication"/>
                    </arguments>
                  </value>
                </expression>
              </statements>
              <statements xsi:type="statements:Break"/>
              <condition xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.3"/>
                </next>
                <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:DefaultSwitchCase">
              <statements xsi:type="statements:Throw">
                <throwable xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="expressions:AdditiveExpression">
                    <children xsi:type="references:StringReference" value="Unsupported data type "/>
                    <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
                    <additiveOperators xsi:type="operators:Addition"/>
                  </arguments>
                </throwable>
              </statements>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
          </statements>
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="raster">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <initialValue xsi:type="expressions:CastExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.22">
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.4"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.5"/>
                </child>
              </initialValue>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@elseStatement/@statements.2/@variable">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0/@members.8"/>
                <arguments xsi:type="literals:BooleanLiteral"/>
              </next>
            </expression>
          </statements>
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.3/@elseStatement/@statements.2/@variable"/>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createInterleavedRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataBuffer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scanlineStride">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="pixelStride">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bandOffsets">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a Raster based on a PixelInterleavedSampleModel with the&#xA;     * specified DataBuffer, width, height, scanline stride, pixel&#xA;     * stride, and band offsets.  The number of bands is inferred from&#xA;     * bandOffsets.length.  The upper left corner of the Raster&#xA;     * is given by the location argument.  If location is null, (0, 0)&#xA;     * will be used.&#xA;     * &lt;p> Note that interleaved &lt;code>DataBuffer.TYPE_INT&lt;/code>&#xA;     * Rasters are not supported.  To create a 1-band Raster of type&#xA;     * &lt;code>DataBuffer.TYPE_INT&lt;/code>, use&#xA;     * Raster.createPackedRaster().&#xA;     * @param dataBuffer the &lt;code>DataBuffer&lt;/code> that contains the&#xA;     *        image data&#xA;     * @param w         the width in pixels of the image data&#xA;     * @param h         the height in pixels of the image data&#xA;     * @param scanlineStride the line stride of the image data&#xA;     * @param pixelStride the pixel stride of the image data&#xA;     * @param bandOffsets the offsets of all bands&#xA;     * @param location  the upper-left corner of the &lt;code>Raster&lt;/code>&#xA;     * @return a WritableRaster object with the specified&#xA;     *         &lt;code>DataBuffer&lt;/code>, width, height, scanline stride, &#xA;     *         pixel stride and band offsets.&#xA;     * @throws RasterFormatException if &lt;code>w&lt;/code> or &lt;code>h&lt;/code>&#xA;     *         is less than or equal to zero, or computing either&#xA;     *         &lt;code>location.x + w&lt;/code> or&#xA;     *         &lt;code>location.y + h&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws IllegalArgumentException if &lt;code>dataType&lt;/code> is not&#xA;     *         one of the supported data types, which are&#xA;     *         &lt;code>DataBuffer.TYPE_BYTE&lt;/code>, &#xA;     *         &lt;code>DataBuffer.TYPE_USHORT&lt;/code>&#xA;     * @throws RasterFormatException if &lt;code>dataBuffer&lt;/code> has more&#xA;     *         than one bank.&#xA;     * @throws NullPointerException if &lt;code>dataBuffer&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="DataBuffer cannot be null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.6"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.6"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dataType">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DataBuffer.class.xmi#//@classifiers.0/@members.18"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="csm">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="PixelInterleavedSampleModel.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="PixelInterleavedSampleModel.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.5"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Switch">
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ByteInterleavedRaster.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.6"/>
            </returnValue>
          </statements>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ShortInterleavedRaster.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.3/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.6"/>
            </returnValue>
          </statements>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:DefaultSwitchCase">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Unsupported data type "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </cases>
        <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createBandedRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataBuffer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scanlineStride">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bankIndices">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bandOffsets">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a Raster based on a BandedSampleModel with the&#xA;     * specified DataBuffer, width, height, scanline stride, bank&#xA;     * indices, and band offsets.  The number of bands is inferred&#xA;     * from bankIndices.length and bandOffsets.length, which must be&#xA;     * the same.  The upper left corner of the Raster is given by the&#xA;     * location argument.  If location is null, (0, 0) will be used.&#xA;     * @param dataBuffer the &lt;code>DataBuffer&lt;/code> that contains the&#xA;     *        image data&#xA;     * @param w         the width in pixels of the image data&#xA;     * @param h         the height in pixels of the image data&#xA;     * @param scanlineStride the line stride of the image data&#xA;     * @param bankIndices the bank indices for each band&#xA;     * @param bandOffsets the offsets of all bands&#xA;     * @param location  the upper-left corner of the &lt;code>Raster&lt;/code>&#xA;     * @return a WritableRaster object with the specified&#xA;     *         &lt;code>DataBuffer&lt;/code>, width, height, scanline stride, &#xA;     *         bank indices and band offsets.&#xA;     * @throws RasterFormatException if &lt;code>w&lt;/code> or &lt;code>h&lt;/code>&#xA;     *         is less than or equal to zero, or computing either&#xA;     *         &lt;code>location.x + w&lt;/code> or&#xA;     *         &lt;code>location.y + h&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws IllegalArgumentException if &lt;code>dataType&lt;/code> is not&#xA;     *         one of the supported data types, which are&#xA;     *         &lt;code>DataBuffer.TYPE_BYTE&lt;/code>, &#xA;     *         &lt;code>DataBuffer.TYPE_USHORT&lt;/code> &#xA;     *         or &lt;code>DataBuffer.TYPE_INT&lt;/code>&#xA;     * @throws NullPointerException if &lt;code>dataBuffer&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="DataBuffer cannot be null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.6"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.6"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dataType">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DataBuffer.class.xmi#//@classifiers.0/@members.18"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bands">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.4">
            <next xsi:type="references:IdentifierReference"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="bankIndices.length != bandOffsets.length"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.5">
            <next xsi:type="references:IdentifierReference"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.3/@variable"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="bsm">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="BandedSampleModel.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="BandedSampleModel.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.5"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Switch">
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ByteBandedRaster.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.5/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.6"/>
            </returnValue>
          </statements>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ShortBandedRaster.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.5/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.6"/>
            </returnValue>
          </statements>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.5/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.6"/>
            </returnValue>
          </statements>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.3"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:DefaultSwitchCase">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Unsupported data type "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.2/@variable"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </cases>
        <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createPackedRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataBuffer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="scanlineStride">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bandMasks">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a Raster based on a SinglePixelPackedSampleModel with&#xA;     * the specified DataBuffer, width, height, scanline stride, and&#xA;     * band masks.  The number of bands is inferred from bandMasks.length.&#xA;     * The upper left corner of the Raster is given by&#xA;     * the location argument.  If location is null, (0, 0) will be used.&#xA;     * @param dataBuffer the &lt;code>DataBuffer&lt;/code> that contains the&#xA;     *        image data&#xA;     * @param w         the width in pixels of the image data&#xA;     * @param h         the height in pixels of the image data&#xA;     * @param scanlineStride the line stride of the image data&#xA;     * @param bandMasks an array containing an entry for each band&#xA;     * @param location  the upper-left corner of the &lt;code>Raster&lt;/code>&#xA;     * @return a WritableRaster object with the specified&#xA;     *         &lt;code>DataBuffer&lt;/code>, width, height, scanline stride, &#xA;     *         and band masks.&#xA;     * @throws RasterFormatException if &lt;code>w&lt;/code> or &lt;code>h&lt;/code>&#xA;     *         is less than or equal to zero, or computing either&#xA;     *         &lt;code>location.x + w&lt;/code> or&#xA;     *         &lt;code>location.y + h&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws IllegalArgumentException if &lt;code>dataType&lt;/code> is not&#xA;     *         one of the supported data types, which are&#xA;     *         &lt;code>DataBuffer.TYPE_BYTE&lt;/code>, &#xA;     *         &lt;code>DataBuffer.TYPE_USHORT&lt;/code> &#xA;     *         or &lt;code>DataBuffer.TYPE_INT&lt;/code>&#xA;     * @throws RasterFormatException if &lt;code>dataBuffer&lt;/code> has more&#xA;     *         than one bank.&#xA;     * @throws NullPointerException if &lt;code>dataBuffer&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="DataBuffer cannot be null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.5"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.5"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dataType">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DataBuffer.class.xmi#//@classifiers.0/@members.18"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sppsm">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="SinglePixelPackedSampleModel.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SinglePixelPackedSampleModel.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.4"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Switch">
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ByteInterleavedRaster.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.3/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.5"/>
            </returnValue>
          </statements>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ShortInterleavedRaster.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.3/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.5"/>
            </returnValue>
          </statements>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:NormalSwitchCase">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../sun/awt/image/IntegerInterleavedRaster.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.3/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.5"/>
            </returnValue>
          </statements>
          <condition xsi:type="references:IdentifierReference">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.3"/>
            </next>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </condition>
        </cases>
        <cases xsi:type="statements:DefaultSwitchCase">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Unsupported data type "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.2/@variable"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </cases>
        <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@statements.2/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createPackedRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataBuffer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bitsPerPixel">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a Raster based on a MultiPixelPackedSampleModel with the&#xA;     * specified DataBuffer, width, height, and bits per pixel.  The upper&#xA;     * left corner of the Raster is given by the location argument.  If&#xA;     * location is null, (0, 0) will be used.&#xA;     * @param dataBuffer the &lt;code>DataBuffer&lt;/code> that contains the&#xA;     *        image data&#xA;     * @param w         the width in pixels of the image data&#xA;     * @param h         the height in pixels of the image data&#xA;     * @param bitsPerPixel the number of bits for each pixel&#xA;     * @param location  the upper-left corner of the &lt;code>Raster&lt;/code>&#xA;     * @return a WritableRaster object with the specified&#xA;     *         &lt;code>DataBuffer&lt;/code>, width, height, and&#xA;     *         bits per pixel.&#xA;     * @throws RasterFormatException if &lt;code>w&lt;/code> or &lt;code>h&lt;/code>&#xA;     *         is less than or equal to zero, or computing either&#xA;     *         &lt;code>location.x + w&lt;/code> or&#xA;     *         &lt;code>location.y + h&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws IllegalArgumentException if &lt;code>dataType&lt;/code> is not&#xA;     *         one of the supported data types, which are&#xA;     *         &lt;code>DataBuffer.TYPE_BYTE&lt;/code>, &#xA;     *         &lt;code>DataBuffer.TYPE_USHORT&lt;/code> &#xA;     *         or &lt;code>DataBuffer.TYPE_INT&lt;/code>&#xA;     * @throws RasterFormatException if &lt;code>dataBuffer&lt;/code> has more&#xA;     *         than one bank.&#xA;     * @throws NullPointerException if &lt;code>dataBuffer&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="DataBuffer cannot be null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.4"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.4"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dataType">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DataBuffer.class.xmi#//@classifiers.0/@members.18"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/IllegalArgumentException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="Unsupported data type "/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.2/@variable"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.2/@variable"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
            </children>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.2/@variable"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
              </next>
              <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
            </children>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.2/@variable"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.3"/>
              </next>
              <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
            </children>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="RasterFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="DataBuffer for packed Rasters"/>
                <children xsi:type="references:StringReference" value=" must only have 1 bank."/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="DataBuffer.class.xmi#//@classifiers.0/@members.22"/>
            </next>
          </children>
          <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="mppsm">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="MultiPixelPackedSampleModel.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="MultiPixelPackedSampleModel.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.2/@variable"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.3"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../sun/awt/image/BytePackedRaster.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.5/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.4"/>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.2/@variable"/>
            <children xsi:type="references:IdentifierReference">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
              </next>
              <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
            </children>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:ConditionalOrExpression">
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.3"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
              </children>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.3"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
              </children>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.3"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="4"/>
              </children>
            </expression>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@statements.5/@variable"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.4"/>
            </returnValue>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sm">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SampleModel.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="db">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Creates a Raster with the specified SampleModel and DataBuffer.&#xA;     *  The upper left corner of the Raster is given by the location argument.&#xA;     *  If location is null, (0, 0) will be used.&#xA;     *  @param sm the specified &lt;code>SampleModel&lt;/code>&#xA;     *  @param db the specified &lt;code>DataBuffer&lt;/code>&#xA;     *  @param location the upper-left corner of the &lt;code>Raster&lt;/code>&#xA;     *  @return a &lt;code>Raster&lt;/code> with the specified &#xA;     *          &lt;code>SampleModel&lt;/code>, &lt;code>DataBuffer&lt;/code>, and&#xA;     *          location.&#xA;     * @throws RasterFormatException if computing either&#xA;     *         &lt;code>location.x + sm.getWidth()&lt;/code> or&#xA;     *         &lt;code>location.y + sm.getHeight()&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws RasterFormatException if &lt;code>dataBuffer&lt;/code> has more&#xA;     *         than one bank and the &lt;code>sampleModel&lt;/code> is&#xA;     *         PixelInterleavedSampleModel, SinglePixelPackedSampleModel,&#xA;     *         or MultiPixelPackedSampleModel.&#xA;     *  @throws NullPointerException if either SampleModel or DataBuffer is &#xA;     *          null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="SampleModel and DataBuffer cannot be null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dataType">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.10"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ByteInterleavedRaster.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
                </returnValue>
              </statements>
              <condition xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ShortInterleavedRaster.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
                </returnValue>
              </statements>
              <condition xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
              </condition>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.2/@variable"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="PixelInterleavedSampleModel.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Switch">
              <cases xsi:type="statements:NormalSwitchCase">
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ByteInterleavedRaster.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
                  </returnValue>
                </statements>
                <condition xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
                </condition>
              </cases>
              <cases xsi:type="statements:NormalSwitchCase">
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ShortInterleavedRaster.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
                  </returnValue>
                </statements>
                <condition xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
                </condition>
              </cases>
              <cases xsi:type="statements:NormalSwitchCase">
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../../sun/awt/image/IntegerInterleavedRaster.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
                  </returnValue>
                </statements>
                <condition xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.3"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
                </condition>
              </cases>
              <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.2/@variable"/>
            </statements>
          </statement>
          <condition xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SinglePixelPackedSampleModel.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../sun/awt/image/BytePackedRaster.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
                </returnValue>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:InstanceOfExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="MultiPixelPackedSampleModel.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
              </children>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
                </children>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.44"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
            </condition>
          </elseStatement>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// we couldn't do anything special - do the generic thing</comments>
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createWritableRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sm">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SampleModel.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Creates a WritableRaster with the specified SampleModel.&#xA;     *  The upper left corner of the Raster is given by the location argument.&#xA;     *  If location is null, (0, 0) will be used.&#xA;     *  @param sm the specified &lt;code>SampleModel&lt;/code>&#xA;     *  @param location the upper-left corner of the &#xA;     *         &lt;code>WritableRaster&lt;/code>&#xA;     *  @return a &lt;code>WritableRaster&lt;/code> with the specified &#xA;     *          &lt;code>SampleModel&lt;/code> and location.&#xA;     *  @throws RasterFormatException if computing either&#xA;     *          &lt;code>location.x + sm.getWidth()&lt;/code> or&#xA;     *          &lt;code>location.y + sm.getHeight()&lt;/code> results in integer&#xA;     *          overflow&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="raster">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:MethodCall" target="//@classifiers.0/@members.25">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.42"/>
                </next>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
            </child>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.1/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0/@members.8"/>
            <arguments xsi:type="literals:BooleanLiteral"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.1/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createWritableRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sm">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SampleModel.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="db">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="location">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *  Creates a WritableRaster with the specified SampleModel and DataBuffer.&#xA;     *  The upper left corner of the Raster is given by the location argument.&#xA;     *  If location is null, (0, 0) will be used.&#xA;     *  @param sm the specified &lt;code>SampleModel&lt;/code>&#xA;     *  @param db the specified &lt;code>DataBuffer&lt;/code>&#xA;     *  @param location the upper-left corner of the &#xA;     *         &lt;code>WritableRaster&lt;/code>&#xA;     *  @return a &lt;code>WritableRaster&lt;/code> with the specified &#xA;     *          &lt;code>SampleModel&lt;/code>, &lt;code>DataBuffer&lt;/code>, and&#xA;     *          location.&#xA;     * @throws RasterFormatException if computing either&#xA;     *         &lt;code>location.x + sm.getWidth()&lt;/code> or&#xA;     *         &lt;code>location.y + sm.getHeight()&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws RasterFormatException if &lt;code>dataBuffer&lt;/code> has more&#xA;     *         than one bank and the &lt;code>sampleModel&lt;/code> is&#xA;     *         PixelInterleavedSampleModel, SinglePixelPackedSampleModel,&#xA;     *         or MultiPixelPackedSampleModel.&#xA;     * @throws NullPointerException if either SampleModel or DataBuffer is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="SampleModel and DataBuffer cannot be null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="dataType">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.10"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Switch">
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ByteInterleavedRaster.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
                </returnValue>
              </statements>
              <condition xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
                </next>
                <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
              </condition>
            </cases>
            <cases xsi:type="statements:NormalSwitchCase">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ShortInterleavedRaster.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
                </returnValue>
              </statements>
              <condition xsi:type="references:IdentifierReference">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
                </next>
                <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
              </condition>
            </cases>
            <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.2/@variable"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:InstanceOfExpression">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="PixelInterleavedSampleModel.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Switch">
              <cases xsi:type="statements:NormalSwitchCase">
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ByteInterleavedRaster.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
                  </returnValue>
                </statements>
                <condition xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
                </condition>
              </cases>
              <cases xsi:type="statements:NormalSwitchCase">
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../../sun/awt/image/ShortInterleavedRaster.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
                  </returnValue>
                </statements>
                <condition xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.1"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
                </condition>
              </cases>
              <cases xsi:type="statements:NormalSwitchCase">
                <statements xsi:type="statements:Return">
                  <returnValue xsi:type="instantiations:NewConstructorCall">
                    <typeReference xsi:type="types:NamespaceClassifierReference">
                      <classifierReferences>
                        <target xsi:type="classifiers:Class" href="../../../sun/awt/image/IntegerInterleavedRaster.class.xmi#//@classifiers.0"/>
                      </classifierReferences>
                    </typeReference>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
                    <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
                  </returnValue>
                </statements>
                <condition xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.3"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
                </condition>
              </cases>
              <variable xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.2/@variable"/>
            </statements>
          </statement>
          <condition xsi:type="expressions:InstanceOfExpression">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="SinglePixelPackedSampleModel.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
          </condition>
          <elseStatement xsi:type="statements:Condition">
            <statement xsi:type="statements:Block">
              <statements xsi:type="statements:Return">
                <returnValue xsi:type="instantiations:NewConstructorCall">
                  <typeReference xsi:type="types:NamespaceClassifierReference">
                    <classifierReferences>
                      <target xsi:type="classifiers:Class" href="../../../sun/awt/image/BytePackedRaster.class.xmi#//@classifiers.0"/>
                    </classifierReferences>
                  </typeReference>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
                </returnValue>
              </statements>
            </statement>
            <condition xsi:type="expressions:ConditionalAndExpression">
              <children xsi:type="expressions:InstanceOfExpression">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="MultiPixelPackedSampleModel.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
              </children>
              <children xsi:type="expressions:EqualityExpression">
                <equalityOperators xsi:type="operators:Equal"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.2/@variable"/>
                <children xsi:type="references:IdentifierReference">
                  <next xsi:type="references:IdentifierReference">
                    <target xsi:type="members:Field" href="DataBuffer.class.xmi#//@classifiers.0/@members.0"/>
                  </next>
                  <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
                </children>
              </children>
              <children xsi:type="expressions:RelationExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0">
                  <next xsi:type="references:MethodCall">
                    <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.44"/>
                    <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                  </next>
                </children>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="8"/>
                <relationOperators xsi:type="operators:LessThan"/>
              </children>
            </condition>
          </elseStatement>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// we couldn't do anything special - do the generic thing</comments>
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:Constructor" name="Raster">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.42"/>
            </next>
          </arguments>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../Point.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../Point.class.xmi#//@classifiers.0/@members.1"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.6"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.7"/>
              </next>
            </arguments>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.26/@parameters.1"/>
          <arguments xsi:type="literals:NullLiteral"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sampleModel">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SampleModel.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="origin">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     *  Constructs a Raster with the given SampleModel.  The Raster's&#xA;     *  upper left corner is origin and it is the same size as the&#xA;     *  SampleModel.  A DataBuffer large enough to describe the&#xA;     *  Raster is automatically created.&#xA;     *  @param sampleModel     The SampleModel that specifies the layout&#xA;     *  @param origin          The Point that specified the origin&#xA;     *  @throws RasterFormatException if computing either&#xA;     *          &lt;code>origin.x + sampleModel.getWidth()&lt;/code> or&#xA;     *          &lt;code>origin.y + sampleModel.getHeight()&lt;/code> results in&#xA;     *          integer overflow&#xA;     *  @throws NullPointerException either &lt;code>sampleModel&lt;/code> or &#xA;     *          &lt;code>origin&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Raster">
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="instantiations:ExplicitConstructorCall">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.1"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.2">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../Point.class.xmi#//@classifiers.0/@members.0"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.2">
              <next xsi:type="references:IdentifierReference">
                <target xsi:type="members:Field" href="../Point.class.xmi#//@classifiers.0/@members.1"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.6"/>
              </next>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.0">
              <next xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.7"/>
              </next>
            </arguments>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.27/@parameters.2"/>
          <arguments xsi:type="literals:NullLiteral"/>
          <callTarget xsi:type="literals:This"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sampleModel">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SampleModel.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataBuffer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="origin">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     *  Constructs a Raster with the given SampleModel and DataBuffer.&#xA;     *  The Raster's upper left corner is origin and it is the same size&#xA;     *  as the SampleModel.  The DataBuffer is not initialized and must&#xA;     *  be compatible with SampleModel.&#xA;     *  @param sampleModel     The SampleModel that specifies the layout&#xA;     *  @param dataBuffer      The DataBuffer that contains the image data&#xA;     *  @param origin          The Point that specifies the origin&#xA;     *  @throws RasterFormatException if computing either&#xA;     *          &lt;code>origin.x + sampleModel.getWidth()&lt;/code> or&#xA;     *          &lt;code>origin.y + sampleModel.getHeight()&lt;/code> results in&#xA;     *          integer overflow&#xA;     *  @throws NullPointerException either &lt;code>sampleModel&lt;/code> or&#xA;     *          &lt;code>origin&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:Constructor" name="Raster">
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="SampleModel, dataBuffer, aRegion and "/>
                <children xsi:type="references:StringReference" value="sampleModelTranslate cannot be null"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.2"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:EqualityExpression">
              <equalityOperators xsi:type="operators:Equal"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.3"/>
              <children xsi:type="literals:NullLiteral"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.2">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../Rectangle.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.2">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../Rectangle.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.2">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../Rectangle.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.2">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../Rectangle.class.xmi#//@classifiers.0/@members.3"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="RasterFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="negative or zero "/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ConditionalExpression">
                    <child xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        <relationOperators xsi:type="operators:LessThanOrEqual"/>
                      </expression>
                    </child>
                    <expressionIf xsi:type="references:StringReference" value="width"/>
                    <expressionElse xsi:type="references:StringReference" value="height"/>
                  </expression>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="RasterFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="overflow condition for X coordinates of Raster"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </expression>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="RasterFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="overflow condition for Y coordinates of Raster"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </expression>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.3">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../Point.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.3">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../Point.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.8"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.9"/>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.9"/>
            </next>
          </value>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="expressions:AssignmentExpression">
          <child xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
            <self xsi:type="literals:This"/>
          </child>
          <assignmentOperator xsi:type="operators:Assignment"/>
          <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.28/@parameters.4"/>
        </expression>
      </statements>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sampleModel">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="SampleModel.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dataBuffer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aRegion">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sampleModelTranslate">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parent">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences target="//@classifiers.0"/>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Constructs a Raster with the given SampleModel, DataBuffer, and&#xA;     * parent.  aRegion specifies the bounding rectangle of the new&#xA;     * Raster.  When translated into the base Raster's coordinate&#xA;     * system, aRegion must be contained by the base Raster.&#xA;     * (The base Raster is the Raster's ancestor which has no parent.)&#xA;     * sampleModelTranslate specifies the sampleModelTranslateX and&#xA;     * sampleModelTranslateY values of the new Raster.&#xA;     *&#xA;     * Note that this constructor should generally be called by other&#xA;     * constructors or create methods, it should not be used directly.&#xA;     * @param sampleModel     The SampleModel that specifies the layout&#xA;     * @param dataBuffer      The DataBuffer that contains the image data&#xA;     * @param aRegion         The Rectangle that specifies the image area     &#xA;     * @param sampleModelTranslate  The Point that specifies the translation&#xA;     *                        from SampleModel to Raster coordinates&#xA;     * @param parent          The parent (if any) of this raster&#xA;     * @throws NullPointerException if any of &lt;code>sampleModel&lt;/code>, &#xA;     *         &lt;code>dataBuffer&lt;/code>, &lt;code>aRegion&lt;/code> or &#xA;     *         &lt;code>sampleModelTranslate&lt;/code> is null&#xA;     * @throws RasterFormatException if &lt;code>aRegion&lt;/code> has width&#xA;     *         or height less than or equal to zero, or computing either&#xA;     *         &lt;code>aRegion.x + aRegion.width&lt;/code> or&#xA;     *         &lt;code>aRegion.y + aRegion.height&lt;/code> results in integer&#xA;     *         overflow&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getParent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns the parent Raster (if any) of this Raster or null. &#xA;     * @return the parent Raster or &lt;code>null&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.10"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSampleModelTranslateX">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Returns the X translation from the coordinate system of the&#xA;     * SampleModel to that of the Raster.  To convert a pixel's X&#xA;     * coordinate from the Raster coordinate system to the SampleModel&#xA;     * coordinate system, this value must be subtracted.&#xA;     * @return the X translation from the coordinate space of the&#xA;     *         Raster's SampleModel to that of the Raster.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSampleModelTranslateY">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/**&#xA;     * Returns the Y translation from the coordinate system of the&#xA;     * SampleModel to that of the Raster.  To convert a pixel's Y&#xA;     * coordinate from the Raster coordinate system to the SampleModel&#xA;     * coordinate system, this value must be subtracted.&#xA;     * @return the Y translation from the coordinate space of the&#xA;     *         Raster's SampleModel to that of the Raster.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createCompatibleWritableRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a compatible WritableRaster the same size as this Raster with&#xA;     * the same SampleModel and a new initialized DataBuffer.&#xA;     * @return a compatible &lt;code>WritableRaster&lt;/code> with the same sample&#xA;     *         model and a new data buffer.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createCompatibleWritableRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a compatible WritableRaster with the specified size, a new&#xA;     * SampleModel, and a new initialized DataBuffer.&#xA;     * @param w the specified width of the new &lt;code>WritableRaster&lt;/code>&#xA;     * @param h the specified height of the new &lt;code>WritableRaster&lt;/code>&#xA;     * @return a compatible &lt;code>WritableRaster&lt;/code> with the specified &#xA;     *         size and a new sample model and data buffer.&#xA;     * @exception RasterFormatException if the width or height is less than&#xA;     *                               or equal to zero.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="RasterFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:StringReference" value="negative "/>
                <children xsi:type="expressions:NestedExpression">
                  <expression xsi:type="expressions:ConditionalExpression">
                    <child xsi:type="expressions:NestedExpression">
                      <expression xsi:type="expressions:RelationExpression">
                        <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
                        <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
                        <relationOperators xsi:type="operators:LessThanOrEqual"/>
                      </expression>
                    </child>
                    <expressionIf xsi:type="references:StringReference" value="width"/>
                    <expressionElse xsi:type="references:StringReference" value="height"/>
                  </expression>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThanOrEqual"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="sm">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="SampleModel.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.40"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@parameters.1"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../sun/awt/image/SunWritableRaster.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.33/@statements.1/@variable"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createCompatibleWritableRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rect">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a compatible WritableRaster with location (minX, minY)&#xA;     * and size (width, height) specified by rect, a&#xA;     * new SampleModel, and a new initialized DataBuffer.&#xA;     * @param rect a &lt;code>Rectangle&lt;/code> that specifies the size and&#xA;     *        location of the &lt;code>WritableRaster&lt;/code>&#xA;     * @return a compatible &lt;code>WritableRaster&lt;/code> with the specified &#xA;     *         size and location and a new sample model and data buffer.&#xA;     * @throws RasterFormatException if &lt;code>rect&lt;/code> has width&#xA;     *         or height less than or equal to zero, or computing either&#xA;     *         &lt;code>rect.x + rect.width&lt;/code> or&#xA;     *         &lt;code>rect.y + rect.height&lt;/code> results in integer&#xA;     *         overflow&#xA;     * @throws NullPointerException if &lt;code>rect&lt;code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="Rect cannot be null"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.35">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../Rectangle.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../Rectangle.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../Rectangle.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="../Rectangle.class.xmi#//@classifiers.0/@members.3"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createCompatibleWritableRaster">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a compatible WritableRaster with the specified&#xA;     * location (minX, minY) and size (width, height), a&#xA;     * new SampleModel, and a new initialized DataBuffer.&#xA;     * @param x,&amp;nbsp;y the coordinates of the upper-left corner of&#xA;     *        the &lt;code>WritableRaster&lt;/code>&#xA;     * @param w the specified width of the &lt;code>WritableRaster&lt;/code>&#xA;     * @param h the specified height of the &lt;code>WritableRaster&lt;/code>&#xA;     * @return a compatible &lt;code>WritableRaster&lt;/code> with the specified &#xA;     *         size and location and a new sample model and data buffer.&#xA;     * @throws RasterFormatException if &lt;code>w&lt;/code> or &lt;code>h&lt;/code>&#xA;     *         is less than or equal to zero, or computing either&#xA;     *         &lt;code>x + w&lt;/code> or&#xA;     *         &lt;code>y + h&lt;/code> results in integer&#xA;     *         overflow&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="ret">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="WritableRaster.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.33">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.3"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="WritableRaster.class.xmi#//@classifiers.0/@members.5"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.35/@parameters.1"/>
            <arguments xsi:type="literals:NullLiteral"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createTranslatedChild">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="childMinX">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="childMinY">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Create a Raster with the same size, SampleModel and DataBuffer&#xA;     * as this one, but with a different location.  The new Raster&#xA;     * will possess a reference to the current Raster, accessible&#xA;     * through its getParent() method.&#xA;     * &#xA;     * @param childMinX,&amp;nbsp;childMinY coordinates of the upper-left &#xA;     *        corner of the new &lt;code>Raster&lt;/code>&#xA;     * @return a new &lt;code>Raster&lt;/code> with the same size, SampleModel, &#xA;     *         and DataBuffer as this &lt;code>Raster&lt;/code>, but with the&#xA;     *         specified location.&#xA;     * @throws RasterFormatException if  computing either&#xA;     *         &lt;code>childMinX + this.getWidth()&lt;/code> or&#xA;     *         &lt;code>childMinY + this.getHeight()&lt;/code> results in integer&#xA;     *         overflow&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.37">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.36/@parameters.1"/>
          <arguments xsi:type="literals:NullLiteral"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createChild">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parentX">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="parentY">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="childMinX">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="childMinY">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bandList">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a new Raster which shares all or part of this Raster's&#xA;     * DataBuffer.  The new Raster will possess a reference to the&#xA;     * current Raster, accessible through its getParent() method.&#xA;     *&#xA;     * &lt;p> The parentX, parentY, width and height parameters&#xA;     * form a Rectangle in this Raster's coordinate space,&#xA;     * indicating the area of pixels to be shared.  An error will&#xA;     * be thrown if this Rectangle is not contained with the bounds&#xA;     * of the current Raster.&#xA;     *&#xA;     * &lt;p> The new Raster may additionally be translated to a&#xA;     * different coordinate system for the plane than that used by the current&#xA;     * Raster.  The childMinX and childMinY parameters give the new&#xA;     * (x, y) coordinate of the upper-left pixel of the returned&#xA;     * Raster; the coordinate (childMinX, childMinY) in the new Raster&#xA;     * will map to the same pixel as the coordinate (parentX, parentY)&#xA;     * in the current Raster.&#xA;     *&#xA;     * &lt;p> The new Raster may be defined to contain only a subset of&#xA;     * the bands of the current Raster, possibly reordered, by means&#xA;     * of the bandList parameter.  If bandList is null, it is taken to&#xA;     * include all of the bands of the current Raster in their current&#xA;     * order.&#xA;     *&#xA;     * &lt;p> To create a new Raster that contains a subregion of the current&#xA;     * Raster, but shares its coordinate system and bands,&#xA;     * this method should be called with childMinX equal to parentX,&#xA;     * childMinY equal to parentY, and bandList equal to null.&#xA;     *&#xA;     * @param parentX,&amp;nbsp;parentY coordinates of the upper-left corner &#xA;     *        in this Raster's coordinates&#xA;     * @param width      Width of the region starting at (parentX, parentY)&#xA;     * @param height     Height of the region starting at (parentX, parentY).&#xA;     * @param childMinX,&amp;nbsp;childMinY coordinates of the upper-left corner &#xA;     *                   of the returned Raster&#xA;     * @param bandList   Array of band indices, or null to use all bands&#xA;     * @return a new &lt;code>Raster&lt;/code>.&#xA;     * @exception RasterFormatException if the specified subregion is outside&#xA;     *                               of the raster bounds.&#xA;     * @throws RasterFormatException if &lt;code>width&lt;/code> or&#xA;     *         &lt;code>height&lt;/code>&#xA;     *         is less than or equal to zero, or computing any of&#xA;     *         &lt;code>parentX + width&lt;/code>, &lt;code>parentY + height&lt;/code>,&#xA;     *         &lt;code>childMinX + width&lt;/code>, or&#xA;     *         &lt;code>childMinY + height&lt;/code> results in integer&#xA;     *         overflow&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="RasterFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="parentX lies outside raster"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
            <self xsi:type="literals:This"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="RasterFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="parentY lies outside raster"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1"/>
          <children xsi:type="references:SelfReference">
            <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
            <self xsi:type="literals:This"/>
          </children>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="RasterFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="(parentX + width) is outside raster"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.2"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.2"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </children>
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
                  <self xsi:type="literals:This"/>
                </children>
                <children xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
                  <self xsi:type="literals:This"/>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Throw">
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="RasterFormatException.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
              <arguments xsi:type="references:StringReference" value="(parentY + height) is outside raster"/>
            </throwable>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.3"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </children>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.3"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </children>
              <children xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
                  <self xsi:type="literals:This"/>
                </children>
                <children xsi:type="references:SelfReference">
                  <next xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
                  <self xsi:type="literals:This"/>
                </children>
                <additiveOperators xsi:type="operators:Addition"/>
              </children>
              <relationOperators xsi:type="operators:GreaterThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="subSampleModel">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="SampleModel.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <comments>// Note: the SampleModel for the child Raster should have the same</comments>
        <comments>// width and height as that for the parent, since it represents</comments>
        <comments>// the physical layout of the pixel data.  The child Raster's width</comments>
        <comments>// and height represent a &quot;virtual&quot; view of the pixel data, so</comments>
        <comments>// they may be different than those of the SampleModel.</comments>
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.4/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.6"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.4/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
                <next xsi:type="references:MethodCall">
                  <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.41"/>
                  <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.6"/>
                </next>
              </value>
            </expression>
          </statements>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="deltaX">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.4"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="deltaY">
          <typeReference xsi:type="types:Int"/>
          <initialValue xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.5"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <comments>// we use getDataBuffer() here, which will ensure that notifyStolen()</comments>
        <comments>// is invoked if this is a SunWritableRaster, thus disabling future</comments>
        <comments>// acceleration of this WritableRaster</comments>
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.4/@variable"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.46"/>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.5"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.3"/>
          </arguments>
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../Point.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.6/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@statements.7/@variable"/>
              <additiveOperators xsi:type="operators:Addition"/>
            </arguments>
          </arguments>
          <arguments xsi:type="references:SelfReference">
            <self xsi:type="literals:This"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getBounds">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the bounding Rectangle of this Raster. This function returns&#xA;     * the same information as getMinX/MinY/Width/Height.&#xA;     * @return the bounding box of this &lt;code>Raster&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMinX">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/** Returns the minimum valid X coordinate of the Raster.&#xA;     *  @return the minimum x coordinate of this &lt;code>Raster&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMinY">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/** Returns the minimum valid Y coordinate of the Raster. &#xA;     *  @return the minimum y coordinate of this &lt;code>Raster&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.3"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getWidth">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/** Returns the width in pixels of the Raster.  &#xA;     *  @return the width of this &lt;code>Raster&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.4"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getHeight">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/** Returns the height in pixels of the Raster.  &#xA;     *  @return the height of this &lt;code>Raster&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNumBands">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/** Returns the number of bands (samples per pixel) in this Raster. &#xA;     *  @return the number of bands of this &lt;code>Raster&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getNumDataElements">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/** &#xA;     *  Returns the number of data elements needed to transfer one pixel&#xA;     *  via the getDataElements and setDataElements methods.  When pixels&#xA;     *  are transferred via these methods, they may be transferred in a&#xA;     *  packed or unpacked format, depending on the implementation of the&#xA;     *  underlying SampleModel.  Using these methods, pixels are transferred&#xA;     *  as an array of getNumDataElements() elements of a primitive type given&#xA;     *  by getTransferType().  The TransferType may or may not be the same&#xA;     *  as the storage data type of the DataBuffer.&#xA;     *  @return the number of data elements.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.9"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getTransferType">
      <typeReference xsi:type="types:Int"/>
      <annotationsAndModifiers xsi:type="modifiers:Final">
        <comments>/** &#xA;     *  Returns the TransferType used to transfer pixels via the&#xA;     *  getDataElements and setDataElements methods.  When pixels&#xA;     *  are transferred via these methods, they may be transferred in a&#xA;     *  packed or unpacked format, depending on the implementation of the&#xA;     *  underlying SampleModel.  Using these methods, pixels are transferred&#xA;     *  as an array of getNumDataElements() elements of a primitive type given&#xA;     *  by getTransferType().  The TransferType may or may not be the same&#xA;     *  as the storage data type of the DataBuffer.  The TransferType will&#xA;     *  be one of the types defined in DataBuffer.&#xA;     *  @return this transfer type.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.11"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDataBuffer">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="DataBuffer.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Returns the DataBuffer associated with this Raster. &#xA;     *  @return the &lt;code>DataBuffer&lt;/code> of this &lt;code>Raster&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSampleModel">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="SampleModel.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** Returns the SampleModel that describes the layout of the image data. &#xA;     *  @return the &lt;code>SampleModel&lt;/code> of this &lt;code>Raster&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDataElements">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="outData">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns data for a single pixel in a primitive array of type&#xA;     * TransferType.  For image data supported by the Java 2D(tm) API, &#xA;     * this will be one of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, &#xA;     * DataBuffer.TYPE_INT, DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT,&#xA;     * or DataBuffer.TYPE_DOUBLE.  Data may be returned in a packed format,&#xA;     * thus increasing efficiency for data transfers.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * A ClassCastException will be thrown if the input object is non null&#xA;     * and references anything other than an array of TransferType.&#xA;     * @see java.awt.image.SampleModel#getDataElements(int, int, Object, DataBuffer)&#xA;     * @param x,&amp;nbsp;y    the coordinates of the pixel location&#xA;     * @param outData  An object reference to an array of type defined by&#xA;     *                 getTransferType() and length getNumDataElements(). &#xA;     *                 If null, an array of appropriate type and size will be&#xA;     *                 allocated&#xA;     * @return         An object reference to an array of type defined by&#xA;     *                 getTransferType() with the requested pixel data.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates are not&#xA;     * in bounds, or if outData is too small to hold the output.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.13"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.48/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getDataElements">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="outData">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the pixel data for the specified rectangle of pixels in a&#xA;     * primitive array of type TransferType.&#xA;     * For image data supported by the Java 2D API, this&#xA;     * will be one of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,&#xA;     * DataBuffer.TYPE_INT, DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT,&#xA;     * or DataBuffer.TYPE_DOUBLE.  Data may be returned in a packed format,&#xA;     * thus increasing efficiency for data transfers.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * A ClassCastException will be thrown if the input object is non null&#xA;     * and references anything other than an array of TransferType.&#xA;     * @see java.awt.image.SampleModel#getDataElements(int, int, int, int, Object, DataBuffer)&#xA;     * @param x,&amp;nbsp;y   the coordinates of the upper-left pixel location&#xA;     * @param w    Width of the pixel rectangle&#xA;     * @param h   Height of the pixel rectangle&#xA;     * @param outData  An object reference to an array of type defined by&#xA;     *                 getTransferType() and length w*h*getNumDataElements().  &#xA;     *                 If null, an array of appropriate type and size will be&#xA;     *                 allocated.&#xA;     * @return         An object reference to an array of type defined by&#xA;     *                 getTransferType() with the requested pixel data.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates are not&#xA;     * in bounds, or if outData is too small to hold the output.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPixel">
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="iArray">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the samples in an array of int for the specified pixel.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y    the coordinates of the pixel location&#xA;     * @param iArray An optionally preallocated int array&#xA;     * @return the samples for the specified pixel.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates are not&#xA;     * in bounds, or if iArray is too small to hold the output.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.12"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPixel">
      <typeReference xsi:type="types:Float"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fArray">
        <typeReference xsi:type="types:Float"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the samples in an array of float for the &#xA;     * specified pixel.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y    the coordinates of the pixel location&#xA;     * @param fArray An optionally preallocated float array&#xA;     * @return the samples for the specified pixel.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates are not&#xA;     * in bounds, or if fArray is too small to hold the output.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.17"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.51/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPixel">
      <typeReference xsi:type="types:Double"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dArray">
        <typeReference xsi:type="types:Double"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns the samples in an array of double for the specified pixel.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y    the coordinates of the pixel location&#xA;     * @param dArray An optionally preallocated double array&#xA;     * @return the samples for the specified pixel.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates are not&#xA;     * in bounds, or if dArray is too small to hold the output.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.18"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.52/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPixels">
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="iArray">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns an int array containing all samples for a rectangle of pixels,&#xA;     * one sample per array element.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y   the coordinates of the upper-left pixel location&#xA;     * @param w      Width of the pixel rectangle&#xA;     * @param h      Height of the pixel rectangle&#xA;     * @param iArray An optionally pre-allocated int array&#xA;     * @return the samples for the specified rectangle of pixels.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates are not&#xA;     * in bounds, or if iArray is too small to hold the output.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.19"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.53/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPixels">
      <typeReference xsi:type="types:Float"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fArray">
        <typeReference xsi:type="types:Float"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a float array containing all samples for a rectangle of pixels,&#xA;     * one sample per array element.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y    the coordinates of the pixel location&#xA;     * @param w        Width of the pixel rectangle&#xA;     * @param h        Height of the pixel rectangle&#xA;     * @param fArray   An optionally pre-allocated float array&#xA;     * @return the samples for the specified rectangle of pixels.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates are not&#xA;     * in bounds, or if fArray is too small to hold the output.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.20"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.54/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPixels">
      <typeReference xsi:type="types:Double"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dArray">
        <typeReference xsi:type="types:Double"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a double array containing all samples for a rectangle of pixels,&#xA;     * one sample per array element.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y   the coordinates of the upper-left pixel location&#xA;     * @param w        Width of the pixel rectangle&#xA;     * @param h        Height of the pixel rectangle&#xA;     * @param dArray   An optionally pre-allocated double array&#xA;     * @return the samples for the specified rectangle of pixels.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates are not&#xA;     * in bounds, or if dArray is too small to hold the output.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.21"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.55/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSample">
      <typeReference xsi:type="types:Int"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns the sample in a specified band for the pixel located&#xA;     * at (x,y) as an int.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y    the coordinates of the pixel location&#xA;     * @param b        The band to return&#xA;     * @return the sample in the specified band for the pixel at the&#xA;     *         specified coordinate.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates or&#xA;     * the band index are not in bounds.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.22"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.56/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSampleFloat">
      <typeReference xsi:type="types:Float"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns the sample in a specified band&#xA;     * for the pixel located at (x,y) as a float.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y    the coordinates of the pixel location&#xA;     * @param b        The band to return&#xA;     * @return the sample in the specified band for the pixel at the&#xA;     *         specified coordinate.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates or&#xA;     * the band index are not in bounds.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.23"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.57/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSampleDouble">
      <typeReference xsi:type="types:Double"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns the sample in a specified band&#xA;     * for a pixel located at (x,y) as a double.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y    the coordinates of the pixel location&#xA;     * @param b        The band to return&#xA;     * @return the sample in the specified band for the pixel at the&#xA;     *         specified coordinate.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates or&#xA;     * the band index are not in bounds.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.24"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.58/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSamples">
      <typeReference xsi:type="types:Int"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="iArray">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns the samples for a specified band for the specified rectangle&#xA;     * of pixels in an int array, one sample per array element.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y    the coordinates of the upper-left pixel location&#xA;     * @param w        Width of the pixel rectangle&#xA;     * @param h        Height of the pixel rectangle&#xA;     * @param b        The band to return&#xA;     * @param iArray   An optionally pre-allocated int array&#xA;     * @return the samples for the specified band for the specified &#xA;     *         rectangle of pixels.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates or&#xA;     * the band index are not in bounds, or if iArray is too small to&#xA;     * hold the output.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.25"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.59/@parameters.5"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSamples">
      <typeReference xsi:type="types:Float"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="fArray">
        <typeReference xsi:type="types:Float"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the samples for a specified band for the specified rectangle&#xA;     * of pixels in a float array, one sample per array element.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y   the coordinates of the upper-left pixel location&#xA;     * @param w        Width of the pixel rectangle&#xA;     * @param h        Height of the pixel rectangle&#xA;     * @param b        The band to return&#xA;     * @param fArray   An optionally pre-allocated float array&#xA;     * @return the samples for the specified band for the specified &#xA;     *         rectangle of pixels.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates or&#xA;     * the band index are not in bounds, or if fArray is too small to&#xA;     * hold the output.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.26"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.60/@parameters.5"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getSamples">
      <typeReference xsi:type="types:Double"/>
      <arrayDimensionsBefore/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="b">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dArray">
        <typeReference xsi:type="types:Double"/>
        <arrayDimensionsAfter/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the samples for a specified band for a specified rectangle&#xA;     * of pixels in a double array, one sample per array element.&#xA;     * An ArrayIndexOutOfBoundsException may be thrown&#xA;     * if the coordinates are not in bounds.  However, explicit bounds&#xA;     * checking is not guaranteed.&#xA;     * @param x,&amp;nbsp;y   the coordinates of the upper-left pixel location&#xA;     * @param w        Width of the pixel rectangle&#xA;     * @param h        Height of the pixel rectangle&#xA;     * @param b        The band to return&#xA;     * @param dArray   An optionally pre-allocated double array&#xA;     * @return the samples for the specified band for the specified &#xA;     *         rectangle of pixels.&#xA;     *&#xA;     * @throws ArrayIndexOutOfBoundsException if the coordinates or&#xA;     * the band index are not in bounds, or if dArray is too small to&#xA;     * hold the output.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="SampleModel.class.xmi#//@classifiers.0/@members.27"/>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.0"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.6"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="expressions:AdditiveExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.1"/>
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7"/>
              <additiveOperators xsi:type="operators:Subtraction"/>
            </arguments>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.3"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.4"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.61/@parameters.5"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A class representing a rectangular array of pixels.  A Raster&#xA; * encapsulates a DataBuffer that stores the sample values and a&#xA; * SampleModel that describes how to locate a given sample value in a&#xA; * DataBuffer.&#xA; * &lt;p>&#xA; * A Raster defines values for pixels occupying a particular&#xA; * rectangular area of the plane, not necessarily including (0, 0).&#xA; * The rectangle, known as the Raster's bounding rectangle and&#xA; * available by means of the getBounds method, is defined by minX,&#xA; * minY, width, and height values.  The minX and minY values define&#xA; * the coordinate of the upper left corner of the Raster.  References&#xA; * to pixels outside of the bounding rectangle may result in an&#xA; * exception being thrown, or may result in references to unintended&#xA; * elements of the Raster's associated DataBuffer.  It is the user's&#xA; * responsibility to avoid accessing such pixels.&#xA; * &lt;p>&#xA; * A SampleModel describes how samples of a Raster&#xA; * are stored in the primitive array elements of a DataBuffer.&#xA; * Samples may be stored one per data element, as in a&#xA; * PixelInterleavedSampleModel or BandedSampleModel, or packed several to&#xA; * an element, as in a SinglePixelPackedSampleModel or&#xA; * MultiPixelPackedSampleModel.  The SampleModel is also&#xA; * controls whether samples are sign extended, allowing unsigned&#xA; * data to be stored in signed Java data types such as byte, short, and&#xA; * int.&#xA; * &lt;p>&#xA; * Although a Raster may live anywhere in the plane, a SampleModel&#xA; * makes use of a simple coordinate system that starts at (0, 0).  A&#xA; * Raster therefore contains a translation factor that allows pixel&#xA; * locations to be mapped between the Raster's coordinate system and&#xA; * that of the SampleModel.  The translation from the SampleModel&#xA; * coordinate system to that of the Raster may be obtained by the&#xA; * getSampleModelTranslateX and getSampleModelTranslateY methods.&#xA; * &lt;p>&#xA; * A Raster may share a DataBuffer with another Raster either by&#xA; * explicit construction or by the use of the createChild and&#xA; * createTranslatedChild methods.  Rasters created by these methods&#xA; * can return a reference to the Raster they were created from by&#xA; * means of the getParent method.  For a Raster that was not&#xA; * constructed by means of a call to createTranslatedChild or&#xA; * createChild, getParent will return null.&#xA; * &lt;p>&#xA; * The createTranslatedChild method returns a new Raster that&#xA; * shares all of the data of the current Raster, but occupies a&#xA; * bounding rectangle of the same width and height but with a&#xA; * different starting point.  For example, if the parent Raster&#xA; * occupied the region (10, 10) to (100, 100), and the translated&#xA; * Raster was defined to start at (50, 50), then pixel (20, 20) of the&#xA; * parent and pixel (60, 60) of the child occupy the same location in&#xA; * the DataBuffer shared by the two Rasters.  In the first case, (-10,&#xA; * -10) should be added to a pixel coordinate to obtain the&#xA; * corresponding SampleModel coordinate, and in the second case (-50,&#xA; * -50) should be added.&#xA; * &lt;p>&#xA; * The translation between a parent and child Raster may be&#xA; * determined by subtracting the child's sampleModelTranslateX and&#xA; * sampleModelTranslateY values from those of the parent.&#xA; * &lt;p>&#xA; * The createChild method may be used to create a new Raster&#xA; * occupying only a subset of its parent's bounding rectangle&#xA; * (with the same or a translated coordinate system) or&#xA; * with a subset of the bands of its parent.&#xA; * &lt;p>&#xA; * All constructors are protected.  The correct way to create a&#xA; * Raster is to use one of the static create methods defined in this&#xA; * class.  These methods create instances of Raster that use the&#xA; * standard Interleaved, Banded, and Packed SampleModels and that may&#xA; * be processed more efficiently than a Raster created by combining&#xA; * an externally generated SampleModel and DataBuffer.&#xA; * @see java.awt.image.DataBuffer&#xA; * @see java.awt.image.SampleModel&#xA; * @see java.awt.image.PixelInterleavedSampleModel&#xA; * @see java.awt.image.BandedSampleModel&#xA; * @see java.awt.image.SinglePixelPackedSampleModel&#xA; * @see java.awt.image.MultiPixelPackedSampleModel&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
