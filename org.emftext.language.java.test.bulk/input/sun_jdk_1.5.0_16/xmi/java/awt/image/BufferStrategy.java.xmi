<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/types ../../../java.ecore#/16" name="BufferStrategy.java">
  <comments>/*&#xA; * @(#)BufferStrategy.java&#x9;1.6 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <namespaces>image</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../BufferCapabilities.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../Graphics.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../Image.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="BufferStrategy">
    <members xsi:type="members:InterfaceMethod" name="getCapabilities">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../BufferCapabilities.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * @return the buffering capabilities of this strategy&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDrawGraphics">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../Graphics.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * @return the graphics on the drawing buffer.  This method may not&#xA;     * be synchronized for performance reasons; use of this method by multiple&#xA;     * threads should be handled at the application level.  Disposal of the&#xA;     * graphics object obtained must be handled by the application.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="contentsLost">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns whether the drawing buffer was lost since the last call to&#xA;     * &lt;code>getDrawGraphics&lt;/code>.  Since the buffers in a buffer strategy&#xA;     * are usually type &lt;code>VolatileImage&lt;/code>, they may become lost.&#xA;     * For a discussion on lost buffers, see &lt;code>VolatileImage&lt;/code>.&#xA;     * @see java.awt.image.VolatileImage&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="contentsRestored">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns whether the drawing buffer was recently restored from a lost&#xA;     * state and reinitialized to the default background color (white).&#xA;     * Since the buffers in a buffer strategy are usually type&#xA;     * &lt;code>VolatileImage&lt;/code>, they may become lost.  If a surface has&#xA;     * been recently restored from a lost state since the last call to&#xA;     * &lt;code>getDrawGraphics&lt;/code>, it may require repainting.&#xA;     * For a discussion on lost buffers, see &lt;code>VolatileImage&lt;/code>.&#xA;     * @see java.awt.image.VolatileImage&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="show">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Makes the next available buffer visible by either copying the memory&#xA;     * (blitting) or changing the display pointer (flipping).&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>BufferStrategy&lt;/code> class represents the mechanism with which&#xA; * to organize complex memory on a particular &lt;code>Canvas&lt;/code> or&#xA; * &lt;code>Window&lt;/code>.  Hardware and software limitations determine whether and&#xA; * how a particular buffer strategy can be implemented.  These limitations&#xA; * are detectible through the capabilities of the&#xA; * &lt;code>GraphicsConfiguration&lt;/code> used when creating the&#xA; * &lt;code>Canvas&lt;/code> or &lt;code>Window&lt;/code>.&#xA; * &lt;p>&#xA; * It is worth noting that the terms &lt;i>buffer&lt;/i> and &lt;i>surface&lt;/i> are meant&#xA; * to be synonymous: an area of contiguous memory, either in video device&#xA; * memory or in system memory.&#xA; * &lt;p>&#xA; * There are several types of complex buffer strategies;&#xA; * sequential ring buffering, blit buffering, and stereo buffering are&#xA; * common types.  Sequential ring buffering (i.e., double or triple&#xA; * buffering) is the most common; an application draws to a single &lt;i>back&#xA; * buffer&lt;/i> and then moves the contents to the front (display) in a single&#xA; * step, either by copying the data or moving the video pointer.&#xA; * Moving the video pointer exchanges the buffers so that the first buffer&#xA; * drawn becomes the &lt;i>front buffer&lt;/i>, or what is currently displayed on the&#xA; * device; this is called &lt;i>page flipping&lt;/i>.&#xA; * &lt;p>&#xA; * Alternatively, the contents of the back buffer can be copied, or&#xA; * &lt;i>blitted&lt;/i> forward in a chain instead of moving the video pointer.&#xA; * &lt;p>&#xA; * &lt;pre>&#xA; * Double buffering:&#xA; *&#xA; *                    ***********         ***********&#xA; *                    *         * ------> *         *&#xA; * [To display] &lt;---- * Front B *   Show  * Back B. * &lt;---- Rendering&#xA; *                    *         * &lt;------ *         *&#xA; *                    ***********         ***********&#xA; *&#xA; * Triple buffering:&#xA; *&#xA; * [To      ***********         ***********        ***********&#xA; * display] *         * --------+---------+------> *         *&#xA; *    &lt;---- * Front B *   Show  * Mid. B. *        * Back B. * &lt;---- Rendering&#xA; *          *         * &lt;------ *         * &lt;----- *         *&#xA; *          ***********         ***********        ***********&#xA; *&#xA; * &lt;/pre>&#xA; * &lt;p>&#xA; * Stereo buffering is for hardware that supports rendering separate images for&#xA; * a left and right eye.  It is similar to sequential ring buffering, but&#xA; * there are two buffer chains, one for each eye.  Both buffer chains flip&#xA; * simultaneously:&#xA; *&#xA; * &lt;pre>&#xA; * Stereo buffering:&#xA; *&#xA; *                     ***********         ***********&#xA; *                     *         * ------> *         *&#xA; * [To left eye] &lt;---- * Front B *         * Back B. * &lt;---- Rendering&#xA; *                     *         * &lt;------ *         *&#xA; *                     ***********         ***********&#xA; *                                  Show&#xA; *                     ***********         ***********&#xA; *                     *         * ------> *         *&#xA; * [To right eye] &lt;--- * Front B *         * Back B. * &lt;---- Rendering&#xA; *                     *         * &lt;------ *         *&#xA; *                     ***********         ***********&#xA; * &lt;/pre>&#xA; * &lt;p>&#xA; * Here is an example of how buffer strategies can be created and used:&#xA; * &lt;pre>&lt;code>&#xA; *&#xA; * // Check the capabilities of the GraphicsConfiguration&#xA; * ...&#xA; *&#xA; * // Create our component&#xA; * Window w = new Window(gc);&#xA; *&#xA; * // Show our window&#xA; * w.setVisible(true);&#xA; *&#xA; * // Create a general double-buffering strategy&#xA; * w.createBufferStrategy(2);&#xA; * BufferStrategy strategy = w.getBufferStrategy();&#xA; *&#xA; * // Render loop&#xA; * while (!done) {&#xA; *    Graphics g = strategy.getDrawGraphics();&#xA; *    // Draw to graphics&#xA; *    ...&#xA; *    strategy.show();&#xA; * }&#xA; *&#xA; * // Dispose the window&#xA; * w.setVisible(false);&#xA; * w.dispose();&#xA; * &lt;/code>&lt;/pre>&#xA; *&#xA; * @see java.awt.Component&#xA; * @see java.awt.GraphicsConfiguration&#xA; * @author Michael Martak&#xA; * @since 1.4&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
