<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:generics="http://www.emftext.org/java/generics" xmlns:imports="http://www.emftext.org/java/imports" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/generics ../../java.ecore#/6 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="Graphics2D.java">
  <comments>/*&#xA; * @(#)Graphics2D.java&#x9;1.81 04/05/05&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>RenderingHints</namespaces>
    <classifier xsi:type="classifiers:Class" href="RenderingHints$Key.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>geom</namespaces>
    <classifier xsi:type="classifiers:Class" href="geom/AffineTransform.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Interface" href="image/ImageObserver.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Interface" href="image/BufferedImageOp.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="image/BufferedImage.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Interface" href="image/RenderedImage.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <namespaces>renderable</namespaces>
    <classifier xsi:type="classifiers:Interface" href="image/renderable/RenderableImage.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>font</namespaces>
    <classifier xsi:type="classifiers:Class" href="font/GlyphVector.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>font</namespaces>
    <classifier xsi:type="classifiers:Class" href="font/FontRenderContext.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>font</namespaces>
    <classifier xsi:type="classifiers:Class" href="font/TextAttribute.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../text/AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Graphics2D">
    <members xsi:type="members:Constructor" name="Graphics2D">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Constructs a new &lt;code>Graphics2D&lt;/code> object.  Since &#xA;     * &lt;code>Graphics2D&lt;/code> is an abstract class, and since it must be&#xA;     * customized by subclasses for different output devices,&#xA;     * &lt;code>Graphics2D&lt;/code> objects cannot be created directly.&#xA;     * Instead, &lt;code>Graphics2D&lt;/code> objects must be obtained from another &#xA;     * &lt;code>Graphics2D&lt;/code> object, created by a &#xA;     * &lt;code>Component&lt;/code>, or obtained from images such as&#xA;     * {@link BufferedImage} objects.&#xA;     * @see java.awt.Component#getGraphics&#xA;     * @see java.awt.Graphics#create&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="draw3DRect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="raised">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Draws a 3-D highlighted outline of the specified rectangle.&#xA;     * The edges of the rectangle are highlighted so that they&#xA;     * appear to be beveled and lit from the upper left corner.&#xA;     * &lt;p>&#xA;     * The colors used for the highlighting effect are determined &#xA;     * based on the current color.&#xA;     * The resulting rectangle covers an area that is &#xA;     * &lt;code>width&amp;nbsp;+&amp;nbsp;1&lt;/code> pixels wide&#xA;     * by &lt;code>height&amp;nbsp;+&amp;nbsp;1&lt;/code> pixels tall.  This method&#xA;     * uses the current &lt;code>Color&lt;/code> exclusively and ignores&#xA;     * the current &lt;code>Paint&lt;/code>.&#xA;     * @param x the x coordinate of the rectangle to be drawn.&#xA;     * @param y the y coordinate of the rectangle to be drawn.&#xA;     * @param width the width of the rectangle to be drawn.&#xA;     * @param height the height of the rectangle to be drawn.&#xA;     * @param raised a boolean that determines whether the rectangle&#xA;     *                      appears to be raised above the surface &#xA;     *                      or sunk into the surface.&#xA;     * @see         java.awt.Graphics#fill3DRect&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="Paint.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.4"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="brighter">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Color.class.xmi#//@classifiers.0/@members.50"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="darker">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Color.class.xmi#//@classifiers.0/@members.51"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.5"/>
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.4"/>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.2/@variable"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.3/@variable"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <comments>//drawLine(x, y, x, y + height);</comments>
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.19"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.1"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <comments>//drawLine(x + 1, y, x + width - 1, y);</comments>
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.19"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.1"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.5"/>
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.4"/>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.3/@variable"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.2/@variable"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <comments>//drawLine(x + 1, y + height, x + width, y + height);</comments>
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.19"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.3"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.2"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <comments>//drawLine(x + width, y, x + width, y + height - 1);</comments>
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.19"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.1"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@parameters.3"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.17">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1/@statements.0/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="fill3DRect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="raised">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Paints a 3-D highlighted rectangle filled with the current color.&#xA;     * The edges of the rectangle are highlighted so that it appears&#xA;     * as if the edges were beveled and lit from the upper left corner.&#xA;     * The colors used for the highlighting effect and for filling are&#xA;     * determined from the current &lt;code>Color&lt;/code>.  This method uses&#xA;     * the current &lt;code>Color&lt;/code> exclusively and ignores the current &#xA;     * &lt;code>Paint&lt;/code>.&#xA;     * @param x the x coordinate of the rectangle to be filled.&#xA;     * @param y the y coordinate of the rectangle to be filled.&#xA;     * @param       width the width of the rectangle to be filled.&#xA;     * @param       height the height of the rectangle to be filled.&#xA;     * @param       raised a boolean value that determines whether the &#xA;     *                      rectangle appears to be raised above the surface &#xA;     *                      or etched into the surface.&#xA;     * @see         java.awt.Graphics#draw3DRect&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="p">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Interface" href="Paint.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.33"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.4"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="brighter">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Color.class.xmi#//@classifiers.0/@members.50"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="darker">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.1/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Color.class.xmi#//@classifiers.0/@members.51"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.5"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.3/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.4"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:ExpressionStatement">
              <expression xsi:type="references:MethodCall">
                <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.5"/>
                <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.1/@variable"/>
              </expression>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:NotEqual"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.1/@variable"/>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.19"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.5"/>
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.4"/>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.2/@variable"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.3/@variable"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <comments>//drawLine(x, y, x, y + height - 1);</comments>
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.19"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.3"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <comments>//drawLine(x + 1, y, x + width - 2, y);</comments>
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.19"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.5"/>
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.4"/>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.3/@variable"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.2/@variable"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <comments>//drawLine(x + 1, y + height - 1, x + width - 1, y + height - 1);</comments>
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.19"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall">
          <comments>//drawLine(x + width - 1, y, x + width - 1, y + height - 2);</comments>
          <target xsi:type="members:ClassMethod" href="Graphics.class.xmi#//@classifiers.0/@members.19"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
          <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.17">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="draw">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Strokes the outline of a &lt;code>Shape&lt;/code> using the settings of the &#xA;     * current &lt;code>Graphics2D&lt;/code> context.  The rendering attributes&#xA;     * applied include the &lt;code>Clip&lt;/code>, &lt;code>Transform&lt;/code>,&#xA;     * &lt;code>Paint&lt;/code>, &lt;code>Composite&lt;/code> and &#xA;     * &lt;code>Stroke&lt;/code> attributes.&#xA;     * @param s the &lt;code>Shape&lt;/code> to be rendered&#xA;     * @see #setStroke&#xA;     * @see #setPaint&#xA;     * @see java.awt.Graphics#setColor&#xA;     * @see #transform&#xA;     * @see #setTransform     &#xA;     * @see #clip&#xA;     * @see #setClip&#xA;     * @see #setComposite    &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawImage">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="img">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Image.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="xform">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="geom/AffineTransform.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="obs">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="image/ImageObserver.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Renders an image, applying a transform from image space into user space&#xA;     * before drawing.&#xA;     * The transformation from user space into device space is done with&#xA;     * the current &lt;code>Transform&lt;/code> in the &lt;code>Graphics2D&lt;/code>.&#xA;     * The specified transformation is applied to the image before the&#xA;     * transform attribute in the &lt;code>Graphics2D&lt;/code> context is applied.&#xA;     * The rendering attributes applied include the &lt;code>Clip&lt;/code>,&#xA;     * &lt;code>Transform&lt;/code>, and &lt;code>Composite&lt;/code> attributes. &#xA;     * Note that no rendering is done if the specified transform is &#xA;     * noninvertible.&#xA;     * @param img the specified image to be rendered. &#xA;     *            This method does nothing if &lt;code>img&lt;/code> is null.&#xA;     * @param xform the transformation from image space into user space&#xA;     * @param obs the {@link ImageObserver}&#xA;     * to be notified as more of the &lt;code>Image&lt;/code>&#xA;     * is converted&#xA;     * @return &lt;code>true&lt;/code> if the &lt;code>Image&lt;/code> is &#xA;     * fully loaded and completely rendered, or if it's null;&#xA;     * &lt;code>false&lt;/code> if the &lt;code>Image&lt;/code> is still being loaded.&#xA;     * @see #transform&#xA;     * @see #setTransform&#xA;     * @see #setComposite&#xA;     * @see #clip&#xA;     * @see #setClip&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawImage">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="img">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="image/BufferedImage.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="op">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="image/BufferedImageOp.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Renders a &lt;code>BufferedImage&lt;/code> that is&#xA;     * filtered with a &#xA;     * {@link BufferedImageOp}.&#xA;     * The rendering attributes applied include the &lt;code>Clip&lt;/code>,&#xA;     * &lt;code>Transform&lt;/code>&#xA;     * and &lt;code>Composite&lt;/code> attributes.  This is equivalent to:&#xA;     * &lt;pre>&#xA;     * img1 = op.filter(img, null);&#xA;     * drawImage(img1, new AffineTransform(1f,0f,0f,1f,x,y), null);&#xA;     * &lt;/pre>&#xA;     * @param op the filter to be applied to the image before rendering&#xA;     * @param img the specified &lt;code>BufferedImage&lt;/code> to be rendered. &#xA;     *            This method does nothing if &lt;code>img&lt;/code> is null.&#xA;     * @param x the x coordinate of the location in user space where&#xA;     * the upper left corner of the image is rendered&#xA;     * @param y the y coordinate of the location in user space where&#xA;     * the upper left corner of the image is rendered&#xA;     *&#xA;     * @see #transform&#xA;     * @see #setTransform&#xA;     * @see #setComposite&#xA;     * @see #clip&#xA;     * @see #setClip&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawRenderedImage">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="img">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="image/RenderedImage.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="xform">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="geom/AffineTransform.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Renders a {@link RenderedImage},&#xA;     * applying a transform from image &#xA;     * space into user space before drawing.&#xA;     * The transformation from user space into device space is done with&#xA;     * the current &lt;code>Transform&lt;/code> in the &lt;code>Graphics2D&lt;/code>.&#xA;     * The specified transformation is applied to the image before the&#xA;     * transform attribute in the &lt;code>Graphics2D&lt;/code> context is applied.&#xA;     * The rendering attributes applied include the &lt;code>Clip&lt;/code>,&#xA;     * &lt;code>Transform&lt;/code>, and &lt;code>Composite&lt;/code> attributes. Note&#xA;     * that no rendering is done if the specified transform is&#xA;     * noninvertible.&#xA;     * @param img the image to be rendered. This method does&#xA;     *            nothing if &lt;code>img&lt;/code> is null.&#xA;     * @param xform the transformation from image space into user space&#xA;     * @see #transform&#xA;     * @see #setTransform&#xA;     * @see #setComposite&#xA;     * @see #clip&#xA;     * @see #setClip&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawRenderableImage">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="img">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="image/renderable/RenderableImage.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="xform">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="geom/AffineTransform.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Renders a &#xA;     * {@link RenderableImage},&#xA;     * applying a transform from image space into user space before drawing.&#xA;     * The transformation from user space into device space is done with&#xA;     * the current &lt;code>Transform&lt;/code> in the &lt;code>Graphics2D&lt;/code>.&#xA;     * The specified transformation is applied to the image before the&#xA;     * transform attribute in the &lt;code>Graphics2D&lt;/code> context is applied.&#xA;     * The rendering attributes applied include the &lt;code>Clip&lt;/code>,&#xA;     * &lt;code>Transform&lt;/code>, and &lt;code>Composite&lt;/code> attributes. Note&#xA;     * that no rendering is done if the specified transform is&#xA;     * noninvertible.&#xA;     *&lt;p> &#xA;     * Rendering hints set on the &lt;code>Graphics2D&lt;/code> object might&#xA;     * be used in rendering the &lt;code>RenderableImage&lt;/code>.  &#xA;     * If explicit control is required over specific hints recognized by a &#xA;     * specific &lt;code>RenderableImage&lt;/code>, or if knowledge of which hints &#xA;     * are used is required, then a &lt;code>RenderedImage&lt;/code> should be   &#xA;     * obtained directly from the &lt;code>RenderableImage&lt;/code>&#xA;     * and rendered using &#xA;     *{@link #drawRenderedImage(RenderedImage, AffineTransform) drawRenderedImage}.&#xA;     * @param img the image to be rendered. This method does&#xA;     *            nothing if &lt;code>img&lt;/code> is null.&#xA;     * @param xform the transformation from image space into user space&#xA;     * @see #transform&#xA;     * @see #setTransform&#xA;     * @see #setComposite&#xA;     * @see #clip&#xA;     * @see #setClip&#xA;     * @see #drawRenderedImage&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawString">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Renders the text of the specified &lt;code>String&lt;/code>, using the &#xA;     * current text attribute state in the &lt;code>Graphics2D&lt;/code> context. &#xA;     * The baseline of the &#xA;     * first character is at position (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in &#xA;     * the User Space. &#xA;     * The rendering attributes applied include the &lt;code>Clip&lt;/code>,&#xA;     * &lt;code>Transform&lt;/code>, &lt;code>Paint&lt;/code>, &lt;code>Font&lt;/code> and&#xA;     * &lt;code>Composite&lt;/code> attributes.  For characters in script &#xA;     * systems such as Hebrew and Arabic, the glyphs can be rendered from&#xA;     * right to left, in which case the coordinate supplied is the&#xA;     * location of the leftmost character on the baseline.&#xA;     * @param str the string to be rendered&#xA;     * @param x the x coordinate of the location where the&#xA;     * &lt;code>String&lt;/code> should be rendered&#xA;     * @param y the y coordinate of the location where the&#xA;     * &lt;code>String&lt;/code> should be rendered&#xA;     * @throws NullPointerException if &lt;code>str&lt;/code> is &#xA;     *         &lt;code>null&lt;/code>&#xA;     * @see         java.awt.Graphics#drawBytes&#xA;     * @see         java.awt.Graphics#drawChars&#xA;     * @since       JDK1.0&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawString">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Renders the text specified by the specified &lt;code>String&lt;/code>, &#xA;     * using the current text attribute state in the &lt;code>Graphics2D&lt;/code> context. &#xA;     * The baseline of the first character is at position &#xA;     * (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in the User Space.&#xA;     * The rendering attributes applied include the &lt;code>Clip&lt;/code>,&#xA;     * &lt;code>Transform&lt;/code>, &lt;code>Paint&lt;/code>, &lt;code>Font&lt;/code> and&#xA;     * &lt;code>Composite&lt;/code> attributes. For characters in script systems &#xA;     * such as Hebrew and Arabic, the glyphs can be rendered from right to&#xA;     * left, in which case the coordinate supplied is the location of the&#xA;     * leftmost character on the baseline.&#xA;     * @param s the &lt;code>String&lt;/code> to be rendered&#xA;     * @param x the x coordinate of the location where the&#xA;     * &lt;code>String&lt;/code> should be rendered&#xA;     * @param y the y coordinate of the location where the&#xA;     * &lt;code>String&lt;/code> should be rendered&#xA;     * @throws NullPointerException if &lt;code>str&lt;/code> is&#xA;     *         &lt;code>null&lt;/code>&#xA;     * @see #setPaint&#xA;     * @see java.awt.Graphics#setColor&#xA;     * @see java.awt.Graphics#setFont&#xA;     * @see #setTransform&#xA;     * @see #setComposite&#xA;     * @see #setClip&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawString">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="iterator">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../text/AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Renders the text of the specified iterator, using the&#xA;     * &lt;code>Graphics2D&lt;/code> context's current &lt;code>Paint&lt;/code>. The &#xA;     * iterator has to specify a font&#xA;     * for each character. The baseline of the &#xA;     * first character is at position (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in the &#xA;     * User Space. &#xA;     * The rendering attributes applied include the &lt;code>Clip&lt;/code>,&#xA;     * &lt;code>Transform&lt;/code>, &lt;code>Paint&lt;/code>, and&#xA;     * &lt;code>Composite&lt;/code> attributes.&#xA;     * For characters in script systems such as Hebrew and Arabic,&#xA;     * the glyphs can be rendered from right to left, in which case the &#xA;     * coordinate supplied is the location of the leftmost character&#xA;     * on the baseline.&#xA;     * @param iterator the iterator whose text is to be rendered&#xA;     * @param x the x coordinate where the iterator's text is to be&#xA;     * rendered&#xA;     * @param y the y coordinate where the iterator's text is to be&#xA;     * rendered&#xA;     * @see #setPaint&#xA;     * @see java.awt.Graphics#setColor&#xA;     * @see #setTransform&#xA;     * @see #setComposite&#xA;     * @see #setClip&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawString">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="iterator">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../text/AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Renders the text of the specified iterator, using the &#xA;     * &lt;code>Graphics2D&lt;/code> context's current &lt;code>Paint&lt;/code>. The &#xA;     * iterator must specify a font&#xA;     * for each character. The baseline of the &#xA;     * first character is at position (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in the &#xA;     * User Space. &#xA;     * The rendering attributes applied include the &lt;code>Clip&lt;/code>,&#xA;     * &lt;code>Transform&lt;/code>, &lt;code>Paint&lt;/code>, and&#xA;     * &lt;code>Composite&lt;/code> attributes.&#xA;     * For characters in script systems such as Hebrew and Arabic,&#xA;     * the glyphs can be rendered from right to left, in which case the &#xA;     * coordinate supplied is the location of the leftmost character&#xA;     * on the baseline.&#xA;     * @param iterator the iterator whose text is to be rendered&#xA;     * @param x the x coordinate where the iterator's text is to be&#xA;     * rendered&#xA;     * @param y the y coordinate where the iterator's text is to be&#xA;     * rendered&#xA;     * @see #setPaint&#xA;     * @see java.awt.Graphics#setColor&#xA;     * @see #setTransform&#xA;     * @see #setComposite&#xA;     * @see #setClip&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawGlyphVector">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="g">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="font/GlyphVector.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Float"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Renders the text of the specified &#xA;     * {@link GlyphVector} using&#xA;     * the &lt;code>Graphics2D&lt;/code> context's rendering attributes.&#xA;     * The rendering attributes applied include the &lt;code>Clip&lt;/code>,&#xA;     * &lt;code>Transform&lt;/code>, &lt;code>Paint&lt;/code>, and&#xA;     * &lt;code>Composite&lt;/code> attributes.  The &lt;code>GlyphVector&lt;/code>&#xA;     * specifies individual glyphs from a {@link Font}.&#xA;     * The &lt;code>GlyphVector&lt;/code> can also contain the glyph positions.  &#xA;     * This is the fastest way to render a set of characters to the&#xA;     * screen.&#xA;     * @param g the &lt;code>GlyphVector&lt;/code> to be rendered&#xA;     * @param x the x position in User Space where the glyphs should&#xA;     * be rendered&#xA;     * @param y the y position in User Space where the glyphs should&#xA;     * be rendered&#xA;     *&#xA;     * @see java.awt.Font#createGlyphVector&#xA;     * @see java.awt.font.GlyphVector&#xA;     * @see #setPaint&#xA;     * @see java.awt.Graphics#setColor&#xA;     * @see #setTransform&#xA;     * @see #setComposite&#xA;     * @see #setClip&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="fill">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Fills the interior of a &lt;code>Shape&lt;/code> using the settings of the   &#xA;     * &lt;code>Graphics2D&lt;/code> context. The rendering attributes applied &#xA;     * include the &lt;code>Clip&lt;/code>, &lt;code>Transform&lt;/code>,&#xA;     * &lt;code>Paint&lt;/code>, and &lt;code>Composite&lt;/code>.&#xA;     * @param s the &lt;code>Shape&lt;/code> to be filled&#xA;     * @see #setPaint&#xA;     * @see java.awt.Graphics#setColor&#xA;     * @see #transform&#xA;     * @see #setTransform&#xA;     * @see #setComposite&#xA;     * @see #clip&#xA;     * @see #setClip&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="hit">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="rect">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Rectangle.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="onStroke">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Checks whether or not the specified &lt;code>Shape&lt;/code> intersects &#xA;     * the specified {@link Rectangle}, which is in device&#xA;     * space. If &lt;code>onStroke&lt;/code> is false, this method checks&#xA;     * whether or not the interior of the specified &lt;code>Shape&lt;/code>&#xA;     * intersects the specified &lt;code>Rectangle&lt;/code>.  If &#xA;     * &lt;code>onStroke&lt;/code> is &lt;code>true&lt;/code>, this method checks&#xA;     * whether or not the &lt;code>Stroke&lt;/code> of the specified &#xA;     * &lt;code>Shape&lt;/code> outline intersects the specified&#xA;     * &lt;code>Rectangle&lt;/code>.&#xA;     * The rendering attributes taken into account include the&#xA;     * &lt;code>Clip&lt;/code>, &lt;code>Transform&lt;/code>, and &lt;code>Stroke&lt;/code> &#xA;     * attributes.&#xA;     * @param rect the area in device space to check for a hit&#xA;     * @param s the &lt;code>Shape&lt;/code> to check for a hit&#xA;     * @param onStroke flag used to choose between testing the &#xA;     * stroked or the filled shape.  If the flag is &lt;code>true&lt;/code>, the &#xA;     * &lt;code>Stroke&lt;/code> oultine is tested.  If the flag is &#xA;     * &lt;code>false&lt;/code>, the filled &lt;code>Shape&lt;/code> is tested.&#xA;     * @return &lt;code>true&lt;/code> if there is a hit; &lt;code>false&lt;/code> &#xA;     * otherwise.&#xA;     * @see #setStroke&#xA;     * @see #fill&#xA;     * @see #draw&#xA;     * @see #transform&#xA;     * @see #setTransform&#xA;     * @see #clip&#xA;     * @see #setClip&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDeviceConfiguration">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GraphicsConfiguration.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the device configuration associated with this &#xA;     * &lt;code>Graphics2D&lt;/code>.&#xA;     * @return the device configuration of this &lt;code>Graphics2D&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setComposite">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="comp">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Composite.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the &lt;code>Composite&lt;/code> for the &lt;code>Graphics2D&lt;/code> context.&#xA;     * The &lt;code>Composite&lt;/code> is used in all drawing methods such as &#xA;     * &lt;code>drawImage&lt;/code>, &lt;code>drawString&lt;/code>, &lt;code>draw&lt;/code>,&#xA;     * and &lt;code>fill&lt;/code>.  It specifies how new pixels are to be combined &#xA;     * with the existing pixels on the graphics device during the rendering &#xA;     * process.&#xA;     * &lt;p>If this &lt;code>Graphics2D&lt;/code> context is drawing to a&#xA;     * &lt;code>Component&lt;/code> on the display screen and the&#xA;     * &lt;code>Composite&lt;/code> is a custom object rather than an&#xA;     * instance of the &lt;code>AlphaComposite&lt;/code> class, and if&#xA;     * there is a security manager, its &lt;code>checkPermission&lt;/code>&#xA;     * method is called with an &lt;code>AWTPermission(&quot;readDisplayPixels&quot;)&lt;/code>&#xA;     * permission.&#xA;     * @throws SecurityException&#xA;     *         if a custom &lt;code>Composite&lt;/code> object is being&#xA;     *         used to render to the screen and a security manager&#xA;     *         is set and its &lt;code>checkPermission&lt;/code> method&#xA;     *         does not allow the operation.&#xA;     * @param comp the &lt;code>Composite&lt;/code> object to be used for rendering&#xA;     * @see java.awt.Graphics#setXORMode&#xA;     * @see java.awt.Graphics#setPaintMode&#xA;     * @see #getComposite&#xA;     * @see AlphaComposite&#xA;     * @see SecurityManager#checkPermission&#xA;     * @see java.awt.AWTPermission&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setPaint">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="paint">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Paint.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the &lt;code>Paint&lt;/code> attribute for the &#xA;     * &lt;code>Graphics2D&lt;/code> context.  Calling this method&#xA;     * with a &lt;code>null&lt;/code> &lt;code>Paint&lt;/code> object does &#xA;     * not have any effect on the current &lt;code>Paint&lt;/code> attribute&#xA;     * of this &lt;code>Graphics2D&lt;/code>.  &#xA;     * @param paint the &lt;code>Paint&lt;/code> object to be used to generate &#xA;     * color during the rendering process, or &lt;code>null&lt;/code>&#xA;     * @see java.awt.Graphics#setColor&#xA;     * @see #getPaint&#xA;     * @see GradientPaint&#xA;     * @see TexturePaint&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setStroke">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Stroke.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the &lt;code>Stroke&lt;/code> for the &lt;code>Graphics2D&lt;/code> context.&#xA;     * @param s the &lt;code>Stroke&lt;/code> object to be used to stroke a &#xA;     * &lt;code>Shape&lt;/code> during the rendering process&#xA;     * @see BasicStroke&#xA;     * @see #getStroke&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setRenderingHint">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hintKey">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="RenderingHints$Key.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hintValue">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the value of a single preference for the rendering algorithms.&#xA;     * Hint categories include controls for rendering quality and overall &#xA;     * time/quality trade-off in the rendering process.  Refer to the&#xA;     * &lt;code>RenderingHints&lt;/code> class for definitions of some common&#xA;     * keys and values.&#xA;     * @param hintKey the key of the hint to be set.&#xA;     * @param hintValue the value indicating preferences for the specified&#xA;     * hint category.&#xA;     * @see #getRenderingHint(RenderingHints.Key)&#xA;     * @see RenderingHints&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getRenderingHint">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hintKey">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="RenderingHints$Key.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the value of a single preference for the rendering algorithms.&#xA;     * Hint categories include controls for rendering quality and overall &#xA;     * time/quality trade-off in the rendering process.  Refer to the&#xA;     * &lt;code>RenderingHints&lt;/code> class for definitions of some common&#xA;     * keys and values.&#xA;     * @param hintKey the key corresponding to the hint to get. &#xA;     * @return an object representing the value for the specified hint key.&#xA;     * Some of the keys and their associated values are defined in the&#xA;     * &lt;code>RenderingHints&lt;/code> class.&#xA;     * @see RenderingHints&#xA;     * @see #setRenderingHint(RenderingHints.Key, Object)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setRenderingHints">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hints">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Replaces the values of all preferences for the rendering&#xA;     * algorithms with the specified &lt;code>hints&lt;/code>.&#xA;     * The existing values for all rendering hints are discarded and&#xA;     * the new set of known hints and values are initialized from the&#xA;     * specified {@link Map} object.&#xA;     * Hint categories include controls for rendering quality and&#xA;     * overall time/quality trade-off in the rendering process.&#xA;     * Refer to the &lt;code>RenderingHints&lt;/code> class for definitions of&#xA;     * some common keys and values.&#xA;     * @param hints the rendering hints to be set&#xA;     * @see #getRenderingHints&#xA;     * @see RenderingHints&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="addRenderingHints">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="hints">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <typeArguments xsi:type="generics:UnknownTypeArgument"/>
            <target xsi:type="classifiers:Interface" href="../util/Map.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the values of an arbitrary number of preferences for the&#xA;     * rendering algorithms.&#xA;     * Only values for the rendering hints that are present in the&#xA;     * specified &lt;code>Map&lt;/code> object are modified.&#xA;     * All other preferences not present in the specified &#xA;     * object are left unmodified.&#xA;     * Hint categories include controls for rendering quality and&#xA;     * overall time/quality trade-off in the rendering process.&#xA;     * Refer to the &lt;code>RenderingHints&lt;/code> class for definitions of&#xA;     * some common keys and values.&#xA;     * @param hints the rendering hints to be set&#xA;     * @see RenderingHints&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getRenderingHints">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="RenderingHints.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the preferences for the rendering algorithms.  Hint categories&#xA;     * include controls for rendering quality and overall time/quality&#xA;     * trade-off in the rendering process.&#xA;     * Returns all of the hint key/value pairs that were ever specified in &#xA;     * one operation.  Refer to the&#xA;     * &lt;code>RenderingHints&lt;/code> class for definitions of some common&#xA;     * keys and values.&#xA;     * @return a reference to an instance of &lt;code>RenderingHints&lt;/code>&#xA;     * that contains the current preferences.&#xA;     * @see RenderingHints&#xA;     * @see #setRenderingHints(Map)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="translate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates the origin of the &lt;code>Graphics2D&lt;/code> context to the &#xA;     * point (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in the current coordinate system. &#xA;     * Modifies the &lt;code>Graphics2D&lt;/code> context so that its new origin &#xA;     * corresponds to the point (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in the &#xA;     * &lt;code>Graphics2D&lt;/code> context's former coordinate system.  All &#xA;     * coordinates used in subsequent rendering operations on this graphics &#xA;     * context are relative to this new origin.&#xA;     * @param  x the specified x coordinate&#xA;     * @param  y the specified y coordinate&#xA;     * @since   JDK1.0&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="translate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="tx">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="ty">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Concatenates the current&#xA;     * &lt;code>Graphics2D&lt;/code> &lt;code>Transform&lt;/code> &#xA;     * with a translation transform. &#xA;     * Subsequent rendering is translated by the specified&#xA;     * distance relative to the previous position.&#xA;     * This is equivalent to calling transform(T), where T is an&#xA;     * &lt;code>AffineTransform&lt;/code> represented by the following matrix:&#xA;     * &lt;pre>&#xA;     *&#x9;&#x9;[   1    0    tx  ]&#xA;     *&#x9;&#x9;[   0    1    ty  ]&#xA;     *&#x9;&#x9;[   0    0    1   ]&#xA;     * &lt;/pre>&#xA;     * @param tx the distance to translate along the x-axis&#xA;     * @param ty the distance to translate along the y-axis&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rotate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="theta">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Concatenates the current &lt;code>Graphics2D&lt;/code>&#xA;     * &lt;code>Transform&lt;/code> with a rotation transform. &#xA;     * Subsequent rendering is rotated by the specified radians relative&#xA;     * to the previous origin.&#xA;     * This is equivalent to calling &lt;code>transform(R)&lt;/code>, where R is an&#xA;     * &lt;code>AffineTransform&lt;/code> represented by the following matrix:&#xA;     * &lt;pre>&#xA;     *&#x9;&#x9;[   cos(theta)    -sin(theta)    0   ]&#xA;     *&#x9;&#x9;[   sin(theta)     cos(theta)    0   ]&#xA;     *&#x9;&#x9;[       0              0         1   ]&#xA;     * &lt;/pre>&#xA;     * Rotating with a positive angle theta rotates points on the positive&#xA;     * x axis toward the positive y axis.&#xA;     * @param theta the angle of rotation in radians&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="rotate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="theta">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Concatenates the current &lt;code>Graphics2D&lt;/code> &#xA;     * &lt;code>Transform&lt;/code> with a translated rotation &#xA;     * transform.  Subsequent rendering is transformed by a transform&#xA;     * which is constructed by translating to the specified location, &#xA;     * rotating by the specified radians, and translating back by the same&#xA;     * amount as the original translation.  This is equivalent to the&#xA;     * following sequence of calls:&#xA;     * &lt;pre>&#xA;     *&#x9;&#x9;translate(x, y);&#xA;     *&#x9;&#x9;rotate(theta);&#xA;     *&#x9;&#x9;translate(-x, -y);&#xA;     * &lt;/pre>&#xA;     * Rotating with a positive angle theta rotates points on the positive&#xA;     * x axis toward the positive y axis.&#xA;     * @param theta the angle of rotation in radians&#xA;     * @param x the x coordinate of the origin of the rotation&#xA;     * @param y the y coordinate of the origin of the rotation&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="scale">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sx">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sy">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Concatenates the current &lt;code>Graphics2D&lt;/code>&#xA;     * &lt;code>Transform&lt;/code> with a scaling transformation &#xA;     * Subsequent rendering is resized according to the specified scaling&#xA;     * factors relative to the previous scaling.&#xA;     * This is equivalent to calling &lt;code>transform(S)&lt;/code>, where S is an&#xA;     * &lt;code>AffineTransform&lt;/code> represented by the following matrix:&#xA;     * &lt;pre>&#xA;     *&#x9;&#x9;[   sx   0    0   ]&#xA;     *&#x9;&#x9;[   0    sy   0   ]&#xA;     *&#x9;&#x9;[   0    0    1   ]&#xA;     * &lt;/pre>&#xA;     * @param sx the amount by which X coordinates in subsequent&#xA;     * rendering operations are multiplied relative to previous&#xA;     * rendering operations.&#xA;     * @param sy the amount by which Y coordinates in subsequent &#xA;     * rendering operations are multiplied relative to previous &#xA;     * rendering operations.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="shear">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="shx">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="shy">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Concatenates the current &lt;code>Graphics2D&lt;/code>&#xA;     * &lt;code>Transform&lt;/code> with a shearing transform. &#xA;     * Subsequent renderings are sheared by the specified&#xA;     * multiplier relative to the previous position.&#xA;     * This is equivalent to calling &lt;code>transform(SH)&lt;/code>, where SH&#xA;     * is an &lt;code>AffineTransform&lt;/code> represented by the following&#xA;     * matrix:&#xA;     * &lt;pre>&#xA;     *&#x9;&#x9;[   1   shx   0   ]&#xA;     *&#x9;&#x9;[  shy   1    0   ]&#xA;     *&#x9;&#x9;[   0    0    1   ]&#xA;     * &lt;/pre>&#xA;     * @param shx the multiplier by which coordinates are shifted in &#xA;     * the positive X axis direction as a function of their Y coordinate&#xA;     * @param shy the multiplier by which coordinates are shifted in&#xA;     * the positive Y axis direction as a function of their X coordinate&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="transform">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="Tx">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="geom/AffineTransform.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Composes an &lt;code>AffineTransform&lt;/code> object with the &#xA;     * &lt;code>Transform&lt;/code> in this &lt;code>Graphics2D&lt;/code> according &#xA;     * to the rule last-specified-first-applied.  If the current&#xA;     * &lt;code>Transform&lt;/code> is Cx, the result of composition&#xA;     * with Tx is a new &lt;code>Transform&lt;/code> Cx'.  Cx' becomes the&#xA;     * current &lt;code>Transform&lt;/code> for this &lt;code>Graphics2D&lt;/code>.&#xA;     * Transforming a point p by the updated &lt;code>Transform&lt;/code> Cx' is&#xA;     * equivalent to first transforming p by Tx and then transforming&#xA;     * the result by the original &lt;code>Transform&lt;/code> Cx.  In other&#xA;     * words, Cx'(p) = Cx(Tx(p)).  A copy of the Tx is made, if necessary,&#xA;     * so further modifications to Tx do not affect rendering.&#xA;     * @param Tx the &lt;code>AffineTransform&lt;/code> object to be composed with &#xA;     * the current &lt;code>Transform&lt;/code>&#xA;     * @see #setTransform&#xA;     * @see AffineTransform&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setTransform">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="Tx">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="geom/AffineTransform.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Overwrites the Transform in the &lt;code>Graphics2D&lt;/code> context.&#xA;     * WARNING: This method should &lt;b>never&lt;/b> be used to apply a new&#xA;     * coordinate transform on top of an existing transform because the &#xA;     * &lt;code>Graphics2D&lt;/code> might already have a transform that is&#xA;     * needed for other purposes, such as rendering Swing &#xA;     * components or applying a scaling transformation to adjust for the&#xA;     * resolution of a printer.  &#xA;     * &lt;p>To add a coordinate transform, use the &#xA;     * &lt;code>transform&lt;/code>, &lt;code>rotate&lt;/code>, &lt;code>scale&lt;/code>,&#xA;     * or &lt;code>shear&lt;/code> methods.  The &lt;code>setTransform&lt;/code> &#xA;     * method is intended only for restoring the original &#xA;     * &lt;code>Graphics2D&lt;/code> transform after rendering, as shown in this&#xA;     * example:&#xA;     * &lt;pre>&lt;blockquote>&#xA;     * // Get the current transform&#xA;     * AffineTransform saveAT = g2.getTransform();&#xA;     * // Perform transformation&#xA;     * g2d.transform(...);&#xA;     * // Render&#xA;     * g2d.draw(...);&#xA;     * // Restore original transform&#xA;     * g2d.setTransform(saveAT);&#xA;     * &lt;/blockquote>&lt;/pre>&#xA;     *&#xA;     * @param Tx the &lt;code>AffineTransform&lt;/code> that was retrieved&#xA;     *           from the &lt;code>getTransform&lt;/code> method&#xA;     * @see #transform&#xA;     * @see #getTransform&#xA;     * @see AffineTransform&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getTransform">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="geom/AffineTransform.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a copy of the current &lt;code>Transform&lt;/code> in the &#xA;     * &lt;code>Graphics2D&lt;/code> context.&#xA;     * @return the current &lt;code>AffineTransform&lt;/code> in the &#xA;     *             &lt;code>Graphics2D&lt;/code> context.&#xA;     * @see #transform&#xA;     * @see #setTransform&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getPaint">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Paint.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current &lt;code>Paint&lt;/code> of the &#xA;     * &lt;code>Graphics2D&lt;/code> context.&#xA;     * @return the current &lt;code>Graphics2D&lt;/code> &lt;code>Paint&lt;/code>,&#xA;     * which defines a color or pattern.&#xA;     * @see #setPaint&#xA;     * @see java.awt.Graphics#setColor&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getComposite">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Composite.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current &lt;code>Composite&lt;/code> in the&#xA;     * &lt;code>Graphics2D&lt;/code> context.&#xA;     * @return the current &lt;code>Graphics2D&lt;/code> &lt;code>Composite&lt;/code>,&#xA;     *              which defines a compositing style.&#xA;     * @see #setComposite&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setBackground">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="color">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the background color for the &lt;code>Graphics2D&lt;/code> context. &#xA;     * The background color is used for clearing a region.&#xA;     * When a &lt;code>Graphics2D&lt;/code> is constructed for a&#xA;     * &lt;code>Component&lt;/code>, the background color is&#xA;     * inherited from the &lt;code>Component&lt;/code>. Setting the background color &#xA;     * in the &lt;code>Graphics2D&lt;/code> context only affects the subsequent      &#xA;     * &lt;code>clearRect&lt;/code> calls and not the background color of the  &#xA;     * &lt;code>Component&lt;/code>.  To change the background&#xA;     * of the &lt;code>Component&lt;/code>, use appropriate methods of &#xA;     * the &lt;code>Component&lt;/code>.&#xA;     * @param color the background color that isused in&#xA;     * subsequent calls to &lt;code>clearRect&lt;/code>&#xA;     * @see #getBackground&#xA;     * @see java.awt.Graphics#clearRect&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBackground">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the background color used for clearing a region.&#xA;     * @return the current &lt;code>Graphics2D&lt;/code> &lt;code>Color&lt;/code>,&#xA;     * which defines the background color.&#xA;     * @see #setBackground&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getStroke">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Stroke.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current &lt;code>Stroke&lt;/code> in the&#xA;     * &lt;code>Graphics2D&lt;/code> context.&#xA;     * @return the current &lt;code>Graphics2D&lt;/code> &lt;code>Stroke&lt;/code>,&#xA;     *                 which defines the line style.&#xA;     * @see #setStroke&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clip">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="s">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Intersects the current &lt;code>Clip&lt;/code> with the interior of the&#xA;     * specified &lt;code>Shape&lt;/code> and sets the &lt;code>Clip&lt;/code> to the&#xA;     * resulting intersection.  The specified &lt;code>Shape&lt;/code> is&#xA;     * transformed with the current &lt;code>Graphics2D&lt;/code>&#xA;     * &lt;code>Transform&lt;/code> before being intersected with the current &#xA;     * &lt;code>Clip&lt;/code>.  This method is used to make the current&#xA;     * &lt;code>Clip&lt;/code> smaller.&#xA;     * To make the &lt;code>Clip&lt;/code> larger, use &lt;code>setClip&lt;/code>.&#xA;     * The &lt;i>user clip&lt;/i> modified by this method is independent of the&#xA;     * clipping associated with device bounds and visibility.  If no clip has &#xA;     * previously been set, or if the clip has been cleared using &#xA;     * {@link Graphics#setClip(Shape) setClip} with a &lt;code>null&lt;/code>&#xA;     * argument, the specified &lt;code>Shape&lt;/code> becomes the new &#xA;     * user clip.&#xA;     * @param s the &lt;code>Shape&lt;/code> to be intersected with the current&#xA;     *          &lt;code>Clip&lt;/code>.  If &lt;code>s&lt;/code> is &lt;code>null&lt;/code>,&#xA;     *          this method clears the current &lt;code>Clip&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFontRenderContext">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="font/FontRenderContext.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Get the rendering context of the &lt;code>Font&lt;/code> within this &#xA;     * &lt;code>Graphics2D&lt;/code> context.&#xA;     * The {@link FontRenderContext}&#xA;     * encapsulates application hints such as anti-aliasing and &#xA;     * fractional metrics, as well as target device specific information&#xA;     * such as dots-per-inch.  This information should be provided by the&#xA;     * application when using objects that perform typographical&#xA;     * formatting, such as &lt;code>Font&lt;/code> and&#xA;     * &lt;code>TextLayout&lt;/code>.  This information should also be provided&#xA;     * by applications that perform their own layout and need accurate&#xA;     * measurements of various characteristics of glyphs such as advance&#xA;     * and line height when various rendering hints have been applied to&#xA;     * the text rendering.&#xA;     *&#xA;     * @return a reference to an instance of FontRenderContext.&#xA;     * @see java.awt.font.FontRenderContext&#xA;     * @see java.awt.Font#createGlyphVector&#xA;     * @see java.awt.font.TextLayout&#xA;     * @since     1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * This &lt;code>Graphics2D&lt;/code> class extends the&#xA; * {@link Graphics} class to provide more sophisticated&#xA; * control over geometry, coordinate transformations, color management,&#xA; * and text layout.  This is the fundamental class for rendering&#xA; * 2-dimensional shapes, text and images on the  Java(tm) platform.&#xA; * &lt;p>&#xA; * &lt;h2>Coordinate Spaces&lt;/h2>&#xA; * All coordinates passed to a &lt;code>Graphics2D&lt;/code> object are specified &#xA; * in a device-independent coordinate system called User Space, which is&#xA; * used by applications.  The &lt;code>Graphics2D&lt;/code> object contains&#xA; * an {@link AffineTransform} object as part of its rendering state&#xA; * that defines how to convert coordinates from user space to&#xA; * device-dependent coordinates in Device Space.&#xA; * &lt;p>&#xA; * Coordinates in device space usually refer to individual device pixels&#xA; * and are aligned on the infinitely thin gaps between these pixels.&#xA; * Some &lt;code>Graphics2D&lt;/code> objects can be used to capture rendering &#xA; * operations for storage into a graphics metafile for playback on a&#xA; * concrete device of unknown physical resolution at a later time.  Since&#xA; * the resolution might not be known when the rendering operations are&#xA; * captured, the &lt;code>Graphics2D&lt;/code> &lt;code>Transform&lt;/code> is set up&#xA; * to transform user coordinates to a virtual device space that&#xA; * approximates the expected resolution of the target device. Further&#xA; * transformations might need to be applied at playback time if the&#xA; * estimate is incorrect.&#xA; * &lt;p>&#xA; * Some of the operations performed by the rendering attribute objects&#xA; * occur in the device space, but all &lt;code>Graphics2D&lt;/code> methods take &#xA; * user space coordinates.&#xA; * &lt;p>&#xA; * Every &lt;code>Graphics2D&lt;/code> object is associated with a target that&#xA; * defines where rendering takes place. A&#xA; * {@link GraphicsConfiguration} object defines the characteristics&#xA; * of the rendering target, such as pixel format and resolution.&#xA; * The same rendering target is used throughout the life of a&#xA; * &lt;code>Graphics2D&lt;/code> object. &#xA; * &lt;p>&#xA; * When creating a &lt;code>Graphics2D&lt;/code> object,  the &#xA; * &lt;code>GraphicsConfiguration&lt;/code> &#xA; * specifies the &lt;a name=&quot;#deftransform&quot;>default transform&lt;/a> for&#xA; * the target of the &lt;code>Graphics2D&lt;/code> (a &#xA; * {@link Component} or {@link Image}).  This default transform maps the&#xA; * user space coordinate system to screen and printer device coordinates&#xA; * such that the origin maps to the upper left hand corner of the&#xA; * target region of the device with increasing X coordinates extending&#xA; * to the right and increasing Y coordinates extending downward.&#xA; * The scaling of the default transform is set to identity for those devices &#xA; * that are close to 72 dpi, such as screen devices.&#xA; * The scaling of the default transform is set to approximately 72 user &#xA; * space coordinates per square inch for high resolution devices, such as&#xA; * printers.  For image buffers, the default transform is the&#xA; * &lt;code>Identity&lt;/code> transform.&#xA; *&#xA; * &lt;h2>Rendering Process&lt;/h2>&#xA; * The Rendering Process can be broken down into four phases that are &#xA; * controlled by the &lt;code>Graphics2D&lt;/code> rendering attributes.&#xA; * The renderer can optimize many of these steps, either by caching the&#xA; * results for future calls, by collapsing multiple virtual steps into&#xA; * a single operation, or by recognizing various attributes as common&#xA; * simple cases that can be eliminated by modifying other parts of the&#xA; * operation.&#xA; * &lt;p>&#xA; * The steps in the rendering process are:&#xA; * &lt;ol>&#xA; * &lt;li>&#xA; * Determine what to render.  &#xA; * &lt;li>&#xA; * Constrain the rendering operation to the current &lt;code>Clip&lt;/code>.&#xA; * The &lt;code>Clip&lt;/code> is specified by a {@link Shape} in user&#xA; * space and is controlled by the program using the various clip&#xA; * manipulation methods of &lt;code>Graphics&lt;/code> and&#xA; * &lt;code>Graphics2D&lt;/code>.  This &lt;i>user clip&lt;/i>&#xA; * is transformed into device space by the current&#xA; * &lt;code>Transform&lt;/code> and combined with the&#xA; * &lt;i>device clip&lt;/i>, which is defined by the visibility of windows and&#xA; * device extents.  The combination of the user clip and device clip&#xA; * defines the &lt;i>composite clip&lt;/i>, which determines the final clipping&#xA; * region.  The user clip is not modified by the rendering&#xA; * system to reflect the resulting composite clip. &#xA; * &lt;li>&#xA; * Determine what colors to render.&#xA; * &lt;li>&#xA; * Apply the colors to the destination drawing surface using the current&#xA; * {@link Composite} attribute in the &lt;code>Graphics2D&lt;/code> context.&#xA; * &lt;/ol>&#xA; * &lt;br>&#xA; * The three types of rendering operations, along with details of each &#xA; * of their particular rendering processes are:&#xA; * &lt;ol>&#xA; * &lt;li>&#xA; * &lt;b>&lt;a name=&quot;rendershape&quot;>&lt;code>Shape&lt;/code> operations&lt;/a>&lt;/b>&#xA; * &lt;ol>&#xA; * &lt;li>&#xA; * If the operation is a &lt;code>draw(Shape)&lt;/code> operation, then&#xA; * the  {@link Stroke#createStrokedShape(Shape) createStrokedShape} &#xA; * method on the current {@link Stroke} attribute in the&#xA; * &lt;code>Graphics2D&lt;/code> context is used to construct a new&#xA; * &lt;code>Shape&lt;/code> object that contains the outline of the specified&#xA; * &lt;code>Shape&lt;/code>.&#xA; * &lt;li>&#xA; * The &lt;code>Shape&lt;/code> is transformed from user space to device space&#xA; * using the current &lt;code>Transform&lt;/code> &#xA; * in the &lt;code>Graphics2D&lt;/code> context.&#xA; * &lt;li>&#xA; * The outline of the &lt;code>Shape&lt;/code> is extracted using the &#xA; * {@link Shape#getPathIterator(AffineTransform) getPathIterator} method of&#xA; * &lt;code>Shape&lt;/code>, which returns a&#xA; * {@link java.awt.geom.PathIterator PathIterator}&#xA; * object that iterates along the boundary of the &lt;code>Shape&lt;/code>.&#xA; * &lt;li>&#xA; * If the &lt;code>Graphics2D&lt;/code> object cannot handle the curved segments&#xA; * that the &lt;code>PathIterator&lt;/code> object returns then it can call the &#xA; * alternate &#xA; * {@link Shape#getPathIterator(AffineTransform, double) getPathIterator}&#xA; * method of &lt;code>Shape&lt;/code>, which flattens the &lt;code>Shape&lt;/code>.&#xA; * &lt;li>&#xA; * The current {@link Paint} in the &lt;code>Graphics2D&lt;/code> context&#xA; * is queried for a {@link PaintContext}, which specifies the&#xA; * colors to render in device space.&#xA; * &lt;/ol>&#xA; * &lt;li>&#xA; * &lt;b>&lt;a name=rendertext>Text operations&lt;/a>&lt;/b>&#xA; * &lt;ol>&#xA; * &lt;li>&#xA; * The following steps are used to determine the set of glyphs required&#xA; * to render the indicated &lt;code>String&lt;/code>:&#xA; * &lt;ol>&#xA; * &lt;li>&#xA; * If the argument is a &lt;code>String&lt;/code>, then the current&#xA; * &lt;code>Font&lt;/code> in the &lt;code>Graphics2D&lt;/code> context is asked to &#xA; * convert the Unicode characters in the &lt;code>String&lt;/code> into a set of &#xA; * glyphs for presentation with whatever basic layout and shaping&#xA; * algorithms the font implements.&#xA; * &lt;li>&#xA; * If the argument is an&#xA; * {@link AttributedCharacterIterator},&#xA; * the iterator is asked to convert itself to a&#xA; * {@link java.awt.font.TextLayout TextLayout}&#xA; * using its embedded font attributes. The &lt;code>TextLayout&lt;/code>&#xA; * implements more sophisticated glyph layout algorithms that&#xA; * perform Unicode bi-directional layout adjustments automatically&#xA; * for multiple fonts of differing writing directions.&#xA;  * &lt;li>&#xA; * If the argument is a&#xA; * {@link GlyphVector}, then the&#xA; * &lt;code>GlyphVector&lt;/code> object already contains the appropriate&#xA; * font-specific glyph codes with explicit coordinates for the position of&#xA; * each glyph.&#xA; * &lt;/ol>&#xA; * &lt;li>&#xA; * The current &lt;code>Font&lt;/code> is queried to obtain outlines for the &#xA; * indicated glyphs.  These outlines are treated as shapes in user space &#xA; * relative to the position of each glyph that was determined in step 1.&#xA; * &lt;li>&#xA; * The character outlines are filled as indicated above&#xA; * under &lt;a href=&quot;#rendershape&quot;>&lt;code>Shape&lt;/code> operations&lt;/a>.&#xA; * &lt;li>&#xA; * The current &lt;code>Paint&lt;/code> is queried for a&#xA; * &lt;code>PaintContext&lt;/code>, which specifies&#xA; * the colors to render in device space.&#xA; * &lt;/ol>&#xA; * &lt;li>&#xA; * &lt;b>&lt;a name= renderingimage>&lt;code>Image&lt;/code> Operations&lt;/a>&lt;/b>&#xA; * &lt;ol>&#xA; * &lt;li>&#xA; * The region of interest is defined by the bounding box of the source &#xA; * &lt;code>Image&lt;/code>.&#xA; * This bounding box is specified in Image Space, which is the &#xA; * &lt;code>Image&lt;/code> object's local coordinate system. &#xA; * &lt;li>&#xA; * If an &lt;code>AffineTransform&lt;/code> is passed to &#xA; * {@link #drawImage(java.awt.Image, java.awt.geom.AffineTransform, java.awt.image.ImageObserver) drawImage(Image, AffineTransform, ImageObserver)}, &#xA; * the &lt;code>AffineTransform&lt;/code> is used to transform the bounding&#xA; * box from image space to user space. If no &lt;code>AffineTransform&lt;/code> &#xA; * is supplied, the bounding box is treated as if it is already in user space.&#xA; * &lt;li>&#xA; * The bounding box of the source &lt;code>Image&lt;/code> is transformed from user&#xA; * space into device space using the current &lt;code>Transform&lt;/code>.&#xA; * Note that the result of transforming the bounding box does not&#xA; * necessarily result in a rectangular region in device space.&#xA; * &lt;li>&#xA; * The &lt;code>Image&lt;/code> object determines what colors to render, &#xA; * sampled according to the source to destination&#xA; * coordinate mapping specified by the current &lt;code>Transform&lt;/code> and the&#xA; * optional image transform.&#xA; * &lt;/ol>&#xA; * &lt;/ol>&#xA; *&#xA; * &lt;h2>Default Rendering Attributes&lt;/h2>&#xA; * The default values for the &lt;code>Graphics2D&lt;/code> rendering attributes are:&#xA; * &lt;dl compact>&#xA; * &lt;dt>&lt;i>&lt;code>Paint&lt;/code>&lt;/i>&#xA; * &lt;dd>The color of the &lt;code>Component&lt;/code>.&#xA; * &lt;dt>&lt;i>&lt;code>Font&lt;/code>&lt;/i>&#xA; * &lt;dd>The &lt;code>Font&lt;/code> of the &lt;code>Component&lt;/code>.&#xA; * &lt;dt>&lt;i>&lt;code>Stroke&lt;/code>&lt;/i>&#xA; * &lt;dd>A square pen with a linewidth of 1, no dashing, miter segment joins&#xA; * and square end caps.&#xA; * &lt;dt>&lt;i>&lt;code>Transform&lt;/code>&lt;/i>&#xA; * &lt;dd>The &#xA; * {@link GraphicsConfiguration#getDefaultTransform() getDefaultTransform} &#xA; * for the &lt;code>GraphicsConfiguration&lt;/code> of the &lt;code>Component&lt;/code>.&#xA; * &lt;dt>&lt;i>&lt;code>Composite&lt;/code>&lt;/i>&#xA; * &lt;dd>The {@link AlphaComposite#SRC_OVER} rule.&#xA; * &lt;dt>&lt;i>&lt;code>Clip&lt;/code>&lt;/i>&#xA; * &lt;dd>No rendering &lt;code>Clip&lt;/code>, the output is clipped to the&#xA; * &lt;code>Component&lt;/code>.&#xA; * &lt;/dl>&#xA; *&#xA; * &lt;h2>Rendering Compatibility Issues&lt;/h2>&#xA; * The JDK(tm) 1.1 rendering model is based on a pixelization model &#xA; * that specifies that coordinates&#xA; * are infinitely thin, lying between the pixels.  Drawing operations are &#xA; * performed using a one-pixel wide pen that fills the &#xA; * pixel below and to the right of the anchor point on the path.  &#xA; * The JDK 1.1 rendering model is consistent with the &#xA; * capabilities of most of the existing class of platform &#xA; * renderers that need  to resolve integer coordinates to a &#xA; * discrete pen that must fall completely on a specified number of pixels.  &#xA; * &lt;p>&#xA; * The Java 2D(tm) (Java(tm) 2 platform) API supports antialiasing renderers. &#xA; * A pen with a width of one pixel does not need to fall &#xA; * completely on pixel N as opposed to pixel N+1.  The pen can fall &#xA; * partially on both pixels. It is not necessary to choose a bias &#xA; * direction for a wide pen since the blending that occurs along the &#xA; * pen traversal edges makes the sub-pixel position of the pen &#xA; * visible to the user.  On the other hand, when antialiasing is &#xA; * turned off by setting the&#xA; * {@link RenderingHints#KEY_ANTIALIASING KEY_ANTIALIASING} hint key&#xA; * to the&#xA; * {@link RenderingHints#VALUE_ANTIALIAS_OFF VALUE_ANTIALIAS_OFF} &#xA; * hint value, the renderer might need &#xA; * to apply a bias to determine which pixel to modify when the pen &#xA; * is straddling a pixel boundary, such as when it is drawn&#xA; * along an integer coordinate in device space.  While the capabilities&#xA; * of an antialiasing renderer make it no longer necessary for the&#xA; * rendering model to specify a bias for the pen, it is desirable for the&#xA; * antialiasing and non-antialiasing renderers to perform similarly for&#xA; * the common cases of drawing one-pixel wide horizontal and vertical &#xA; * lines on the screen.  To ensure that turning on antialiasing by &#xA; * setting the &#xA; * {@link RenderingHints#KEY_ANTIALIASING KEY_ANTIALIASING} hint&#xA; * key to&#xA; * {@link RenderingHints#VALUE_ANTIALIAS_ON VALUE_ANTIALIAS_ON}&#xA; * does not cause such lines to suddenly become twice as wide and half&#xA; * as opaque, it is desirable to have the model specify a path for such&#xA; * lines so that they completely cover a particular set of pixels to help&#xA; * increase their crispness.&#xA; * &lt;p>&#xA; * Java 2D API maintains compatibility with JDK 1.1 rendering &#xA; * behavior, such that legacy operations and existing renderer&#xA; * behavior is unchanged under Java 2D API.  Legacy&#xA; * methods that map onto general &lt;code>draw&lt;/code> and &#xA; * &lt;code>fill&lt;/code> methods are defined, which clearly indicates &#xA; * how &lt;code>Graphics2D&lt;/code> extends &lt;code>Graphics&lt;/code> based &#xA; * on settings of &lt;code>Stroke&lt;/code> and &lt;code>Transform&lt;/code>&#xA; * attributes and rendering hints.  The definition &#xA; * performs identically under default attribute settings.  &#xA; * For example, the default &lt;code>Stroke&lt;/code> is a &#xA; * &lt;code>BasicStroke&lt;/code> with a width of 1 and no dashing and the&#xA; * default Transform for screen drawing is an Identity transform.  &#xA; * &lt;p>&#xA; * The following two rules provide predictable rendering behavior whether&#xA; * aliasing or antialiasing is being used.&#xA; * &lt;ul>&#xA; * &lt;li> Device coordinates are defined to be between device pixels which&#xA; * avoids any inconsistent results between aliased and antaliased&#xA; * rendering.  If coordinates were defined to be at a pixel's center, some&#xA; * of the pixels covered by a shape, such as a rectangle, would only be&#xA; * half covered.&#xA; * With aliased rendering, the half covered pixels would either be &#xA; * rendered inside the shape or outside the shape.  With anti-aliased&#xA; * rendering, the pixels on the entire edge of the shape would be half&#xA; * covered.  On the other hand, since coordinates are defined to be&#xA; * between pixels, a shape like a rectangle would have no half covered&#xA; * pixels, whether or not it is rendered using antialiasing. &#xA; * &lt;li> Lines and paths stroked using the &lt;code>BasicStroke&lt;/code>&#xA; * object may be &quot;normalized&quot; to provide consistent rendering of the&#xA; * outlines when positioned at various points on the drawable and&#xA; * whether drawn with aliased or antialiased rendering.  This&#xA; * normalization process is controlled by the &#xA; * {@link RenderingHints#KEY_STROKE_CONTROL KEY_STROKE_CONTROL} hint.&#xA; * The exact normalization algorithm is not specified, but the goals&#xA; * of this normalization are to ensure that lines are rendered with&#xA; * consistent visual appearance regardless of how they fall on the&#xA; * pixel grid and to promote more solid horizontal and vertical&#xA; * lines in antialiased mode so that they resemble their non-antialiased&#xA; * counterparts more closely.  A typical normalization step might&#xA; * promote antialiased line endpoints to pixel centers to reduce the&#xA; * amount of blending or adjust the subpixel positioning of&#xA; * non-antialiased lines so that the floating point line widths&#xA; * round to even or odd pixel counts with equal likelihood.  This&#xA; * process can move endpoints by up to half a pixel (usually towards&#xA; * positive infinity along both axes) to promote these consistent&#xA; * results.&#xA; * &lt;/ul>&#xA; * &lt;p>&#xA; * The following definitions of general legacy methods &#xA; * perform identically to previously specified behavior under default &#xA; * attribute settings:&#xA; * &lt;ul>&#xA; * &lt;li>&#xA; * For &lt;code>fill&lt;/code> operations, including &lt;code>fillRect&lt;/code>, &#xA; * &lt;code>fillRoundRect&lt;/code>, &lt;code>fillOval&lt;/code>,&#xA; * &lt;code>fillArc&lt;/code>, &lt;code>fillPolygon&lt;/code>, and &#xA; * &lt;code>clearRect&lt;/code>, {@link #fill(Shape) fill} can now be called&#xA; * with the desired &lt;code>Shape&lt;/code>.  For example, when filling a&#xA; * rectangle:&#xA; * &lt;pre>&#xA; * fill(new Rectangle(x, y, w, h));&#xA; * &lt;/pre>&#xA; * is called.&#xA; * &lt;p>&#xA; * &lt;li>&#xA; * Similarly, for draw operations, including &lt;code>drawLine&lt;/code>, &#xA; * &lt;code>drawRect&lt;/code>, &lt;code>drawRoundRect&lt;/code>,&#xA; * &lt;code>drawOval&lt;/code>, &lt;code>drawArc&lt;/code>, &lt;code>drawPolyline&lt;/code>,&#xA; * and &lt;code>drawPolygon&lt;/code>, {@link #draw(Shape) draw} can now be&#xA; * called with the desired &lt;code>Shape&lt;/code>.  For example, when drawing a&#xA; * rectangle:&#xA; * &lt;pre>&#xA; * draw(new Rectangle(x, y, w, h));&#xA; * &lt;/pre>&#xA; * is called.&#xA; * &lt;p>&#xA; * &lt;li>&#xA; * The &lt;code>draw3DRect&lt;/code> and &lt;code>fill3DRect&lt;/code> methods were&#xA; * implemented in terms of the &lt;code>drawLine&lt;/code> and &#xA; * &lt;code>fillRect&lt;/code> methods in the &lt;code>Graphics&lt;/code> class which&#xA; * would predicate their behavior upon the current &lt;code>Stroke&lt;/code>&#xA; * and &lt;code>Paint&lt;/code> objects in a &lt;code>Graphics2D&lt;/code> context.&#xA; * This class overrides those implementations with versions that use&#xA; * the current &lt;code>Color&lt;/code> exclusively, overriding the current&#xA; * &lt;code>Paint&lt;/code> and which uses &lt;code>fillRect&lt;/code> to describe&#xA; * the exact same behavior as the preexisting methods regardless of the&#xA; * setting of the current &lt;code>Stroke&lt;/code>.&#xA; * &lt;/ul>&#xA; * The &lt;code>Graphics&lt;/code> class defines only the &lt;code>setColor&lt;/code>&#xA; * method to control the color to be painted.  Since the Java 2D API extends&#xA; * the &lt;code>Color&lt;/code> object to implement the new &lt;code>Paint&lt;/code> &#xA; * interface, the existing&#xA; * &lt;code>setColor&lt;/code> method is now a convenience method for setting the &#xA; * current &lt;code>Paint&lt;/code> attribute to a &lt;code>Color&lt;/code> object.  &#xA; * &lt;code>setColor(c)&lt;/code> is equivalent to &lt;code>setPaint(c)&lt;/code>.&#xA; * &lt;p>&#xA; * The &lt;code>Graphics&lt;/code> class defines two methods for controlling&#xA; * how colors are applied to the destination.&#xA; * &lt;ol>&#xA; * &lt;li>&#xA; * The &lt;code>setPaintMode&lt;/code> method is implemented as a convenience&#xA; * method to set the default &lt;code>Composite&lt;/code>, equivalent to&#xA; * &lt;code>setComposite(new AlphaComposite.SrcOver)&lt;/code>.&#xA; * &lt;li>&#xA; * The &lt;code>setXORMode(Color xorcolor)&lt;/code> method is implemented&#xA; * as a convenience method to set a special &lt;code>Composite&lt;/code> object that&#xA; * ignores the &lt;code>Alpha&lt;/code> components of source colors and sets the&#xA; * destination color to the value:&#xA; * &lt;pre>&#xA; * dstpixel = (PixelOf(srccolor) ^ PixelOf(xorcolor) ^ dstpixel);&#xA; * &lt;/pre>&#xA; * &lt;/ol>&#xA; *&#xA; * @version &#x9;1.81, 05/05/04&#xA; * @author Jim Graham&#xA; * @see java.awt.RenderingHints&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <extends xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Class" href="Graphics.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </extends>
  </classifiers>
</containers:CompilationUnit>
