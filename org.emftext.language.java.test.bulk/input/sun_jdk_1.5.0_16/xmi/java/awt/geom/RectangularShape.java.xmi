<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/expressions ../../../java.ecore#/5 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/operators ../../../java.ecore#/12 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/references ../../../java.ecore#/14 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="RectangularShape.java">
  <comments>/*&#xA; * @(#)RectangularShape.java&#x9;1.18 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <namespaces>geom</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../Shape.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="RectangularShape">
    <members xsi:type="members:Constructor" name="RectangularShape">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * This is an abstract class that cannot be instantiated directly.&#xA;     *&#xA;     * @see Arc2D&#xA;     * @see Ellipse2D&#xA;     * @see Rectangle2D&#xA;     * @see RoundRectangle2D&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getX">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the X coordinate of the upper left corner of &#xA;     * the framing rectangle in &lt;code>double&lt;/code> precision.&#xA;     * @return the x coordinate of the upper left corner of&#xA;     * the framing rectangle.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getY">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the Y coordinate of the upper left corner of &#xA;     * the framing rectangle in &lt;code>double&lt;/code> precision.&#xA;     * @return the y coordinate of the upper left corner of&#xA;     * the framing rectangle.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getWidth">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the width of the framing rectangle in &#xA;     * &lt;code>double&lt;/code> precision.&#xA;     * @return the width of the framing rectangle.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getHeight">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the height of the framing rectangle&#xA;     * in &lt;code>double&lt;/code> precision.&#xA;     * @return the height of the framing rectangle.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getMinX">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smallest X coordinate of the framing&#xA;     * rectangle of the &lt;code>Shape&lt;/code> in &lt;code>double&lt;/code>&#xA;     * precision.&#xA;     * @return the smallest x coordinate of the framing &#xA;     * &#x9;&#x9;rectangle of the &lt;code>Shape&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMinY">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the smallest Y coordinate of the framing&#xA;     * rectangle of the &lt;code>Shape&lt;/code> in &lt;code>double&lt;/code> &#xA;     * precision.&#xA;     * @return the smallest y coordinate of the framing &#xA;     * &#x9;&#x9;rectangle of the &lt;code>Shape&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMaxX">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the largest X coordinate of the framing &#xA;     * rectangle of the &lt;code>Shape&lt;/code> in &lt;code>double&lt;/code>&#xA;     * precision.&#xA;     * @return the largest x coordinate of the framing&#xA;     * &#x9;&#x9;rectangle of the &lt;code>Shape&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getMaxY">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the largest Y coordinate of the framing &#xA;     * rectangle of the &lt;code>Shape&lt;/code> in &lt;code>double&lt;/code> &#xA;     * precision.&#xA;     * @return the largest y coordinate of the framing &#xA;     *&#x9;&#x9;rectangle of the &lt;code>Shape&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCenterX">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the X coordinate of the center of the framing&#xA;     * rectangle of the &lt;code>Shape&lt;/code> in &lt;code>double&lt;/code>&#xA;     * precision.&#xA;     * @return the x coordinate of the framing rectangle &#xA;     * &#x9;&#x9;of the &lt;code>Shape&lt;/code> object's center.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
          <children xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
            <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="2.0"/>
            <multiplicativeOperators xsi:type="operators:Division"/>
          </children>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getCenterY">
      <typeReference xsi:type="types:Double"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the Y coordinate of the center of the framing &#xA;     * rectangle of the &lt;code>Shape&lt;/code> in &lt;code>double&lt;/code>&#xA;     * precision.&#xA;     * @return the y coordinate of the framing rectangle &#xA;     * &#x9;&#x9;of the &lt;code>Shape&lt;/code> object's center.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
          <children xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
            <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="2.0"/>
            <multiplicativeOperators xsi:type="operators:Division"/>
          </children>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getFrame">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Rectangle2D.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the framing {@link Rectangle2D}&#xA;     * that defines the overall shape of this object.&#xA;     * @return a &lt;code>Rectangle2D&lt;/code>, specified in&#xA;     * &lt;code>double&lt;/code> coordinates.&#xA;     * @see #setFrame(double, double, double, double)&#xA;     * @see #setFrame(Point2D, Dimension2D)&#xA;     * @see #setFrame(Rectangle2D)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <namespaces>Rectangle2D</namespaces>
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Rectangle2D$Double.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isEmpty">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether the &lt;code>RectangularShape&lt;/code> is empty.&#xA;     * When the &lt;code>RectangularShape&lt;/code> is empty, it encloses no&#xA;     * area.&#xA;     * @return &lt;code>true&lt;/code> if the &lt;code>RectangularShape&lt;/code> is empty; &#xA;     * &#x9;&#x9;&lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setFrame">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="w">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="h">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the location and size of the framing rectangle of this&#xA;     * &lt;code>Shape&lt;/code> to the specified rectangular values.&#xA;     * The framing rectangle is used by the subclasses of &#xA;     * &lt;code>RectangularShape&lt;/code> to define their geometry.&#xA;     * @param x,&amp;nbsp;y the coordinates of the upper-left corner of the&#xA;     * &#x9;&#x9;specified rectangular shape&#xA;     * @param w the width of the specified rectangular shape&#xA;     * @param h the height of the specified rectangular shape&#xA;     * @see #getFrame&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="setFrame">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="loc">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Point2D.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="size">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Dimension2D.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the location and size of the framing rectangle of this &#xA;     * &lt;code>Shape&lt;/code> to the specified {@link Point2D} and &#xA;     * {@link Dimension2D}, respectively.  The framing rectangle is used &#xA;     * by the subclasses of &lt;code>RectangularShape&lt;/code> to define &#xA;     * their geometry.&#xA;     * @param loc the specified &lt;code>Point2D&lt;/code>&#xA;     * @param size the specified &lt;code>Dimension2D&lt;/code>&#xA;     * @see #getFrame&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Dimension2D.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.14/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Dimension2D.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setFrame">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="r">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Rectangle2D.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the framing rectangle of this &lt;code>Shape&lt;/code> to &#xA;     * be the specified &lt;code>Rectangle2D&lt;/code>.  The framing rectangle is&#xA;     * used by the subclasses of &lt;code>RectangularShape&lt;/code> to define&#xA;     * their geometry.&#xA;     * @param r the specified &lt;code>Rectangle2D&lt;/code>&#xA;     * @see #getFrame&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setFrameFromDiagonal">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x1">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y1">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x2">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y2">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the diagonal of the framing rectangle of this &lt;code>Shape&lt;/code>&#xA;     * based on the two specified coordinates.  The framing rectangle is&#xA;     * used by the subclasses of &lt;code>RectangularShape&lt;/code> to define&#xA;     * their geometry.&#xA;     * @param x1,&amp;nbsp;y1 the first specified coordinates&#xA;     * @param x2,&amp;nbsp;y2 the second specified coordinates&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="t">
              <typeReference xsi:type="types:Double"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.0/@statement/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:LocalVariableStatement">
            <variable name="t">
              <typeReference xsi:type="types:Double"/>
              <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
            </variable>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.3"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.3"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@statements.1/@statement/@statements.0/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:RelationExpression">
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.3"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
          <relationOperators xsi:type="operators:LessThan"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.2"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.0"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.3"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.16/@parameters.1"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setFrameFromDiagonal">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="p1">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Point2D.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="p2">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Point2D.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the diagonal of the framing rectangle of this &lt;code>Shape&lt;/code> &#xA;     * based on two specified &lt;code>Point2D&lt;/code> objects.  The framing &#xA;     * rectangle is used by the subclasses of &lt;code>RectangularShape&lt;/code> &#xA;     * to define their geometry.&#xA;     * @param p1,&amp;nbsp;p2 the two specified &lt;code>Point2D&lt;/code> objects&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.16">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.17/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setFrameFromCenter">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="centerX">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="centerY">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cornerX">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="cornerY">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the framing rectangle of this &lt;code>Shape&lt;/code>&#xA;     * based on the specified center point coordinates and corner point&#xA;     * coordinates.  The framing rectangle is used by the subclasses of &#xA;     * &lt;code>RectangularShape&lt;/code> to define their geometry.&#xA;     * @param centerX,&amp;nbsp;centerY the center point coordinates&#xA;     * @param cornerX,&amp;nbsp;cornerY the corner point coordinates&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="halfW">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Math.class.xmi#//@classifiers.0/@members.32"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.2"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Math.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="halfH">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Math.class.xmi#//@classifiers.0/@members.32"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.3"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Math.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.0/@variable"/>
            <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="2.0"/>
            <multiplicativeOperators xsi:type="operators:Multiplication"/>
          </arguments>
          <arguments xsi:type="expressions:MultiplicativeExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.18/@statements.1/@variable"/>
            <children xsi:type="literals:DecimalDoubleLiteral" decimalValue="2.0"/>
            <multiplicativeOperators xsi:type="operators:Multiplication"/>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setFrameFromCenter">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="center">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Point2D.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="corner">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Point2D.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the framing rectangle of this &lt;code>Shape&lt;/code> based on a &#xA;     * specified center &lt;code>Point2D&lt;/code> and corner &#xA;     * &lt;code>Point2D&lt;/code>.  The framing rectangle is used by the subclasses &#xA;     * of &lt;code>RectangularShape&lt;/code> to define their geometry.&#xA;     * @param center the specified center &lt;code>Point2D&lt;/code>&#xA;     * @param corner the specified corner &lt;code>Point2D&lt;/code>&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.19/@parameters.1">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="contains">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="p">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Point2D.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if a specified &lt;code>Point2D&lt;/code> is inside the boundary &#xA;     * of the &lt;code>Shape&lt;/code>.&#xA;     * @param p the specified &lt;code>Point2D&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if the &lt;code>Point2D&lt;/code> is inside the&#xA;     * &#x9;&#x9;&#x9;&lt;code>Shape&lt;/code> object's boundary;&#xA;     *&#x9;&#x9;&#x9; &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall">
          <target xsi:type="members:InterfaceMethod" href="../Shape.class.xmi#//@classifiers.0/@members.2"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Point2D.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="intersects">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="r">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Rectangle2D.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if the interior of the&lt;code>Shape&lt;/code> intersects the &#xA;     * interior of a specified &lt;code>Rectangle2D&lt;/code>.&#xA;     * @param r the specified &lt;code>Rectangle2D&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if the &lt;code>Shape&lt;/code> and the &#xA;     * &#x9;&#x9;specified &lt;code>Rectangle2D&lt;/code> intersect each other; &#xA;     * &#x9;&#x9;&lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall">
          <target xsi:type="members:InterfaceMethod" href="../Shape.class.xmi#//@classifiers.0/@members.4"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.21/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="contains">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="r">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Rectangle2D.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Tests if the interior of the &lt;code>Shape&lt;/code> entirely contains the&#xA;     * specified &lt;code>Rectangle2D&lt;/code>.&#xA;     * @param r the specified &lt;code>Rectangle2D&lt;/code>&#xA;     * @return &lt;code>true&lt;/code> if the &lt;code>Shape&lt;/code> entirely contains&#xA;     * &#x9;&#x9;&#x9;the specified &lt;code>Rectangle2D&lt;/code>;&#xA;     *&#x9;&#x9;       &lt;code>false&lt;/code> otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall">
          <target xsi:type="members:InterfaceMethod" href="../Shape.class.xmi#//@classifiers.0/@members.6"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.22/@parameters.0">
            <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getBounds">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the bounding box of the &lt;code>Shape&lt;/code>.&#xA;     * @return a {@link Rectangle} object that bounds the &#xA;     * &#x9;&#x9;&lt;code>Shape&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="width">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.3"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="height">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </returnValue>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
          <children xsi:type="expressions:RelationExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.1/@variable"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <relationOperators xsi:type="operators:LessThan"/>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="x">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="y">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.2"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="x1">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Math.class.xmi#//@classifiers.0/@members.21"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.3/@variable"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Math.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="y1">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Math.class.xmi#//@classifiers.0/@members.21"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.4/@variable"/>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Math.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="x2">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Math.class.xmi#//@classifiers.0/@members.20"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.3/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.0/@variable"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Math.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="y2">
          <typeReference xsi:type="types:Double"/>
          <initialValue xsi:type="references:IdentifierReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Math.class.xmi#//@classifiers.0/@members.20"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.4/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.1/@variable"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </next>
            <target xsi:type="classifiers:Class" href="../../lang/Math.class.xmi#//@classifiers.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../Rectangle.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.5/@variable"/>
          </arguments>
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.6/@variable"/>
          </arguments>
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.7/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.5/@variable"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </expression>
            </child>
          </arguments>
          <arguments xsi:type="expressions:CastExpression">
            <typeReference xsi:type="types:Int"/>
            <child xsi:type="expressions:NestedExpression">
              <expression xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.8/@variable"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.23/@statements.6/@variable"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </expression>
            </child>
          </arguments>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getPathIterator">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="PathIterator.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="at">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="AffineTransform.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="flatness">
        <typeReference xsi:type="types:Double"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns an iterator object that iterates along the &#xA;     * &lt;code>Shape&lt;/code> object's boundary and provides access to a&#xA;     * flattened view of the outline of the &lt;code>Shape&lt;/code>&#xA;     * object's geometry.&#xA;     * &lt;p>&#xA;     * Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types will&#xA;     * be returned by the iterator.&#xA;     * &lt;p>&#xA;     * The amount of subdivision of the curved segments is controlled&#xA;     * by the &lt;code>flatness&lt;/code> parameter, which specifies the&#xA;     * maximum distance that any point on the unflattened transformed&#xA;     * curve can deviate from the returned flattened path segments.&#xA;     * An optional {@link AffineTransform} can&#xA;     * be specified so that the coordinates returned in the iteration are&#xA;     * transformed accordingly.&#xA;     * @param at an optional &lt;code>AffineTransform&lt;/code> to be applied to the&#xA;     * &#x9;&#x9;coordinates as they are returned in the iteration, &#xA;     *&#x9;&#x9;or &lt;code>null&lt;/code> if untransformed coordinates are desired.&#xA;     * @param flatness the maximum distance that the line segments used to&#xA;     *          approximate the curved segments are allowed to deviate&#xA;     *          from any point on the original curve&#xA;     * @return a &lt;code>PathIterator&lt;/code> object that provides access to &#xA;     * &#x9;&#x9;the &lt;code>Shape&lt;/code> object's flattened geometry.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="FlatteningPathIterator.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <arguments xsi:type="references:MethodCall">
            <target xsi:type="members:InterfaceMethod" href="../Shape.class.xmi#//@classifiers.0/@members.8"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="clone">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new object of the same class and with the same&#xA;     * contents as this object.&#xA;     * @return     a clone of this instance.&#xA;     * @exception  OutOfMemoryError            if there is not enough memory.&#xA;     * @see        java.lang.Cloneable&#xA;     * @since      1.2&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:TryBlock">
        <statements xsi:type="statements:Return">
          <returnValue xsi:type="references:SelfReference">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../../lang/Object.class.xmi#//@classifiers.0/@members.5"/>
            </next>
            <self xsi:type="literals:Super"/>
          </returnValue>
        </statements>
        <catcheBlocks>
          <statements xsi:type="statements:Throw">
            <comments>// this shouldn't happen, since we are Cloneable</comments>
            <throwable xsi:type="instantiations:NewConstructorCall">
              <typeReference xsi:type="types:NamespaceClassifierReference">
                <classifierReferences>
                  <target xsi:type="classifiers:Class" href="../../lang/InternalError.class.xmi#//@classifiers.0"/>
                </classifierReferences>
              </typeReference>
            </throwable>
          </statements>
          <parameter name="e">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../../lang/CloneNotSupportedException.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
          </parameter>
        </catcheBlocks>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * &lt;code>RectangularShape&lt;/code> is the base class for a number of &#xA; * {@link Shape} objects whose geometry is defined by a rectangular frame.&#xA; * This class does not directly specify any specific geometry by&#xA; * itself, but merely provides manipulation methods inherited by&#xA; * a whole category of &lt;code>Shape&lt;/code> objects.&#xA; * The manipulation methods provided by this class can be used to&#xA; * query and modify the rectangular frame, which provides a reference&#xA; * for the subclasses to define their geometry.&#xA; *&#xA; * @version &#x9;1.18, 12/19/03&#xA; * @author&#x9;Jim Graham&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../Shape.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
    <implements xsi:type="types:NamespaceClassifierReference">
      <classifierReferences>
        <target xsi:type="classifiers:Interface" href="../../lang/Cloneable.class.xmi#//@classifiers.0"/>
      </classifierReferences>
    </implements>
  </classifiers>
</containers:CompilationUnit>
