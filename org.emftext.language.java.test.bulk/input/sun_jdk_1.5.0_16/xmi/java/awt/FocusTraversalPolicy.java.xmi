<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="FocusTraversalPolicy.java">
  <comments>/*&#xA; * @(#)FocusTraversalPolicy.java&#x9;1.7 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <classifiers xsi:type="classifiers:Class" name="FocusTraversalPolicy">
    <members xsi:type="members:InterfaceMethod" name="getComponentAfter">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Component.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aContainer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Container.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aComponent">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Component.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the Component that should receive the focus after aComponent.&#xA;     * aContainer must be a focus cycle root of aComponent or a focus traversal&#xA;     * policy provider.&#xA;     *&#xA;     * @param aContainer a focus cycle root of aComponent or focus traversal&#xA;     *        policy provider&#xA;     * @param aComponent a (possibly indirect) child of aContainer, or&#xA;     *        aContainer itself&#xA;     * @return the Component that should receive the focus after aComponent, or&#xA;     *         null if no suitable Component can be found&#xA;     * @throws IllegalArgumentException if aContainer is not a focus cycle&#xA;     *         root of aComponent or a focus traversal policy provider, or if &#xA;     *         either aContainer or aComponent is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getComponentBefore">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Component.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aContainer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Container.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aComponent">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Component.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the Component that should receive the focus before aComponent.&#xA;     * aContainer must be a focus cycle root of aComponent or a focus traversal&#xA;     * policy provider.&#xA;     *&#xA;     * @param aContainer a focus cycle root of aComponent or focus traversal&#xA;     *        policy provider&#xA;     * @param aComponent a (possibly indirect) child of aContainer, or&#xA;     *        aContainer itself&#xA;     * @return the Component that should receive the focus before aComponent,&#xA;     *         or null if no suitable Component can be found&#xA;     * @throws IllegalArgumentException if aContainer is not a focus cycle&#xA;     *         root of aComponent or a focus traversal policy provider, or if &#xA;     *         either aContainer or aComponent is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFirstComponent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Component.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aContainer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Container.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the first Component in the traversal cycle. This method is used&#xA;     * to determine the next Component to focus when traversal wraps in the&#xA;     * forward direction.&#xA;     *&#xA;     * @param aContainer the focus cycle root or focus traversal policy provider&#xA;     *        whose first Component is to be returned&#xA;     * @return the first Component in the traversal cycle of aContainer,&#xA;     *         or null if no suitable Component can be found&#xA;     * @throws IllegalArgumentException if aContainer is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLastComponent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Component.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aContainer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Container.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the last Component in the traversal cycle. This method is used&#xA;     * to determine the next Component to focus when traversal wraps in the&#xA;     * reverse direction.&#xA;     *&#xA;     * @param aContainer the focus cycle root or focus traversal policy&#xA;     *        provider whose last Component is to be returned&#xA;     * @return the last Component in the traversal cycle of aContainer,&#xA;     *         or null if no suitable Component can be found&#xA;     * @throws IllegalArgumentException if aContainer is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDefaultComponent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Component.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="aContainer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Container.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the default Component to focus. This Component will be the first&#xA;     * to receive focus when traversing down into a new focus traversal cycle&#xA;     * rooted at aContainer.&#xA;     *&#xA;     * @param aContainer the focus cycle root or focus traversal policy&#xA;     *        provider whose default Component is to be returned&#xA;     * @return the default Component in the traversal cycle of aContainer, &#xA;     *         or null if no suitable Component can be found&#xA;     * @throws IllegalArgumentException if aContainer is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getInitialComponent">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Component.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="window">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Window.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the Component that should receive the focus when a Window is&#xA;     * made visible for the first time. Once the Window has been made visible&#xA;     * by a call to &lt;code>show()&lt;/code> or &lt;code>setVisible(true)&lt;/code>, the&#xA;     * initial Component will not be used again. Instead, if the Window loses&#xA;     * and subsequently regains focus, or is made invisible or undisplayable&#xA;     * and subsequently made visible and displayable, the Window's most&#xA;     * recently focused Component will become the focus owner. The default&#xA;     * implementation of this method returns the default Component.&#xA;     *&#xA;     * @param window the Window whose initial Component is to be returned&#xA;     * @return the Component that should receive the focus when window is made&#xA;     *         visible for the first time, or null if no suitable Component can&#xA;     *         be found&#xA;     * @see #getDefaultComponent&#xA;     * @see Window#getMostRecentFocusOwner&#xA;     * @throws IllegalArgumentException if window is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="def">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Component.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.4">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.0/@variable"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalAndExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.0/@variable"/>
            <children xsi:type="literals:NullLiteral"/>
          </children>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@parameters.0">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Window.class.xmi#//@classifiers.0/@members.86"/>
            </next>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.5/@statements.0/@variable"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * A FocusTraversalPolicy defines the order in which Components with a&#xA; * particular focus cycle root are traversed. Instances can apply the policy to&#xA; * arbitrary focus cycle roots, allowing themselves to be shared across&#xA; * Containers. They do not need to be reinitialized when the focus cycle roots&#xA; * of a Component hierarchy change.&#xA; * &lt;p>&#xA; * The core responsibility of a FocusTraversalPolicy is to provide algorithms&#xA; * determining the next and previous Components to focus when traversing&#xA; * forward or backward in a UI. Each FocusTraversalPolicy must also provide&#xA; * algorithms for determining the first, last, and default Components in a&#xA; * traversal cycle. First and last Components are used when normal forward and&#xA; * backward traversal, respectively, wraps. The default Component is the first&#xA; * to receive focus when traversing down into a new focus traversal cycle.&#xA; * A FocusTraversalPolicy can optionally provide an algorithm for determining&#xA; * a Window's initial Component. The initial Component is the first to receive&#xA; * focus when a Window is first made visible.&#xA; * &lt;p>&#xA; * FocusTraversalPolicy takes into account &lt;a&#xA; * href=&quot;doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;>focus traversal&#xA; * policy providers&lt;/a>.  When searching for first/last/next/previous Component,&#xA; * if a focus traversal policy provider is encountered, its focus traversal&#xA; * policy is used to perform the search operation.&#xA; * &lt;p>&#xA; * Please see&#xA; * &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html&quot;>&#xA; * How to Use the Focus Subsystem&lt;/a>,&#xA; * a section in &lt;em>The Java Tutorial&lt;/em>, and the&#xA; * &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;>Focus Specification&lt;/a>&#xA; * for more information.&#xA; *&#xA; * @author David Mendenhall&#xA; * @version 1.7, 12/19/03&#xA; *&#xA; * @see Container#setFocusTraversalPolicy&#xA; * @see Container#getFocusTraversalPolicy&#xA; * @see Container#setFocusCycleRoot&#xA; * @see Container#isFocusCycleRoot&#xA; * @see Container#setFocusTraversalPolicyProvider&#xA; * @see Container#isFocusTraversalPolicyProvider&#xA; * @see KeyboardFocusManager#setDefaultFocusTraversalPolicy&#xA; * @see KeyboardFocusManager#getDefaultFocusTraversalPolicy&#xA; * @since 1.4&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
