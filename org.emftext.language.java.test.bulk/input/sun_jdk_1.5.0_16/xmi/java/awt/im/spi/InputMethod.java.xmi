<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../../java.ecore#/7 http://www.emftext.org/java/members ../../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../../java.ecore#/13 http://www.emftext.org/java/types ../../../../java.ecore#/16" name="InputMethod.java">
  <comments>/*&#xA; * @(#)InputMethod.java&#x9;1.29 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <namespaces>im</namespaces>
  <namespaces>spi</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../AWTEvent.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../Rectangle.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <namespaces>Character</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../lang/Character$Subset.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Interface" name="InputMethod">
    <members xsi:type="members:InterfaceMethod" name="setInputMethodContext">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="context">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="InputMethodContext.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the input method context, which is used to dispatch input method&#xA;     * events to the client component and to request information from&#xA;     * the client component.&#xA;     * &lt;p>&#xA;     * This method is called once immediately after instantiating this input&#xA;     * method.&#xA;     *&#xA;     * @param context the input method context for this input method&#xA;     * @exception NullPointerException if &lt;code>context&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setLocale">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="locale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Attempts to set the input locale. If the input method supports the&#xA;     * desired locale, it changes its behavior to support input for the locale&#xA;     * and returns true.&#xA;     * Otherwise, it returns false and does not change its behavior.&#xA;     * &lt;p>&#xA;     * This method is called&#xA;     * &lt;ul>&#xA;     * &lt;li>by {@link java.awt.im.InputContext#selectInputMethod InputContext.selectInputMethod},&#xA;     * &lt;li>when switching to this input method through the user interface if the user&#xA;     *     specified a locale or if the previously selected input method's&#xA;     *     {@link java.awt.im.spi.InputMethod#getLocale getLocale} method&#xA;     *     returns a non-null value.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param locale locale to input&#xA;     * @return whether the specified locale is supported&#xA;     * @exception NullPointerException if &lt;code>locale&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getLocale">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../util/Locale.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current input locale. Might return null in exceptional cases.&#xA;     * &lt;p>&#xA;     * This method is called&#xA;     * &lt;ul>&#xA;     * &lt;li>by {@link java.awt.im.InputContext#getLocale InputContext.getLocale} and&#xA;     * &lt;li>when switching from this input method to a different one through the&#xA;     *     user interface.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @return the current input locale, or null&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setCharacterSubsets">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="subsets">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../../lang/Character$Subset.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the subsets of the Unicode character set that this input method&#xA;     * is allowed to input. Null may be passed in to indicate that all&#xA;     * characters are allowed.&#xA;     * &lt;p>&#xA;     * This method is called&#xA;     * &lt;ul>&#xA;     * &lt;li>immediately after instantiating this input method,&#xA;     * &lt;li>when switching to this input method from a different one, and&#xA;     * &lt;li>by {@link java.awt.im.InputContext#setCharacterSubsets InputContext.setCharacterSubsets}.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param subsets the subsets of the Unicode character set from which&#xA;     * characters may be input&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setCompositionEnabled">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="enable">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enables or disables this input method for composition,&#xA;     * depending on the value of the parameter &lt;code>enable&lt;/code>.&#xA;     * &lt;p>&#xA;     * An input method that is enabled for composition interprets incoming&#xA;     * events for both composition and control purposes, while a&#xA;     * disabled input method does not interpret events for composition.&#xA;     * Note however that events are passed on to the input method regardless&#xA;     * whether it is enabled or not, and that an input method that is disabled&#xA;     * for composition may still interpret events for control purposes,&#xA;     * including to enable or disable itself for composition.&#xA;     * &lt;p>&#xA;     * For input methods provided by host operating systems, it is not always possible to &#xA;     * determine whether this operation is supported. For example, an input method may enable&#xA;     * composition only for some locales, and do nothing for other locales. For such input &#xA;     * methods, it is possible that this method does not throw &#xA;     * {@link java.lang.UnsupportedOperationException UnsupportedOperationException},&#xA;     * but also does not affect whether composition is enabled.&#xA;     * &lt;p>&#xA;     * This method is called&#xA;     * &lt;ul>&#xA;     * &lt;li>by {@link java.awt.im.InputContext#setCompositionEnabled InputContext.setCompositionEnabled},&#xA;     * &lt;li>when switching to this input method from a different one using the&#xA;     *     user interface or&#xA;     *     {@link java.awt.im.InputContext#selectInputMethod InputContext.selectInputMethod},&#xA;     *     if the previously selected input method's&#xA;     *     {@link java.awt.im.spi.InputMethod#isCompositionEnabled isCompositionEnabled}&#xA;     *     method returns without throwing an exception.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @param enable whether to enable the input method for composition&#xA;     * @throws UnsupportedOperationException if this input method does not&#xA;     * support the enabling/disabling operation&#xA;     * @see #isCompositionEnabled&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="isCompositionEnabled">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether this input method is enabled.&#xA;     * An input method that is enabled for composition interprets incoming&#xA;     * events for both composition and control purposes, while a&#xA;     * disabled input method does not interpret events for composition.&#xA;     * &lt;p>&#xA;     * This method is called&#xA;     * &lt;ul>&#xA;     * &lt;li>by {@link java.awt.im.InputContext#isCompositionEnabled InputContext.isCompositionEnabled} and&#xA;     * &lt;li>when switching from this input method to a different one using the&#xA;     *     user interface or&#xA;     *     {@link java.awt.im.InputContext#selectInputMethod InputContext.selectInputMethod}.&#xA;     * &lt;/ul>&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if this input method is enabled for&#xA;     * composition; &lt;code>false&lt;/code> otherwise.&#xA;     * @throws UnsupportedOperationException if this input method does not&#xA;     * support checking whether it is enabled for composition&#xA;     * @see #setCompositionEnabled&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="reconvert">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Starts the reconversion operation. The input method obtains the&#xA;     * text to be reconverted from the current client component using the&#xA;     * {@link java.awt.im.InputMethodRequests#getSelectedText InputMethodRequests.getSelectedText}&#xA;     * method. It can use other &lt;code>InputMethodRequests&lt;/code>&#xA;     * methods to request additional information required for the&#xA;     * reconversion operation. The composed and committed text&#xA;     * produced by the operation is sent to the client component as a&#xA;     * sequence of &lt;code>InputMethodEvent&lt;/code>s. If the given text&#xA;     * cannot be reconverted, the same text should be sent to the&#xA;     * client component as committed text.&#xA;     * &lt;p>&#xA;     * This method is called by&#xA;     * {@link java.awt.im.InputContext#reconvert() InputContext.reconvert}.&#xA;     *&#xA;     * @throws UnsupportedOperationException if the input method does not&#xA;     * support the reconversion operation.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="dispatchEvent">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="event">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../AWTEvent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Dispatches the event to the input method. If input method support is&#xA;     * enabled for the focussed component, incoming events of certain types&#xA;     * are dispatched to the current input method for this component before&#xA;     * they are dispatched to the component's methods or event listeners.&#xA;     * The input method decides whether it needs to handle the event. If it&#xA;     * does, it also calls the event's &lt;code>consume&lt;/code> method; this&#xA;     * causes the event to not get dispatched to the component's event&#xA;     * processing methods or event listeners.&#xA;     * &lt;p>&#xA;     * Events are dispatched if they are instances of InputEvent or its&#xA;     * subclasses.&#xA;     * This includes instances of the AWT classes KeyEvent and MouseEvent.&#xA;     * &lt;p>&#xA;     * This method is called by {@link java.awt.im.InputContext#dispatchEvent InputContext.dispatchEvent}.&#xA;     *&#xA;     * @param event the event being dispatched to the input method&#xA;     * @exception NullPointerException if &lt;code>event&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="notifyClientWindowChange">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bounds">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../Rectangle.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Notifies this input method of changes in the client window&#xA;     * location or state. This method is called while this input&#xA;     * method is the current input method of its input context and&#xA;     * notifications for it are enabled (see {@link&#xA;     * InputMethodContext#enableClientWindowNotification&#xA;     * InputMethodContext.enableClientWindowNotification}). Calls&#xA;     * to this method are temporarily suspended if the input context's&#xA;     * {@link java.awt.im.InputContext#removeNotify removeNotify}&#xA;     * method is called, and resume when the input method is activated&#xA;     * for a new client component. It is called in the following&#xA;     * situations:&#xA;     * &lt;ul>&#xA;     * &lt;li>&#xA;     * when the window containing the current client component changes&#xA;     * in location, size, visibility, iconification state, or when the&#xA;     * window is closed.&lt;/li>&#xA;     * &lt;li>&#xA;     * from &lt;code> enableClientWindowNotification(inputMethod,&#xA;     * true)&lt;/code> if the current client component exists,&lt;/li>&#xA;     * &lt;li>&#xA;     * when activating the input method for the first time after it&#xA;     * called&#xA;     * &lt;code>enableClientWindowNotification(inputMethod,&#xA;     * true)&lt;/code> if during the call no current client component was&#xA;     * available,&lt;/li>&#xA;     * &lt;li>&#xA;     * when activating the input method for a new client component&#xA;     * after the input context's removeNotify method has been&#xA;     * called.&lt;/li>&#xA;     * &lt;/ul>&#xA;     * @param bounds client window's {@link&#xA;     * java.awt.Component#getBounds bounds} on the screen; or null if&#xA;     * the client window is iconified or invisible&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="activate">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Activates the input method for immediate input processing.&#xA;     * &lt;p>&#xA;     * If an input method provides its own windows, it should make sure&#xA;     * at this point that all necessary windows are open and visible.&#xA;     * &lt;p>&#xA;     * This method is called&#xA;     * &lt;ul>&#xA;     * &lt;li>by {@link java.awt.im.InputContext#dispatchEvent InputContext.dispatchEvent}&#xA;     *     when a client component receives a FOCUS_GAINED event,&#xA;     * &lt;li>when switching to this input method from a different one using the&#xA;     *     user interface or&#xA;     *     {@link java.awt.im.InputContext#selectInputMethod InputContext.selectInputMethod}.&#xA;     * &lt;/ul>&#xA;     * The method is only called when the input method is inactive.&#xA;     * A newly instantiated input method is assumed to be inactive.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="deactivate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="isTemporary">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Deactivates the input method.&#xA;     * The isTemporary argument has the same meaning as in&#xA;     * {@link java.awt.event.FocusEvent#isTemporary FocusEvent.isTemporary}.&#xA;     * &lt;p>&#xA;     * If an input method provides its own windows, only windows that relate&#xA;     * to the current composition (such as a lookup choice window) should be&#xA;     * closed at this point.&#xA;     * It is possible that the input method will be immediately activated again&#xA;     * for a different client component, and closing and reopening more&#xA;     * persistent windows (such as a control panel) would create unnecessary&#xA;     * screen flicker.&#xA;     * Before an instance of a different input method class is activated,&#xA;     * {@link #hideWindows} is called on the current input method.&#xA;     * &lt;p>&#xA;     * This method is called&#xA;     * &lt;ul>&#xA;     * &lt;li>by {@link java.awt.im.InputContext#dispatchEvent InputContext.dispatchEvent}&#xA;     *     when a client component receives a FOCUS_LOST event,&#xA;     * &lt;li>when switching from this input method to a different one using the&#xA;     *     user interface or&#xA;     *     {@link java.awt.im.InputContext#selectInputMethod InputContext.selectInputMethod},&#xA;     * &lt;li>before {@link #removeNotify removeNotify} if the current client component is&#xA;     *     removed.&#xA;     * &lt;/ul>&#xA;     * The method is only called when the input method is active.&#xA;     *&#xA;     * @param isTemporary whether the focus change is temporary&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="hideWindows">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Closes or hides all windows opened by this input method instance or&#xA;     * its class.&#xA;     * &lt;p>&#xA;     * This method is called&#xA;     * &lt;ul>&#xA;     * &lt;li>before calling {@link #activate activate} on an instance of a different input&#xA;     *     method class,&#xA;     * &lt;li>before calling {@link #dispose dispose} on this input method.&#xA;     * &lt;/ul>&#xA;     * The method is only called when the input method is inactive.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="removeNotify">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Notifies the input method that a client component has been&#xA;     * removed from its containment hierarchy, or that input method&#xA;     * support has been disabled for the component.&#xA;     * &lt;p>&#xA;     * This method is called by {@link java.awt.im.InputContext#removeNotify InputContext.removeNotify}.&#xA;     * &lt;p>&#xA;     * The method is only called when the input method is inactive.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="endComposition">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Ends any input composition that may currently be going on in this&#xA;     * context. Depending on the platform and possibly user preferences,&#xA;     * this may commit or delete uncommitted text. Any changes to the text&#xA;     * are communicated to the active component using an input method event.&#xA;     *&#xA;     * &lt;p>&#xA;     * A text editing component may call this in a variety of situations,&#xA;     * for example, when the user moves the insertion point within the text&#xA;     * (but outside the composed text), or when the component's text is&#xA;     * saved to a file or copied to the clipboard.&#xA;     * &lt;p>&#xA;     * This method is called&#xA;     * &lt;ul>&#xA;     * &lt;li>by {@link java.awt.im.InputContext#endComposition InputContext.endComposition},&#xA;     * &lt;li>by {@link java.awt.im.InputContext#dispatchEvent InputContext.dispatchEvent}&#xA;     *     when switching to a different client component&#xA;     * &lt;li>when switching from this input method to a different one using the&#xA;     *     user interface or&#xA;     *     {@link java.awt.im.InputContext#selectInputMethod InputContext.selectInputMethod}.&#xA;     * &lt;/ul>&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="dispose">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Disposes of the input method and releases the resources used by it.&#xA;     * In particular, the input method should dispose windows and close files that are no&#xA;     * longer needed.&#xA;     * &lt;p>&#xA;     * This method is called by {@link java.awt.im.InputContext#dispose InputContext.dispose}.&#xA;     * &lt;p>&#xA;     * The method is only called when the input method is inactive.&#xA;     * No method of this interface is called on this instance after dispose.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getControlObject">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a control object from this input method, or null. A&#xA;     * control object provides methods that control the behavior of the&#xA;     * input method or obtain information from the input method. The type&#xA;     * of the object is an input method specific class. Clients have to&#xA;     * compare the result against known input method control object&#xA;     * classes and cast to the appropriate class to invoke the methods&#xA;     * provided.&#xA;     * &lt;p>&#xA;     * This method is called by&#xA;     * {@link java.awt.im.InputContext#getInputMethodControlObject InputContext.getInputMethodControlObject}.&#xA;     *&#xA;     * @return a control object from this input method, or null&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Defines the interface for an input method that supports complex text input.&#xA; * Input methods traditionally support text input for languages that have&#xA; * more characters than can be represented on a standard-size keyboard,&#xA; * such as Chinese, Japanese, and Korean. However, they may also be used to&#xA; * support phonetic text input for English or character reordering for Thai.&#xA; * &lt;p>&#xA; * Subclasses of InputMethod can be loaded by the input method framework; they&#xA; * can then be selected either through the API&#xA; * ({@link java.awt.im.InputContext#selectInputMethod InputContext.selectInputMethod})&#xA; * or the user interface (the input method selection menu).&#xA; *&#xA; * @since 1.3&#xA; *&#xA; * @version &#x9;1.29, 12/19/03&#xA; * @author JavaSoft International&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
