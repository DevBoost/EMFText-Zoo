<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../../java.ecore#/2 http://www.emftext.org/java/containers ../../../java.ecore#/4 http://www.emftext.org/java/imports ../../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../../java.ecore#/8 http://www.emftext.org/java/literals ../../../java.ecore#/9 http://www.emftext.org/java/members ../../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../../java.ecore#/11 http://www.emftext.org/java/parameters ../../../java.ecore#/13 http://www.emftext.org/java/statements ../../../java.ecore#/15 http://www.emftext.org/java/types ../../../java.ecore#/16" name="InputContext.java">
  <comments>/*&#xA; * @(#)InputContext.java&#x9;1.34 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <namespaces>im</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../Component.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../util/Locale.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <classifier xsi:type="classifiers:Class" href="../AWTEvent.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
    <namespaces>Character</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../lang/Character$Subset.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>sun</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>im</namespaces>
    <classifier xsi:type="classifiers:Class" href="../../../sun/awt/im/InputMethodContext.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="InputContext">
    <members xsi:type="members:Constructor" name="InputContext">
      <comments>// real implementation is in sun.awt.im.InputContext</comments>
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Constructs an InputContext.&#xA;     * This method is protected so clients cannot instantiate&#xA;     * InputContext directly. Input contexts are obtained by&#xA;     * calling {@link #getInstance}.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getInstance">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a new InputContext instance.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="instantiations:NewConstructorCall">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <namespaces>sun</namespaces>
            <namespaces>awt</namespaces>
            <namespaces>im</namespaces>
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="../../../sun/awt/im/InputMethodContext.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="selectInputMethod">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="locale">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../util/Locale.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Attempts to select an input method or keyboard layout that&#xA;     * supports the given locale, and returns a value indicating whether such&#xA;     * an input method or keyboard layout has been successfully selected. The&#xA;     * following steps are taken until an input method has been selected:&#xA;     *&#xA;     * &lt;p>&#xA;     * &lt;ul>&#xA;     * &lt;li>&#xA;     * If the currently selected input method or keyboard layout supports the&#xA;     * requested locale, it remains selected.&lt;/li>&#xA;     *&#xA;     * &lt;li>&#xA;     * If there is no input method or keyboard layout available that supports&#xA;     * the requested locale, the current input method or keyboard layout remains&#xA;     * selected.&lt;/li>&#xA;     *&#xA;     * &lt;li>&#xA;     * If the user has previously selected an input method or keyboard layout&#xA;     * for the requested locale from the user interface, then the most recently&#xA;     * selected such input method or keyboard layout is reselected.&lt;/li>&#xA;     *&#xA;     * &lt;li>&#xA;     * Otherwise, an input method or keyboard layout that supports the requested&#xA;     * locale is selected in an implementation dependent way.&lt;/li>&#xA;     *&#xA;     * &lt;p>&#xA;     * &lt;/ul>&#xA;     * Before switching away from an input method, any currently uncommitted text&#xA;     * is committed. If no input method or keyboard layout supporting the requested&#xA;     * locale is available, then false is returned.&#xA;     *&#xA;     * &lt;p>&#xA;     * Not all host operating systems provide API to determine the locale of&#xA;     * the currently selected native input method or keyboard layout, and to&#xA;     * select a native input method or keyboard layout by locale.&#xA;     * For host operating systems that don't provide such API,&#xA;     * &lt;code>selectInputMethod&lt;/code> assumes that native input methods or&#xA;     * keyboard layouts provided by the host operating system support only the&#xA;     * system's default locale.&#xA;     *&#xA;     * &lt;p>&#xA;     * A text editing component may call this method, for example, when&#xA;     * the user changes the insertion point, so that the user can&#xA;     * immediately continue typing in the language of the surrounding text.&#xA;     *&#xA;     * @param locale The desired new locale.&#xA;     * @return true if the input method or keyboard layout that's active after&#xA;     *         this call supports the desired locale.&#xA;     * @exception NullPointerException if &lt;code>locale&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// real implementation is in sun.awt.im.InputContext</comments>
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getLocale">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../util/Locale.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the current locale of the current input method or keyboard&#xA;     * layout.&#xA;     * Returns null if the input context does not have a current input method&#xA;     * or keyboard layout or if the current input method's&#xA;     * {@link java.awt.im.spi.InputMethod#getLocale()} method returns null.&#xA;     *&#xA;     * &lt;p>&#xA;     * Not all host operating systems provide API to determine the locale of&#xA;     * the currently selected native input method or keyboard layout.&#xA;     * For host operating systems that don't provide such API,&#xA;     * &lt;code>getLocale&lt;/code> assumes that the current locale of all native&#xA;     * input methods or keyboard layouts provided by the host operating system&#xA;     * is the system's default locale.&#xA;     *&#xA;     * @return the current locale of the current input method or keyboard layout&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// real implementation is in sun.awt.im.InputContext</comments>
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="setCharacterSubsets">
      <comments>// real implementation is in sun.awt.im.InputContext</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="subsets">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../../lang/Character$Subset.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
        <arrayDimensionsBefore/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the subsets of the Unicode character set that input methods of this input&#xA;     * context should be allowed to input. Null may be passed in to&#xA;     * indicate that all characters are allowed. The initial value&#xA;     * is null. The setting applies to the current input method as well&#xA;     * as input methods selected after this call is made. However,&#xA;     * applications cannot rely on this call having the desired effect,&#xA;     * since this setting cannot be passed on to all host input methods -&#xA;     * applications still need to apply their own character validation.&#xA;     * If no input methods are available, then this method has no effect.&#xA;     *&#xA;     * @param subsets The subsets of the Unicode character set from which characters may be input&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="setCompositionEnabled">
      <comments>// real implementation is in sun.awt.im.InputContext</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="enable">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Enables or disables the current input method for composition,&#xA;     * depending on the value of the parameter &lt;code>enable&lt;/code>.&#xA;     * &lt;p>&#xA;     * An input method that is enabled for composition interprets incoming&#xA;     * events for both composition and control purposes, while a&#xA;     * disabled input method does not interpret events for composition.&#xA;     * Note however that events are passed on to the input method regardless&#xA;     * whether it is enabled or not, and that an input method that is disabled&#xA;     * for composition may still interpret events for control purposes,&#xA;     * including to enable or disable itself for composition.&#xA;     * &lt;p>&#xA;     * For input methods provided by host operating systems, it is not always possible to &#xA;     * determine whether this operation is supported. For example, an input method may enable&#xA;     * composition only for some locales, and do nothing for other locales. For such input &#xA;     * methods, it is possible that this method does not throw &#xA;     * {@link java.lang.UnsupportedOperationException UnsupportedOperationException},&#xA;     * but also does not affect whether composition is enabled.&#xA;     *&#xA;     * @param enable whether to enable the current input method for composition&#xA;     * @throws UnsupportedOperationException if there is no current input&#xA;     * method available or the current input method does not support&#xA;     * the enabling/disabling operation&#xA;     * @see #isCompositionEnabled&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="isCompositionEnabled">
      <typeReference xsi:type="types:Boolean"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Determines whether the current input method is enabled for composition.&#xA;     * An input method that is enabled for composition interprets incoming&#xA;     * events for both composition and control purposes, while a&#xA;     * disabled input method does not interpret events for composition.&#xA;     *&#xA;     * @return &lt;code>true&lt;/code> if the current input method is enabled for&#xA;     * composition; &lt;code>false&lt;/code> otherwise&#xA;     * @throws UnsupportedOperationException if there is no current input&#xA;     * method available or the current input method does not support&#xA;     * checking whether it is enabled for composition&#xA;     * @see #setCompositionEnabled&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// real implementation is in sun.awt.im.InputContext</comments>
        <returnValue xsi:type="literals:BooleanLiteral"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="reconvert">
      <comments>// real implementation is in sun.awt.im.InputContext</comments>
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Asks the current input method to reconvert text from the&#xA;     * current client component. The input method obtains the text to&#xA;     * be reconverted from the client component using the&#xA;     * {@link InputMethodRequests#getSelectedText InputMethodRequests.getSelectedText}&#xA;     * method. The other &lt;code>InputMethodRequests&lt;/code> methods&#xA;     * must be prepared to deal with further information requests by&#xA;     * the input method. The composed and/or committed text will be&#xA;     * sent to the client component as a sequence of&#xA;     * &lt;code>InputMethodEvent&lt;/code>s. If the input method cannot&#xA;     * reconvert the given text, the text is returned as committed&#xA;     * text in an &lt;code>InputMethodEvent&lt;/code>.&#xA;     *&#xA;     * @throws UnsupportedOperationException if there is no current input&#xA;     * method available or the current input method does not support&#xA;     * the reconversion operation.&#xA;     *&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="dispatchEvent">
      <comments>// real implementation is in sun.awt.im.InputContext</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="event">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../AWTEvent.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Dispatches an event to the active input method. Called by AWT.&#xA;     * If no input method is available, then the event will never be consumed.&#xA;     *&#xA;     * @param event The event&#xA;     * @exception NullPointerException if &lt;code>event&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="removeNotify">
      <comments>// real implementation is in sun.awt.im.InputContext</comments>
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="client">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../Component.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Notifies the input context that a client component has been&#xA;     * removed from its containment hierarchy, or that input method&#xA;     * support has been disabled for the component. This method is&#xA;     * usually called from the client component's&#xA;     * {@link java.awt.Component#removeNotify() Component.removeNotify}&#xA;     * method. Potentially pending input from input methods&#xA;     * for this component is discarded.&#xA;     * If no input methods are available, then this method has no effect.&#xA;     *&#xA;     * @param client Client component&#xA;     * @exception NullPointerException if &lt;code>client&lt;/code> is null&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="endComposition">
      <comments>// real implementation is in sun.awt.im.InputContext</comments>
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Ends any input composition that may currently be going on in this&#xA;     * context. Depending on the platform and possibly user preferences,&#xA;     * this may commit or delete uncommitted text. Any changes to the text&#xA;     * are communicated to the active component using an input method event.&#xA;     * If no input methods are available, then this method has no effect.&#xA;     *&#xA;     * &lt;p>&#xA;     * A text editing component may call this in a variety of situations,&#xA;     * for example, when the user moves the insertion point within the text&#xA;     * (but outside the composed text), or when the component's text is&#xA;     * saved to a file or copied to the clipboard.&#xA;     *&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="dispose">
      <comments>// real implementation is in sun.awt.im.InputContext</comments>
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Disposes of the input context and release the resources used by it.&#xA;     * Called by AWT for the default input context of each Window.&#xA;     * If no input methods are available, then this method&#xA;     * has no effect.&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:ClassMethod" name="getInputMethodControlObject">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../../lang/Object.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a control object from the current input method, or null. A&#xA;     * control object provides methods that control the behavior of the&#xA;     * input method or obtain information from the input method. The type&#xA;     * of the object is an input method specific class. Clients have to&#xA;     * compare the result against known input method control object&#xA;     * classes and cast to the appropriate class to invoke the methods&#xA;     * provided.&#xA;     * &lt;p>&#xA;     * If no input methods are available or the current input method does&#xA;     * not provide an input method control object, then null is returned.&#xA;     *&#xA;     * @return A control object from the current input method, or null.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// real implementation is in sun.awt.im.InputContext</comments>
        <returnValue xsi:type="literals:NullLiteral"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * Provides methods to control text input facilities such as input&#xA; * methods and keyboard layouts.&#xA; * Two methods handle both input methods and keyboard layouts: selectInputMethod&#xA; * lets a client component select an input method or keyboard layout by locale,&#xA; * getLocale lets a client component obtain the locale of the current input method&#xA; * or keyboard layout.&#xA; * The other methods more specifically support interaction with input methods:&#xA; * They let client components control the behavior of input methods, and&#xA; * dispatch events from the client component to the input method.&#xA; *&#xA; * &lt;p>&#xA; * By default, one InputContext instance is created per Window instance,&#xA; * and this input context is shared by all components within the window's&#xA; * container hierarchy. However, this means that only one text input&#xA; * operation is possible at any one time within a window, and that the&#xA; * text needs to be committed when moving the focus from one text component&#xA; * to another. If this is not desired, text components can create their&#xA; * own input context instances.&#xA; *&#xA; * &lt;p>&#xA; * The Java 2 platform supports input methods that have been developed in the Java&#xA; * programming language, using the interfaces in the {@link java.awt.im.spi} package,&#xA; * and installed into a Java 2 runtime environment as extensions. Implementations&#xA; * may also support using the native input methods of the platforms they run on;&#xA; * however, not all platforms and locales provide input methods. Keyboard layouts&#xA; * are provided by the host platform.&#xA; *&#xA; * &lt;p>&#xA; * Input methods are &lt;em>unavailable&lt;/em> if (a) no input method written&#xA; * in the Java programming language has been installed and (b) the Java 2 implementation&#xA; * or the underlying platform does not support native input methods. In this case,&#xA; * input contexts can still be created and used; their behavior is specified with&#xA; * the individual methods below.&#xA; *&#xA; * @see java.awt.Component#getInputContext&#xA; * @see java.awt.Component#enableInputMethods&#xA; * @version &#x9;1.34, 12/19/03&#xA; * @author JavaSoft Asia/Pacific&#xA; * @since 1.2&#xA; */</comments>
    </annotationsAndModifiers>
  </classifiers>
</containers:CompilationUnit>
