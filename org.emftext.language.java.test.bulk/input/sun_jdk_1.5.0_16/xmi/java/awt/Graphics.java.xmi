<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:annotations="http://www.emftext.org/java/annotations" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/annotations ../../java.ecore#/0 http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="Graphics.java">
  <comments>/*&#xA; * @(#)Graphics.java&#x9;1.69 04/05/18&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>io</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>lang</namespaces>
  </imports>
  <imports xsi:type="imports:PackageImport">
    <namespaces>java</namespaces>
    <namespaces>util</namespaces>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Interface" href="image/ImageObserver.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>text</namespaces>
    <classifier xsi:type="classifiers:Interface" href="../text/AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="Graphics">
    <members xsi:type="members:Constructor" name="Graphics">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * Constructs a new &lt;code>Graphics&lt;/code> object.  &#xA;     * This constructor is the default contructor for a graphics &#xA;     * context. &#xA;     * &lt;p>&#xA;     * Since &lt;code>Graphics&lt;/code> is an abstract class, applications &#xA;     * cannot call this constructor directly. Graphics contexts are &#xA;     * obtained from other graphics contexts or are created by calling &#xA;     * &lt;code>getGraphics&lt;/code> on a component. &#xA;     * @see        java.awt.Graphics#create()&#xA;     * @see        java.awt.Component#getGraphics&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="create">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new &lt;code>Graphics&lt;/code> object that is &#xA;     * a copy of this &lt;code>Graphics&lt;/code> object.&#xA;     * @return     a new graphics context that is a copy of &#xA;     *                       this graphics context.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="create">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences target="//@classifiers.0"/>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Creates a new &lt;code>Graphics&lt;/code> object based on this &#xA;     * &lt;code>Graphics&lt;/code> object, but with a new translation and clip area.&#xA;     * The new &lt;code>Graphics&lt;/code> object has its origin &#xA;     * translated to the specified point (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>). &#xA;     * Its clip area is determined by the intersection of the original&#xA;     * clip area with the specified rectangle.  The arguments are all&#xA;     * interpreted in the coordinate system of the original &#xA;     * &lt;code>Graphics&lt;/code> object. The new graphics context is &#xA;     * identical to the original, except in two respects: &#xA;     * &lt;p>&#xA;     * &lt;ul>&#xA;     * &lt;li>&#xA;     * The new graphics context is translated by (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>).  &#xA;     * That is to say, the point (&lt;code>0&lt;/code>,&amp;nbsp;&lt;code>0&lt;/code>) in the &#xA;     * new graphics context is the same as (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in &#xA;     * the original graphics context. &#xA;     * &lt;li>&#xA;     * The new graphics context has an additional clipping rectangle, in &#xA;     * addition to whatever (translated) clipping rectangle it inherited &#xA;     * from the original graphics context. The origin of the new clipping &#xA;     * rectangle is at (&lt;code>0&lt;/code>,&amp;nbsp;&lt;code>0&lt;/code>), and its size  &#xA;     * is specified by the &lt;code>width&lt;/code> and &lt;code>height&lt;/code>&#xA;     * arguments.&#xA;     * &lt;/ul>&#xA;     * &lt;p>&#xA;     * @param      x   the &lt;i>x&lt;/i> coordinate.&#xA;     * @param      y   the &lt;i>y&lt;/i> coordinate.&#xA;     * @param      width   the width of the clipping rectangle.&#xA;     * @param      height   the height of the clipping rectangle.&#xA;     * @return     a new graphics context.&#xA;     * @see        java.awt.Graphics#translate&#xA;     * @see        java.awt.Graphics#clipRect&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="g">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences target="//@classifiers.0"/>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.1"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Return">
          <returnValue xsi:type="literals:NullLiteral"/>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.3">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.1"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable">
          <next xsi:type="references:MethodCall" target="//@classifiers.0/@members.13">
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@parameters.3"/>
          </next>
        </expression>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.2/@statements.0/@variable"/>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="translate">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Translates the origin of the graphics context to the point&#xA;     * (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in the current coordinate system. &#xA;     * Modifies this graphics context so that its new origin corresponds &#xA;     * to the point (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in this graphics context's &#xA;     * original coordinate system.  All coordinates used in subsequent &#xA;     * rendering operations on this graphics context will be relative &#xA;     * to this new origin.&#xA;     * @param  x   the &lt;i>x&lt;/i> coordinate.&#xA;     * @param  y   the &lt;i>y&lt;/i> coordinate.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getColor">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets this graphics context's current color.&#xA;     * @return    this graphics context's current color.&#xA;     * @see       java.awt.Color&#xA;     * @see       java.awt.Graphics#setColor(Color)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setColor">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets this graphics context's current color to the specified &#xA;     * color. All subsequent graphics operations using this graphics &#xA;     * context use this specified color. &#xA;     * @param     c   the new rendering color.&#xA;     * @see       java.awt.Color&#xA;     * @see       java.awt.Graphics#getColor&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setPaintMode">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the paint mode of this graphics context to overwrite the &#xA;     * destination with this graphics context's current color. &#xA;     * This sets the logical pixel operation function to the paint or&#xA;     * overwrite mode.  All subsequent rendering operations will&#xA;     * overwrite the destination with the current color. &#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setXORMode">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="c1">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the paint mode of this graphics context to alternate between &#xA;     * this graphics context's current color and the new specified color. &#xA;     * This specifies that logical pixel operations are performed in the &#xA;     * XOR mode, which alternates pixels between the current color and &#xA;     * a specified XOR color. &#xA;     * &lt;p>&#xA;     * When drawing operations are performed, pixels which are the &#xA;     * current color are changed to the specified color, and vice versa. &#xA;     * &lt;p>&#xA;     * Pixels that are of colors other than those two colors are changed &#xA;     * in an unpredictable but reversible manner; if the same figure is &#xA;     * drawn twice, then all pixels are restored to their original values. &#xA;     * @param     c1 the XOR alternation color&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFont">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Font.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the current font.&#xA;     * @return    this graphics context's current font.&#xA;     * @see       java.awt.Font&#xA;     * @see       java.awt.Graphics#setFont(Font)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setFont">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="font">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Font.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets this graphics context's font to the specified font. &#xA;     * All subsequent text operations using this graphics context &#xA;     * use this font. &#xA;     * @param  font   the font.&#xA;     * @see     java.awt.Graphics#getFont&#xA;     * @see     java.awt.Graphics#drawString(java.lang.String, int, int)&#xA;     * @see     java.awt.Graphics#drawBytes(byte[], int, int, int, int)&#xA;     * @see     java.awt.Graphics#drawChars(char[], int, int, int, int)&#xA;    */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="getFontMetrics">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FontMetrics.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the font metrics of the current font.&#xA;     * @return    the font metrics of this graphics &#xA;     *                    context's current font.&#xA;     * @see       java.awt.Graphics#getFont&#xA;     * @see       java.awt.FontMetrics&#xA;     * @see       java.awt.Graphics#getFontMetrics(Font)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.11">
          <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.8"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getFontMetrics">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="FontMetrics.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="f">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Font.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the font metrics for the specified font.&#xA;     * @return    the font metrics for the specified font.&#xA;     * @param     f the specified font&#xA;     * @see       java.awt.Graphics#getFont&#xA;     * @see       java.awt.FontMetrics&#xA;     * @see       java.awt.Graphics#getFontMetrics()&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getClipBounds">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Rectangle.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the bounding rectangle of the current clipping area.&#xA;     * This method refers to the user clip, which is independent of the&#xA;     * clipping associated with device bounds and window visibility.  &#xA;     * If no clip has previously been set, or if the clip has been &#xA;     * cleared using &lt;code>setClip(null)&lt;/code>, this method returns&#xA;     * &lt;code>null&lt;/code>.&#xA;     * The coordinates in the rectangle are relative to the coordinate&#xA;     * system origin of this graphics context.&#xA;     * @return      the bounding rectangle of the current clipping area,&#xA;     *              or &lt;code>null&lt;/code> if no clip is set.&#xA;     * @see         java.awt.Graphics#getClip&#xA;     * @see         java.awt.Graphics#clipRect&#xA;     * @see         java.awt.Graphics#setClip(int, int, int, int)&#xA;     * @see         java.awt.Graphics#setClip(Shape)&#xA;     * @since       JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clipRect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Intersects the current clip with the specified rectangle.&#xA;     * The resulting clipping area is the intersection of the current&#xA;     * clipping area and the specified rectangle.  If there is no &#xA;     * current clipping area, either because the clip has never been &#xA;     * set, or the clip has been cleared using &lt;code>setClip(null)&lt;/code>, &#xA;     * the specified rectangle becomes the new clip.&#xA;     * This method sets the user clip, which is independent of the&#xA;     * clipping associated with device bounds and window visibility.  &#xA;     * This method can only be used to make the current clip smaller.&#xA;     * To set the current clip larger, use any of the setClip methods.&#xA;     * Rendering operations have no effect outside of the clipping area.&#xA;     * @param x the x coordinate of the rectangle to intersect the clip with&#xA;     * @param y the y coordinate of the rectangle to intersect the clip with&#xA;     * @param width the width of the rectangle to intersect the clip with&#xA;     * @param height the height of the rectangle to intersect the clip with&#xA;     * @see #setClip(int, int, int, int)&#xA;     * @see #setClip(Shape)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setClip">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the current clip to the rectangle specified by the given&#xA;     * coordinates.  This method sets the user clip, which is &#xA;     * independent of the clipping associated with device bounds&#xA;     * and window visibility.  &#xA;     * Rendering operations have no effect outside of the clipping area.&#xA;     * @param       x the &lt;i>x&lt;/i> coordinate of the new clip rectangle.&#xA;     * @param       y the &lt;i>y&lt;/i> coordinate of the new clip rectangle.&#xA;     * @param       width the width of the new clip rectangle.&#xA;     * @param       height the height of the new clip rectangle.&#xA;     * @see         java.awt.Graphics#clipRect&#xA;     * @see         java.awt.Graphics#setClip(Shape)&#xA;     * @see&#x9;    java.awt.Graphics#getClip&#xA;     * @since       JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getClip">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Interface" href="Shape.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Gets the current clipping area.&#xA;     * This method returns the user clip, which is independent of the&#xA;     * clipping associated with device bounds and window visibility.&#xA;     * If no clip has previously been set, or if the clip has been &#xA;     * cleared using &lt;code>setClip(null)&lt;/code>, this method returns &#xA;     * &lt;code>null&lt;/code>.&#xA;     * @return      a &lt;code>Shape&lt;/code> object representing the &#xA;     *              current clipping area, or &lt;code>null&lt;/code> if&#xA;     *              no clip is set.&#xA;     * @see         java.awt.Graphics#getClipBounds&#xA;     * @see         java.awt.Graphics#clipRect&#xA;     * @see         java.awt.Graphics#setClip(int, int, int, int)&#xA;     * @see         java.awt.Graphics#setClip(Shape)&#xA;     * @since       JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="setClip">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="clip">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="Shape.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Sets the current clipping area to an arbitrary clip shape.&#xA;     * Not all objects that implement the &lt;code>Shape&lt;/code> &#xA;     * interface can be used to set the clip.  The only &#xA;     * &lt;code>Shape&lt;/code> objects that are guaranteed to be &#xA;     * supported are &lt;code>Shape&lt;/code> objects that are&#xA;     * obtained via the &lt;code>getClip&lt;/code> method and via &#xA;     * &lt;code>Rectangle&lt;/code> objects.  This method sets the&#xA;     * user clip, which is independent of the clipping associated&#xA;     * with device bounds and window visibility.&#xA;     * @param clip the &lt;code>Shape&lt;/code> to use to set the clip&#xA;     * @see         java.awt.Graphics#getClip()&#xA;     * @see         java.awt.Graphics#clipRect&#xA;     * @see         java.awt.Graphics#setClip(int, int, int, int)&#xA;     * @since       JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="copyArea">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dx">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dy">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Copies an area of the component by a distance specified by &#xA;     * &lt;code>dx&lt;/code> and &lt;code>dy&lt;/code>. From the point specified&#xA;     * by &lt;code>x&lt;/code> and &lt;code>y&lt;/code>, this method&#xA;     * copies downwards and to the right.  To copy an area of the &#xA;     * component to the left or upwards, specify a negative value for &#xA;     * &lt;code>dx&lt;/code> or &lt;code>dy&lt;/code>.&#xA;     * If a portion of the source rectangle lies outside the bounds &#xA;     * of the component, or is obscured by another window or component, &#xA;     * &lt;code>copyArea&lt;/code> will be unable to copy the associated&#xA;     * pixels. The area that is omitted can be refreshed by calling &#xA;     * the component's &lt;code>paint&lt;/code> method.&#xA;     * @param       x the &lt;i>x&lt;/i> coordinate of the source rectangle.&#xA;     * @param       y the &lt;i>y&lt;/i> coordinate of the source rectangle.&#xA;     * @param       width the width of the source rectangle.&#xA;     * @param       height the height of the source rectangle.&#xA;     * @param       dx the horizontal distance to copy the pixels.&#xA;     * @param       dy the vertical distance to copy the pixels.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawLine">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws a line, using the current color, between the points &#xA;     * &lt;code>(x1,&amp;nbsp;y1)&lt;/code> and &lt;code>(x2,&amp;nbsp;y2)&lt;/code> &#xA;     * in this graphics context's coordinate system. &#xA;     * @param   x1  the first point's &lt;i>x&lt;/i> coordinate.&#xA;     * @param   y1  the first point's &lt;i>y&lt;/i> coordinate.&#xA;     * @param   x2  the second point's &lt;i>x&lt;/i> coordinate.&#xA;     * @param   y2  the second point's &lt;i>y&lt;/i> coordinate.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="fillRect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Fills the specified rectangle. &#xA;     * The left and right edges of the rectangle are at &#xA;     * &lt;code>x&lt;/code> and &lt;code>x&amp;nbsp;+&amp;nbsp;width&amp;nbsp;-&amp;nbsp;1&lt;/code>. &#xA;     * The top and bottom edges are at &#xA;     * &lt;code>y&lt;/code> and &lt;code>y&amp;nbsp;+&amp;nbsp;height&amp;nbsp;-&amp;nbsp;1&lt;/code>. &#xA;     * The resulting rectangle covers an area &#xA;     * &lt;code>width&lt;/code> pixels wide by &#xA;     * &lt;code>height&lt;/code> pixels tall.&#xA;     * The rectangle is filled using the graphics context's current color. &#xA;     * @param         x   the &lt;i>x&lt;/i> coordinate &#xA;     *                         of the rectangle to be filled.&#xA;     * @param         y   the &lt;i>y&lt;/i> coordinate &#xA;     *                         of the rectangle to be filled.&#xA;     * @param         width   the width of the rectangle to be filled.&#xA;     * @param         height   the height of the rectangle to be filled.&#xA;     * @see           java.awt.Graphics#clearRect&#xA;     * @see           java.awt.Graphics#drawRect&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="drawRect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws the outline of the specified rectangle. &#xA;     * The left and right edges of the rectangle are at &#xA;     * &lt;code>x&lt;/code> and &lt;code>x&amp;nbsp;+&amp;nbsp;width&lt;/code>. &#xA;     * The top and bottom edges are at &#xA;     * &lt;code>y&lt;/code> and &lt;code>y&amp;nbsp;+&amp;nbsp;height&lt;/code>. &#xA;     * The rectangle is drawn using the graphics context's current color.&#xA;     * @param         x   the &lt;i>x&lt;/i> coordinate &#xA;     *                         of the rectangle to be drawn.&#xA;     * @param         y   the &lt;i>y&lt;/i> coordinate &#xA;     *                         of the rectangle to be drawn.&#xA;     * @param         width   the width of the rectangle to be drawn.&#xA;     * @param         height   the height of the rectangle to be drawn.&#xA;     * @see          java.awt.Graphics#fillRect&#xA;     * @see          java.awt.Graphics#clearRect&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return"/>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.2"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
          <children xsi:type="expressions:NestedExpression">
            <expression xsi:type="expressions:RelationExpression">
              <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.3"/>
              <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
              <relationOperators xsi:type="operators:LessThan"/>
            </expression>
          </children>
        </condition>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.2"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.3"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:ConditionalOrExpression">
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </children>
          <children xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
          </children>
        </condition>
        <elseStatement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.2"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.2"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.2"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.3"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
                <additiveOperators xsi:type="operators:Subtraction"/>
              </arguments>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.2"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.3"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.3"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.3"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.0"/>
              <arguments xsi:type="expressions:AdditiveExpression">
                <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.20/@parameters.1"/>
                <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
                <additiveOperators xsi:type="operators:Addition"/>
              </arguments>
            </expression>
          </statements>
        </elseStatement>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="clearRect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Clears the specified rectangle by filling it with the background&#xA;     * color of the current drawing surface. This operation does not &#xA;     * use the current paint mode. &#xA;     * &lt;p>&#xA;     * Beginning with Java&amp;nbsp;1.1, the background color &#xA;     * of offscreen images may be system dependent. Applications should &#xA;     * use &lt;code>setColor&lt;/code> followed by &lt;code>fillRect&lt;/code> to &#xA;     * ensure that an offscreen image is cleared to a specific color. &#xA;     * @param       x the &lt;i>x&lt;/i> coordinate of the rectangle to clear.&#xA;     * @param       y the &lt;i>y&lt;/i> coordinate of the rectangle to clear.&#xA;     * @param       width the width of the rectangle to clear.&#xA;     * @param       height the height of the rectangle to clear.&#xA;     * @see         java.awt.Graphics#fillRect(int, int, int, int)&#xA;     * @see         java.awt.Graphics#drawRect&#xA;     * @see         java.awt.Graphics#setColor(java.awt.Color)&#xA;     * @see         java.awt.Graphics#setPaintMode&#xA;     * @see         java.awt.Graphics#setXORMode(java.awt.Color)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawRoundRect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="arcWidth">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="arcHeight">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws an outlined round-cornered rectangle using this graphics &#xA;     * context's current color. The left and right edges of the rectangle &#xA;     * are at &lt;code>x&lt;/code> and &lt;code>x&amp;nbsp;+&amp;nbsp;width&lt;/code>, &#xA;     * respectively. The top and bottom edges of the rectangle are at &#xA;     * &lt;code>y&lt;/code> and &lt;code>y&amp;nbsp;+&amp;nbsp;height&lt;/code>. &#xA;     * @param      x the &lt;i>x&lt;/i> coordinate of the rectangle to be drawn.&#xA;     * @param      y the &lt;i>y&lt;/i> coordinate of the rectangle to be drawn.&#xA;     * @param      width the width of the rectangle to be drawn.&#xA;     * @param      height the height of the rectangle to be drawn.&#xA;     * @param      arcWidth the horizontal diameter of the arc &#xA;     *                    at the four corners.&#xA;     * @param      arcHeight the vertical diameter of the arc &#xA;     *                    at the four corners.&#xA;     * @see        java.awt.Graphics#fillRoundRect&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="fillRoundRect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="arcWidth">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="arcHeight">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Fills the specified rounded corner rectangle with the current color.&#xA;     * The left and right edges of the rectangle &#xA;     * are at &lt;code>x&lt;/code> and &lt;code>x&amp;nbsp;+&amp;nbsp;width&amp;nbsp;-&amp;nbsp;1&lt;/code>, &#xA;     * respectively. The top and bottom edges of the rectangle are at &#xA;     * &lt;code>y&lt;/code> and &lt;code>y&amp;nbsp;+&amp;nbsp;height&amp;nbsp;-&amp;nbsp;1&lt;/code>. &#xA;     * @param       x the &lt;i>x&lt;/i> coordinate of the rectangle to be filled.&#xA;     * @param       y the &lt;i>y&lt;/i> coordinate of the rectangle to be filled.&#xA;     * @param       width the width of the rectangle to be filled.&#xA;     * @param       height the height of the rectangle to be filled.&#xA;     * @param       arcWidth the horizontal diameter &#xA;     *                     of the arc at the four corners.&#xA;     * @param       arcHeight the vertical diameter &#xA;     *                     of the arc at the four corners.&#xA;     * @see         java.awt.Graphics#drawRoundRect&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="draw3DRect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="raised">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Draws a 3-D highlighted outline of the specified rectangle.&#xA;     * The edges of the rectangle are highlighted so that they&#xA;     * appear to be beveled and lit from the upper left corner.&#xA;     * &lt;p>&#xA;     * The colors used for the highlighting effect are determined &#xA;     * based on the current color.&#xA;     * The resulting rectangle covers an area that is &#xA;     * &lt;code>width&amp;nbsp;+&amp;nbsp;1&lt;/code> pixels wide&#xA;     * by &lt;code>height&amp;nbsp;+&amp;nbsp;1&lt;/code> pixels tall.&#xA;     * @param       x the &lt;i>x&lt;/i> coordinate of the rectangle to be drawn.&#xA;     * @param       y the &lt;i>y&lt;/i> coordinate of the rectangle to be drawn.&#xA;     * @param       width the width of the rectangle to be drawn.&#xA;     * @param       height the height of the rectangle to be drawn.&#xA;     * @param       raised a boolean that determines whether the rectangle&#xA;     *                      appears to be raised above the surface &#xA;     *                      or sunk into the surface.&#xA;     * @see         java.awt.Graphics#fill3DRect&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="brighter">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Color.class.xmi#//@classifiers.0/@members.50"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="darker">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Color.class.xmi#//@classifiers.0/@members.51"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.5">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.4"/>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.1/@variable"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.2/@variable"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.3"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.5">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.4"/>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.2/@variable"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.1/@variable"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.3"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.3"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.2"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.5">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.24/@statements.0/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="fill3DRect">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="raised">
        <typeReference xsi:type="types:Boolean"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Paints a 3-D highlighted rectangle filled with the current color.&#xA;     * The edges of the rectangle will be highlighted so that it appears&#xA;     * as if the edges were beveled and lit from the upper left corner.&#xA;     * The colors used for the highlighting effect will be determined from&#xA;     * the current color.&#xA;     * @param       x the &lt;i>x&lt;/i> coordinate of the rectangle to be filled.&#xA;     * @param       y the &lt;i>y&lt;/i> coordinate of the rectangle to be filled.&#xA;     * @param       width the width of the rectangle to be filled.&#xA;     * @param       height the height of the rectangle to be filled.&#xA;     * @param       raised a boolean value that determines whether the &#xA;     *                      rectangle appears to be raised above the surface &#xA;     *                      or etched into the surface.&#xA;     * @see         java.awt.Graphics#draw3DRect&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="c">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="brighter">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Color.class.xmi#//@classifiers.0/@members.50"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="darker">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="Color.class.xmi#//@classifiers.0/@members.51"/>
            </next>
          </initialValue>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.5">
              <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.2/@variable"/>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:UnaryExpression">
          <operators xsi:type="operators:Negate"/>
          <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.4"/>
        </condition>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.19">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.5">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.4"/>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.1/@variable"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.2/@variable"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.5">
          <arguments xsi:type="expressions:ConditionalExpression">
            <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.4"/>
            <expressionIf xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.2/@variable"/>
            <expressionElse xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.1/@variable"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.18">
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.0"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.2"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="1"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
          <arguments xsi:type="expressions:AdditiveExpression">
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.1"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@parameters.3"/>
            <children xsi:type="literals:DecimalIntegerLiteral" decimalValue="2"/>
            <additiveOperators xsi:type="operators:Addition"/>
            <additiveOperators xsi:type="operators:Subtraction"/>
          </arguments>
        </expression>
      </statements>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.5">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.25/@statements.0/@variable"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawOval">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws the outline of an oval.&#xA;     * The result is a circle or ellipse that fits within the &#xA;     * rectangle specified by the &lt;code>x&lt;/code>, &lt;code>y&lt;/code>, &#xA;     * &lt;code>width&lt;/code>, and &lt;code>height&lt;/code> arguments. &#xA;     * &lt;p> &#xA;     * The oval covers an area that is &#xA;     * &lt;code>width&amp;nbsp;+&amp;nbsp;1&lt;/code> pixels wide &#xA;     * and &lt;code>height&amp;nbsp;+&amp;nbsp;1&lt;/code> pixels tall. &#xA;     * @param       x the &lt;i>x&lt;/i> coordinate of the upper left &#xA;     *                     corner of the oval to be drawn.&#xA;     * @param       y the &lt;i>y&lt;/i> coordinate of the upper left &#xA;     *                     corner of the oval to be drawn.&#xA;     * @param       width the width of the oval to be drawn.&#xA;     * @param       height the height of the oval to be drawn.&#xA;     * @see         java.awt.Graphics#fillOval&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="fillOval">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Fills an oval bounded by the specified rectangle with the&#xA;     * current color.&#xA;     * @param       x the &lt;i>x&lt;/i> coordinate of the upper left corner &#xA;     *                     of the oval to be filled.&#xA;     * @param       y the &lt;i>y&lt;/i> coordinate of the upper left corner &#xA;     *                     of the oval to be filled.&#xA;     * @param       width the width of the oval to be filled.&#xA;     * @param       height the height of the oval to be filled.&#xA;     * @see         java.awt.Graphics#drawOval&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawArc">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="startAngle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="arcAngle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Draws the outline of a circular or elliptical arc &#xA;     * covering the specified rectangle.&#xA;     * &lt;p>&#xA;     * The resulting arc begins at &lt;code>startAngle&lt;/code> and extends  &#xA;     * for &lt;code>arcAngle&lt;/code> degrees, using the current color.&#xA;     * Angles are interpreted such that 0&amp;nbsp;degrees &#xA;     * is at the 3&amp;nbsp;o'clock position. &#xA;     * A positive value indicates a counter-clockwise rotation&#xA;     * while a negative value indicates a clockwise rotation.&#xA;     * &lt;p>&#xA;     * The center of the arc is the center of the rectangle whose origin &#xA;     * is (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) and whose size is specified by the &#xA;     * &lt;code>width&lt;/code> and &lt;code>height&lt;/code> arguments. &#xA;     * &lt;p>&#xA;     * The resulting arc covers an area &#xA;     * &lt;code>width&amp;nbsp;+&amp;nbsp;1&lt;/code> pixels wide&#xA;     * by &lt;code>height&amp;nbsp;+&amp;nbsp;1&lt;/code> pixels tall.&#xA;     * &lt;p>&#xA;     * The angles are specified relative to the non-square extents of&#xA;     * the bounding rectangle such that 45 degrees always falls on the&#xA;     * line from the center of the ellipse to the upper right corner of&#xA;     * the bounding rectangle. As a result, if the bounding rectangle is&#xA;     * noticeably longer in one axis than the other, the angles to the&#xA;     * start and end of the arc segment will be skewed farther along the&#xA;     * longer axis of the bounds.&#xA;     * @param        x the &lt;i>x&lt;/i> coordinate of the &#xA;     *                    upper-left corner of the arc to be drawn.&#xA;     * @param        y the &lt;i>y&lt;/i>  coordinate of the &#xA;     *                    upper-left corner of the arc to be drawn.&#xA;     * @param        width the width of the arc to be drawn.&#xA;     * @param        height the height of the arc to be drawn.&#xA;     * @param        startAngle the beginning angle.&#xA;     * @param        arcAngle the angular extent of the arc, &#xA;     *                    relative to the start angle.&#xA;     * @see         java.awt.Graphics#fillArc&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="fillArc">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="startAngle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="arcAngle">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Fills a circular or elliptical arc covering the specified rectangle.&#xA;     * &lt;p>&#xA;     * The resulting arc begins at &lt;code>startAngle&lt;/code> and extends  &#xA;     * for &lt;code>arcAngle&lt;/code> degrees.&#xA;     * Angles are interpreted such that 0&amp;nbsp;degrees &#xA;     * is at the 3&amp;nbsp;o'clock position. &#xA;     * A positive value indicates a counter-clockwise rotation&#xA;     * while a negative value indicates a clockwise rotation.&#xA;     * &lt;p>&#xA;     * The center of the arc is the center of the rectangle whose origin &#xA;     * is (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) and whose size is specified by the &#xA;     * &lt;code>width&lt;/code> and &lt;code>height&lt;/code> arguments. &#xA;     * &lt;p>&#xA;     * The resulting arc covers an area &#xA;     * &lt;code>width&amp;nbsp;+&amp;nbsp;1&lt;/code> pixels wide&#xA;     * by &lt;code>height&amp;nbsp;+&amp;nbsp;1&lt;/code> pixels tall.&#xA;     * &lt;p>&#xA;     * The angles are specified relative to the non-square extents of&#xA;     * the bounding rectangle such that 45 degrees always falls on the&#xA;     * line from the center of the ellipse to the upper right corner of&#xA;     * the bounding rectangle. As a result, if the bounding rectangle is&#xA;     * noticeably longer in one axis than the other, the angles to the&#xA;     * start and end of the arc segment will be skewed farther along the&#xA;     * longer axis of the bounds.&#xA;     * @param        x the &lt;i>x&lt;/i> coordinate of the &#xA;     *                    upper-left corner of the arc to be filled.&#xA;     * @param        y the &lt;i>y&lt;/i>  coordinate of the &#xA;     *                    upper-left corner of the arc to be filled.&#xA;     * @param        width the width of the arc to be filled.&#xA;     * @param        height the height of the arc to be filled.&#xA;     * @param        startAngle the beginning angle.&#xA;     * @param        arcAngle the angular extent of the arc, &#xA;     *                    relative to the start angle.&#xA;     * @see         java.awt.Graphics#drawArc&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawPolyline">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="xPoints">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="yPoints">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nPoints">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws a sequence of connected lines defined by &#xA;     * arrays of &lt;i>x&lt;/i> and &lt;i>y&lt;/i> coordinates. &#xA;     * Each pair of (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) coordinates defines a point.&#xA;     * The figure is not closed if the first point &#xA;     * differs from the last point.&#xA;     * @param       xPoints an array of &lt;i>x&lt;/i> points&#xA;     * @param       yPoints an array of &lt;i>y&lt;/i> points&#xA;     * @param       nPoints the total number of points&#xA;     * @see         java.awt.Graphics#drawPolygon(int[], int[], int)&#xA;     * @since       JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawPolygon">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="xPoints">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="yPoints">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nPoints">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws a closed polygon defined by &#xA;     * arrays of &lt;i>x&lt;/i> and &lt;i>y&lt;/i> coordinates. &#xA;     * Each pair of (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) coordinates defines a point.&#xA;     * &lt;p>&#xA;     * This method draws the polygon defined by &lt;code>nPoint&lt;/code> line &#xA;     * segments, where the first &lt;code>nPoint&amp;nbsp;-&amp;nbsp;1&lt;/code> &#xA;     * line segments are line segments from &#xA;     * &lt;code>(xPoints[i&amp;nbsp;-&amp;nbsp;1],&amp;nbsp;yPoints[i&amp;nbsp;-&amp;nbsp;1])&lt;/code> &#xA;     * to &lt;code>(xPoints[i],&amp;nbsp;yPoints[i])&lt;/code>, for &#xA;     * 1&amp;nbsp;&amp;le;&amp;nbsp;&lt;i>i&lt;/i>&amp;nbsp;&amp;le;&amp;nbsp;&lt;code>nPoints&lt;/code>.  &#xA;     * The figure is automatically closed by drawing a line connecting&#xA;     * the final point to the first point, if those points are different.&#xA;     * @param        xPoints   a an array of &lt;code>x&lt;/code> coordinates.&#xA;     * @param        yPoints   a an array of &lt;code>y&lt;/code> coordinates.&#xA;     * @param        nPoints   a the total number of points.&#xA;     * @see          java.awt.Graphics#fillPolygon&#xA;     * @see          java.awt.Graphics#drawPolyline&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="drawPolygon">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="p">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Polygon.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws the outline of a polygon defined by the specified &#xA;     * &lt;code>Polygon&lt;/code> object. &#xA;     * @param        p the polygon to draw.&#xA;     * @see          java.awt.Graphics#fillPolygon&#xA;     * @see          java.awt.Graphics#drawPolyline&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.31">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Polygon.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Polygon.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.32/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Polygon.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="fillPolygon">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="xPoints">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="yPoints">
        <typeReference xsi:type="types:Int"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="nPoints">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Fills a closed polygon defined by &#xA;     * arrays of &lt;i>x&lt;/i> and &lt;i>y&lt;/i> coordinates. &#xA;     * &lt;p>&#xA;     * This method draws the polygon defined by &lt;code>nPoint&lt;/code> line &#xA;     * segments, where the first &lt;code>nPoint&amp;nbsp;-&amp;nbsp;1&lt;/code> &#xA;     * line segments are line segments from &#xA;     * &lt;code>(xPoints[i&amp;nbsp;-&amp;nbsp;1],&amp;nbsp;yPoints[i&amp;nbsp;-&amp;nbsp;1])&lt;/code> &#xA;     * to &lt;code>(xPoints[i],&amp;nbsp;yPoints[i])&lt;/code>, for &#xA;     * 1&amp;nbsp;&amp;le;&amp;nbsp;&lt;i>i&lt;/i>&amp;nbsp;&amp;le;&amp;nbsp;&lt;code>nPoints&lt;/code>.  &#xA;     * The figure is automatically closed by drawing a line connecting&#xA;     * the final point to the first point, if those points are different.&#xA;     * &lt;p>&#xA;     * The area inside the polygon is defined using an &#xA;     * even-odd fill rule, also known as the alternating rule.&#xA;     * @param        xPoints   a an array of &lt;code>x&lt;/code> coordinates.&#xA;     * @param        yPoints   a an array of &lt;code>y&lt;/code> coordinates.&#xA;     * @param        nPoints   a the total number of points.&#xA;     * @see          java.awt.Graphics#drawPolygon(int[], int[], int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="fillPolygon">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="p">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Polygon.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Fills the polygon defined by the specified Polygon object with&#xA;     * the graphics context's current color. &#xA;     * &lt;p>&#xA;     * The area inside the polygon is defined using an &#xA;     * even-odd fill rule, also known as the alternating rule.&#xA;     * @param        p the polygon to fill.&#xA;     * @see          java.awt.Graphics#drawPolygon(int[], int[], int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.33">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Polygon.class.xmi#//@classifiers.0/@members.1"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Polygon.class.xmi#//@classifiers.0/@members.2"/>
            </next>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.34/@parameters.0">
            <next xsi:type="references:IdentifierReference">
              <target xsi:type="members:Field" href="Polygon.class.xmi#//@classifiers.0/@members.0"/>
            </next>
          </arguments>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawString">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="str">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws the text given by the specified string, using this &#xA;     * graphics context's current font and color. The baseline of the &#xA;     * leftmost character is at position (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in this &#xA;     * graphics context's coordinate system. &#xA;     * @param       str      the string to be drawn.&#xA;     * @param       x        the &lt;i>x&lt;/i> coordinate.&#xA;     * @param       y        the &lt;i>y&lt;/i> coordinate.&#xA;     * @see         java.awt.Graphics#drawBytes&#xA;     * @see         java.awt.Graphics#drawChars&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawString">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="iterator">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="../text/AttributedCharacterIterator.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws the text given by the specified iterator, using this &#xA;     * graphics context's current color. The iterator has to specify a font&#xA;     * for each character. The baseline of the &#xA;     * leftmost character is at position (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in this &#xA;     * graphics context's coordinate system. &#xA;     * @param       iterator the iterator whose text is to be drawn&#xA;     * @param       x        the &lt;i>x&lt;/i> coordinate.&#xA;     * @param       y        the &lt;i>y&lt;/i> coordinate.&#xA;     * @see         java.awt.Graphics#drawBytes&#xA;     * @see         java.awt.Graphics#drawChars&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="drawChars">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:Char"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws the text given by the specified character array, using this &#xA;     * graphics context's current font and color. The baseline of the &#xA;     * first character is at position (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in this &#xA;     * graphics context's coordinate system. &#xA;     * @param data the array of characters to be drawn&#xA;     * @param offset the start offset in the data&#xA;     * @param length the number of characters to be drawn&#xA;     * @param x the &lt;i>x&lt;/i> coordinate of the baseline of the text&#xA;     * @param y the &lt;i>y&lt;/i> coordinate of the baseline of the text&#xA;     * @see         java.awt.Graphics#drawBytes&#xA;     * @see         java.awt.Graphics#drawString&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.35">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.2"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.3"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.37/@parameters.4"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="drawBytes">
      <typeReference xsi:type="types:Void"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="data">
        <typeReference xsi:type="types:Byte"/>
        <arrayDimensionsAfter/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="offset">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="length">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws the text given by the specified byte array, using this &#xA;     * graphics context's current font and color. The baseline of the &#xA;     * first character is at position (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in this &#xA;     * graphics context's coordinate system.&#xA;     * @param data the data to be drawn&#xA;     * @param offset the start offset in the data&#xA;     * @param length the number of bytes that are drawn&#xA;     * @param x the &lt;i>x&lt;/i> coordinate of the baseline of the text&#xA;     * @param y the &lt;i>y&lt;/i> coordinate of the baseline of the text&#xA;     * @see         java.awt.Graphics#drawChars&#xA;     * @see         java.awt.Graphics#drawString&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.35">
          <arguments xsi:type="instantiations:NewConstructorCall">
            <typeReference xsi:type="types:NamespaceClassifierReference">
              <classifierReferences>
                <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
              </classifierReferences>
            </typeReference>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.0"/>
            <arguments xsi:type="literals:DecimalIntegerLiteral" decimalValue="0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.2"/>
          </arguments>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.3"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.38/@parameters.4"/>
        </expression>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawImage">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="img">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Image.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="observer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="image/ImageObserver.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws as much of the specified image as is currently available.&#xA;     * The image is drawn with its top-left corner at &#xA;     * (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in this graphics context's coordinate &#xA;     * space. Transparent pixels in the image do not affect whatever &#xA;     * pixels are already there. &#xA;     * &lt;p>&#xA;     * This method returns immediately in all cases, even if the&#xA;     * complete image has not yet been loaded, and it has not been dithered &#xA;     * and converted for the current output device.&#xA;     * &lt;p>&#xA;     * If the image has completely loaded and its pixels are&#xA;     * no longer being changed, then&#xA;     * &lt;code>drawImage&lt;/code> returns &lt;code>true&lt;/code>. &#xA;     * Otherwise, &lt;code>drawImage&lt;/code> returns &lt;code>false&lt;/code>&#xA;     * and as more of&#xA;     * the image becomes available &#xA;     * or it is time to draw another frame of animation,&#xA;     * the process that loads the image notifies &#xA;     * the specified image observer.&#xA;     * @param    img the specified image to be drawn. This method does&#xA;     *               nothing if &lt;code>img&lt;/code> is null.&#xA;     * @param    x   the &lt;i>x&lt;/i> coordinate.&#xA;     * @param    y   the &lt;i>y&lt;/i> coordinate.&#xA;     * @param    observer    object to be notified as more of &#xA;     *                          the image is converted.&#xA;     * @return   &lt;code>false&lt;/code> if the image pixels are still changing;&#xA;     *           &lt;code>true&lt;/code> otherwise.&#xA;     * @see      java.awt.Image&#xA;     * @see      java.awt.image.ImageObserver&#xA;     * @see      java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int, int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawImage">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="img">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Image.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="observer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="image/ImageObserver.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Draws as much of the specified image as has already been scaled&#xA;     * to fit inside the specified rectangle.&#xA;     * &lt;p>&#xA;     * The image is drawn inside the specified rectangle of this &#xA;     * graphics context's coordinate space, and is scaled if &#xA;     * necessary. Transparent pixels do not affect whatever pixels&#xA;     * are already there. &#xA;     * &lt;p>&#xA;     * This method returns immediately in all cases, even if the&#xA;     * entire image has not yet been scaled, dithered, and converted&#xA;     * for the current output device.&#xA;     * If the current output representation is not yet complete, then&#xA;     * &lt;code>drawImage&lt;/code> returns &lt;code>false&lt;/code>. As more of&#xA;     * the image becomes available, the process that loads the image notifies&#xA;     * the image observer by calling its &lt;code>imageUpdate&lt;/code> method.&#xA;     * &lt;p>&#xA;     * A scaled version of an image will not necessarily be&#xA;     * available immediately just because an unscaled version of the&#xA;     * image has been constructed for this output device.  Each size of&#xA;     * the image may be cached separately and generated from the original&#xA;     * data in a separate image production sequence.&#xA;     * @param    img    the specified image to be drawn. This method does&#xA;     *                  nothing if &lt;code>img&lt;/code> is null.&#xA;     * @param    x      the &lt;i>x&lt;/i> coordinate.&#xA;     * @param    y      the &lt;i>y&lt;/i> coordinate.&#xA;     * @param    width  the width of the rectangle.&#xA;     * @param    height the height of the rectangle.&#xA;     * @param    observer    object to be notified as more of &#xA;     *                          the image is converted.&#xA;     * @return   &lt;code>false&lt;/code> if the image pixels are still changing;&#xA;     *           &lt;code>true&lt;/code> otherwise.&#xA;     * @see      java.awt.Image&#xA;     * @see      java.awt.image.ImageObserver&#xA;     * @see      java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int, int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawImage">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="img">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Image.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bgcolor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="observer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="image/ImageObserver.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Draws as much of the specified image as is currently available.&#xA;     * The image is drawn with its top-left corner at &#xA;     * (&lt;i>x&lt;/i>,&amp;nbsp;&lt;i>y&lt;/i>) in this graphics context's coordinate &#xA;     * space.  Transparent pixels are drawn in the specified&#xA;     * background color.&#xA;     * &lt;p> &#xA;     * This operation is equivalent to filling a rectangle of the&#xA;     * width and height of the specified image with the given color and then&#xA;     * drawing the image on top of it, but possibly more efficient.&#xA;     * &lt;p>&#xA;     * This method returns immediately in all cases, even if the&#xA;     * complete image has not yet been loaded, and it has not been dithered &#xA;     * and converted for the current output device.&#xA;     * &lt;p>&#xA;     * If the image has completely loaded and its pixels are&#xA;     * no longer being changed, then&#xA;     * &lt;code>drawImage&lt;/code> returns &lt;code>true&lt;/code>. &#xA;     * Otherwise, &lt;code>drawImage&lt;/code> returns &lt;code>false&lt;/code>&#xA;     * and as more of&#xA;     * the image becomes available &#xA;     * or it is time to draw another frame of animation,&#xA;     * the process that loads the image notifies &#xA;     * the specified image observer.&#xA;     * @param    img the specified image to be drawn. This method does&#xA;     *               nothing if &lt;code>img&lt;/code> is null.&#xA;     * @param    x      the &lt;i>x&lt;/i> coordinate.&#xA;     * @param    y      the &lt;i>y&lt;/i> coordinate.&#xA;     * @param    bgcolor the background color to paint under the&#xA;     *                         non-opaque portions of the image.&#xA;     * @param    observer    object to be notified as more of &#xA;     *                          the image is converted.&#xA;     * @return   &lt;code>false&lt;/code> if the image pixels are still changing;&#xA;     *           &lt;code>true&lt;/code> otherwise.&#xA;     * @see      java.awt.Image&#xA;     * @see      java.awt.image.ImageObserver&#xA;     * @see      java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int, int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawImage">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="img">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Image.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bgcolor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="observer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="image/ImageObserver.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Draws as much of the specified image as has already been scaled&#xA;     * to fit inside the specified rectangle.&#xA;     * &lt;p>&#xA;     * The image is drawn inside the specified rectangle of this &#xA;     * graphics context's coordinate space, and is scaled if &#xA;     * necessary. Transparent pixels are drawn in the specified&#xA;     * background color. &#xA;     * This operation is equivalent to filling a rectangle of the&#xA;     * width and height of the specified image with the given color and then&#xA;     * drawing the image on top of it, but possibly more efficient.&#xA;     * &lt;p>&#xA;     * This method returns immediately in all cases, even if the&#xA;     * entire image has not yet been scaled, dithered, and converted&#xA;     * for the current output device.&#xA;     * If the current output representation is not yet complete then&#xA;     * &lt;code>drawImage&lt;/code> returns &lt;code>false&lt;/code>. As more of&#xA;     * the image becomes available, the process that loads the image notifies &#xA;     * the specified image observer.&#xA;     * &lt;p>&#xA;     * A scaled version of an image will not necessarily be&#xA;     * available immediately just because an unscaled version of the&#xA;     * image has been constructed for this output device.  Each size of&#xA;     * the image may be cached separately and generated from the original&#xA;     * data in a separate image production sequence.&#xA;     * @param    img       the specified image to be drawn. This method does&#xA;     *                     nothing if &lt;code>img&lt;/code> is null.&#xA;     * @param    x         the &lt;i>x&lt;/i> coordinate.&#xA;     * @param    y         the &lt;i>y&lt;/i> coordinate.&#xA;     * @param    width     the width of the rectangle.&#xA;     * @param    height    the height of the rectangle.&#xA;     * @param    bgcolor   the background color to paint under the&#xA;     *                         non-opaque portions of the image.&#xA;     * @param    observer    object to be notified as more of &#xA;     *                          the image is converted.&#xA;     * @return   &lt;code>false&lt;/code> if the image pixels are still changing;&#xA;     *           &lt;code>true&lt;/code> otherwise.&#xA;     * @see      java.awt.Image&#xA;     * @see      java.awt.image.ImageObserver&#xA;     * @see      java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int, int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawImage">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="img">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Image.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dx1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dy1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dx2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dy2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sx1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sy1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sx2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sy2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="observer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="image/ImageObserver.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Draws as much of the specified area of the specified image as is&#xA;     * currently available, scaling it on the fly to fit inside the&#xA;     * specified area of the destination drawable surface. Transparent pixels &#xA;     * do not affect whatever pixels are already there.&#xA;     * &lt;p>&#xA;     * This method returns immediately in all cases, even if the&#xA;     * image area to be drawn has not yet been scaled, dithered, and converted&#xA;     * for the current output device.&#xA;     * If the current output representation is not yet complete then&#xA;     * &lt;code>drawImage&lt;/code> returns &lt;code>false&lt;/code>. As more of&#xA;     * the image becomes available, the process that loads the image notifies &#xA;     * the specified image observer.&#xA;     * &lt;p>&#xA;     * This method always uses the unscaled version of the image&#xA;     * to render the scaled rectangle and performs the required&#xA;     * scaling on the fly. It does not use a cached, scaled version&#xA;     * of the image for this operation. Scaling of the image from source&#xA;     * to destination is performed such that the first coordinate&#xA;     * of the source rectangle is mapped to the first coordinate of&#xA;     * the destination rectangle, and the second source coordinate is&#xA;     * mapped to the second destination coordinate. The subimage is&#xA;     * scaled and flipped as needed to preserve those mappings.&#xA;     * @param       img the specified image to be drawn. This method does&#xA;     *                  nothing if &lt;code>img&lt;/code> is null.&#xA;     * @param       dx1 the &lt;i>x&lt;/i> coordinate of the first corner of the&#xA;     *                    destination rectangle.&#xA;     * @param       dy1 the &lt;i>y&lt;/i> coordinate of the first corner of the&#xA;     *                    destination rectangle.&#xA;     * @param       dx2 the &lt;i>x&lt;/i> coordinate of the second corner of the&#xA;     *                    destination rectangle.&#xA;     * @param       dy2 the &lt;i>y&lt;/i> coordinate of the second corner of the&#xA;     *                    destination rectangle.&#xA;     * @param       sx1 the &lt;i>x&lt;/i> coordinate of the first corner of the&#xA;     *                    source rectangle.&#xA;     * @param       sy1 the &lt;i>y&lt;/i> coordinate of the first corner of the&#xA;     *                    source rectangle.&#xA;     * @param       sx2 the &lt;i>x&lt;/i> coordinate of the second corner of the&#xA;     *                    source rectangle.&#xA;     * @param       sy2 the &lt;i>y&lt;/i> coordinate of the second corner of the&#xA;     *                    source rectangle.&#xA;     * @param       observer object to be notified as more of the image is&#xA;     *                    scaled and converted.&#xA;     * @return   &lt;code>false&lt;/code> if the image pixels are still changing;&#xA;     *           &lt;code>true&lt;/code> otherwise.&#xA;     * @see         java.awt.Image&#xA;     * @see         java.awt.image.ImageObserver&#xA;     * @see         java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int, int, int)&#xA;     * @since       JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="drawImage">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="img">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Image.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dx1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dy1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dx2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="dy2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sx1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sy1">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sx2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="sy2">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="bgcolor">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Color.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="observer">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Interface" href="image/ImageObserver.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Draws as much of the specified area of the specified image as is&#xA;     * currently available, scaling it on the fly to fit inside the&#xA;     * specified area of the destination drawable surface. &#xA;     * &lt;p>&#xA;     * Transparent pixels are drawn in the specified background color. &#xA;     * This operation is equivalent to filling a rectangle of the&#xA;     * width and height of the specified image with the given color and then&#xA;     * drawing the image on top of it, but possibly more efficient.&#xA;     * &lt;p>&#xA;     * This method returns immediately in all cases, even if the&#xA;     * image area to be drawn has not yet been scaled, dithered, and converted&#xA;     * for the current output device.&#xA;     * If the current output representation is not yet complete then&#xA;     * &lt;code>drawImage&lt;/code> returns &lt;code>false&lt;/code>. As more of&#xA;     * the image becomes available, the process that loads the image notifies &#xA;     * the specified image observer.&#xA;     * &lt;p>&#xA;     * This method always uses the unscaled version of the image&#xA;     * to render the scaled rectangle and performs the required&#xA;     * scaling on the fly. It does not use a cached, scaled version&#xA;     * of the image for this operation. Scaling of the image from source&#xA;     * to destination is performed such that the first coordinate&#xA;     * of the source rectangle is mapped to the first coordinate of&#xA;     * the destination rectangle, and the second source coordinate is&#xA;     * mapped to the second destination coordinate. The subimage is&#xA;     * scaled and flipped as needed to preserve those mappings.&#xA;     * @param       img the specified image to be drawn. This method does&#xA;     *                  nothing if &lt;code>img&lt;/code> is null.&#xA;     * @param       dx1 the &lt;i>x&lt;/i> coordinate of the first corner of the&#xA;     *                    destination rectangle.&#xA;     * @param       dy1 the &lt;i>y&lt;/i> coordinate of the first corner of the&#xA;     *                    destination rectangle.&#xA;     * @param       dx2 the &lt;i>x&lt;/i> coordinate of the second corner of the&#xA;     *                    destination rectangle.&#xA;     * @param       dy2 the &lt;i>y&lt;/i> coordinate of the second corner of the&#xA;     *                    destination rectangle.&#xA;     * @param       sx1 the &lt;i>x&lt;/i> coordinate of the first corner of the&#xA;     *                    source rectangle.&#xA;     * @param       sy1 the &lt;i>y&lt;/i> coordinate of the first corner of the&#xA;     *                    source rectangle.&#xA;     * @param       sx2 the &lt;i>x&lt;/i> coordinate of the second corner of the&#xA;     *                    source rectangle.&#xA;     * @param       sy2 the &lt;i>y&lt;/i> coordinate of the second corner of the&#xA;     *                    source rectangle.&#xA;     * @param       bgcolor the background color to paint under the&#xA;     *                    non-opaque portions of the image.&#xA;     * @param       observer object to be notified as more of the image is&#xA;     *                    scaled and converted.&#xA;     * @return   &lt;code>false&lt;/code> if the image pixels are still changing;&#xA;     *           &lt;code>true&lt;/code> otherwise.&#xA;     * @see         java.awt.Image&#xA;     * @see         java.awt.image.ImageObserver&#xA;     * @see         java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int, int, int)&#xA;     * @since       JDK1.1&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="dispose">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Disposes of this graphics context and releases &#xA;     * any system resources that it is using. &#xA;     * A &lt;code>Graphics&lt;/code> object cannot be used after &#xA;     * &lt;code>dispose&lt;/code>has been called.&#xA;     * &lt;p>&#xA;     * When a Java program runs, a large number of &lt;code>Graphics&lt;/code>&#xA;     * objects can be created within a short time frame.&#xA;     * Although the finalization process of the garbage collector &#xA;     * also disposes of the same system resources, it is preferable &#xA;     * to manually free the associated resources by calling this&#xA;     * method rather than to rely on a finalization process which &#xA;     * may not run to completion for a long period of time.&#xA;     * &lt;p>&#xA;     * Graphics objects which are provided as arguments to the &#xA;     * &lt;code>paint&lt;/code> and &lt;code>update&lt;/code> methods &#xA;     * of components are automatically released by the system when &#xA;     * those methods return. For efficiency, programmers should&#xA;     * call &lt;code>dispose&lt;/code> when finished using&#xA;     * a &lt;code>Graphics&lt;/code> object only if it was created &#xA;     * directly from a component or another &lt;code>Graphics&lt;/code> object.&#xA;     * @see         java.awt.Graphics#finalize&#xA;     * @see         java.awt.Component#paint&#xA;     * @see         java.awt.Component#update&#xA;     * @see         java.awt.Component#getGraphics&#xA;     * @see         java.awt.Graphics#create&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="finalize">
      <typeReference xsi:type="types:Void"/>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Disposes of this graphics context once it is no longer referenced.&#xA;     * @see #dispose&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:ExpressionStatement">
        <expression xsi:type="references:MethodCall" target="//@classifiers.0/@members.45"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="toString">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="../lang/String.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>String&lt;/code> object representing this &#xA;     *                        &lt;code>Graphics&lt;/code> object's value.&#xA;     * @return       a string representation of this graphics context.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="expressions:AdditiveExpression">
          <children xsi:type="references:MethodCall">
            <next xsi:type="references:MethodCall">
              <target xsi:type="members:ClassMethod" href="../lang/Class.class.xmi#//@classifiers.0/@members.44"/>
            </next>
            <target xsi:type="members:ClassMethod" href="../lang/Object.class.xmi#//@classifiers.0/@members.2"/>
          </children>
          <children xsi:type="references:StringReference" value="[font="/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.8"/>
          <children xsi:type="references:StringReference" value=",color="/>
          <children xsi:type="references:MethodCall" target="//@classifiers.0/@members.4"/>
          <children xsi:type="references:StringReference" value="]"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
          <additiveOperators xsi:type="operators:Addition"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getClipRect">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Rectangle.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="annotations:AnnotationInstance">
        <comments>/**&#xA;     * Returns the bounding rectangle of the current clipping area.&#xA;     * @return      the bounding rectangle of the current clipping area&#xA;     *              or &lt;code>null&lt;/code> if no clip is set.&#xA;     * @deprecated As of JDK version 1.1,&#xA;     * replaced by &lt;code>getClipBounds()&lt;/code>.&#xA;     */</comments>
        <annotation xsi:type="classifiers:Annotation" href="../lang/Deprecated.class.xmi#//@classifiers.0"/>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Public"/>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="hitClip">
      <typeReference xsi:type="types:Boolean"/>
      <parameters xsi:type="parameters:OrdinaryParameter" name="x">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="y">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns true if the specified rectangular area might intersect &#xA;     * the current clipping area.&#xA;     * The coordinates of the specified rectangular area are in the&#xA;     * user coordinate space and are relative to the coordinate&#xA;     * system origin of this graphics context.&#xA;     * This method may use an algorithm that calculates a result quickly&#xA;     * but which sometimes might return true even if the specified&#xA;     * rectangular area does not intersect the clipping area.&#xA;     * The specific algorithm employed may thus trade off accuracy for&#xA;     * speed, but it will never return false unless it can guarantee&#xA;     * that the specified rectangular area does not intersect the&#xA;     * current clipping area.&#xA;     * The clipping area used by this method can represent the&#xA;     * intersection of the user clip as specified through the clip&#xA;     * methods of this graphics context as well as the clipping&#xA;     * associated with the device or image bounds and window visibility.&#xA;     *&#xA;     * @param x the x coordinate of the rectangle to test against the clip&#xA;     * @param y the y coordinate of the rectangle to test against the clip&#xA;     * @param width the width of the rectangle to test against the clip&#xA;     * @param height the height of the rectangle to test against the clip&#xA;     * @return &lt;code>true&lt;/code> if the specified rectangle intersects&#xA;     *         the bounds of the current clip; &lt;code>false&lt;/code>&#xA;     *         otherwise.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="clipRect">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Note, this implementation is not very efficient.</comments>
              <comments>// Subclasses should override this method and calculate</comments>
              <comments>// the results more directly.</comments>
              <target xsi:type="classifiers:Class" href="Rectangle.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:Return">
            <returnValue xsi:type="literals:BooleanLiteral" value="true"/>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@statements.0/@variable">
          <next xsi:type="references:MethodCall">
            <target xsi:type="members:ClassMethod" href="geom/Rectangle2D.class.xmi#//@classifiers.0/@members.14"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.1"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.2"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.49/@parameters.3"/>
          </next>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getClipBounds">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Rectangle.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="r">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="Rectangle.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the bounding rectangle of the current clipping area.&#xA;     * The coordinates in the rectangle are relative to the coordinate&#xA;     * system origin of this graphics context.  This method differs&#xA;     * from {@link #getClipBounds() getClipBounds} in that an existing &#xA;     * rectangle is used instead of allocating a new one.  &#xA;     * This method refers to the user clip, which is independent of the&#xA;     * clipping associated with device bounds and window visibility.&#xA;     *  If no clip has previously been set, or if the clip has been &#xA;     * cleared using &lt;code>setClip(null)&lt;/code>, this method returns the &#xA;     * specified &lt;code>Rectangle&lt;/code>.&#xA;     * @param  r    the rectangle where the current clipping area is&#xA;     *              copied to.  Any current values in this rectangle are&#xA;     *              overwritten.&#xA;     * @return      the bounding rectangle of the current clipping area.&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:LocalVariableStatement">
        <variable name="clipRect">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <comments>// Note, this implementation is not very efficient.</comments>
              <comments>// Subclasses should override this method and avoid</comments>
              <comments>// the allocation overhead of getClipBounds().</comments>
              <target xsi:type="classifiers:Class" href="Rectangle.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
          <initialValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.12"/>
        </variable>
      </statements>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Rectangle.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Rectangle.class.xmi#//@classifiers.0/@members.0"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Rectangle.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Rectangle.class.xmi#//@classifiers.0/@members.1"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Rectangle.class.xmi#//@classifiers.0/@members.2"/>
                </next>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Rectangle.class.xmi#//@classifiers.0/@members.2"/>
                </next>
              </value>
            </expression>
          </statements>
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Rectangle.class.xmi#//@classifiers.0/@members.3"/>
                </next>
              </child>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable">
                <next xsi:type="references:IdentifierReference">
                  <target xsi:type="members:Field" href="Rectangle.class.xmi#//@classifiers.0/@members.3"/>
                </next>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:NotEqual"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@statements.0/@variable"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
        <elseStatement xsi:type="statements:Condition">
          <statement xsi:type="statements:Block">
            <statements xsi:type="statements:Throw">
              <throwable xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="../lang/NullPointerException.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="references:StringReference" value="null rectangle parameter"/>
              </throwable>
            </statements>
          </statement>
          <condition xsi:type="expressions:EqualityExpression">
            <equalityOperators xsi:type="operators:Equal"/>
            <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
            <children xsi:type="literals:NullLiteral"/>
          </condition>
        </elseStatement>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.50/@parameters.0"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>Graphics&lt;/code> class is the abstract base class for &#xA; * all graphics contexts that allow an application to draw onto &#xA; * components that are realized on various devices, as well as &#xA; * onto off-screen images.&#xA; * &lt;p>&#xA; * A &lt;code>Graphics&lt;/code> object encapsulates state information needed&#xA; * for the basic rendering operations that Java supports.  This&#xA; * state information includes the following properties:&#xA; * &lt;p>&#xA; * &lt;ul>&#xA; * &lt;li>The &lt;code>Component&lt;/code> object on which to draw.&#xA; * &lt;li>A translation origin for rendering and clipping coordinates.&#xA; * &lt;li>The current clip.  &#xA; * &lt;li>The current color.&#xA; * &lt;li>The current font.&#xA; * &lt;li>The current logical pixel operation function (XOR or Paint).&#xA; * &lt;li>The current XOR alternation color &#xA; *     (see {@link Graphics#setXORMode}).&#xA; * &lt;/ul>&#xA; * &lt;p>&#xA; * Coordinates are infinitely thin and lie between the pixels of the&#xA; * output device.&#xA; * Operations that draw the outline of a figure operate by traversing&#xA; * an infinitely thin path between pixels with a pixel-sized pen that hangs&#xA; * down and to the right of the anchor point on the path.&#xA; * Operations that fill a figure operate by filling the interior&#xA; * of that infinitely thin path.&#xA; * Operations that render horizontal text render the ascending&#xA; * portion of character glyphs entirely above the baseline coordinate.&#xA; * &lt;p>&#xA; * The graphics pen hangs down and to the right from the path it traverses. &#xA; * This has the following implications:&#xA; * &lt;p>&lt;ul>&#xA; * &lt;li>If you draw a figure that covers a given rectangle, that &#xA; * figure occupies one extra row of pixels on the right and bottom edges &#xA; * as compared to filling a figure that is bounded by that same rectangle.&#xA; * &lt;li>If you draw a horizontal line along the same &lt;i>y&lt;/i> coordinate as&#xA; * the baseline of a line of text, that line is drawn entirely below&#xA; * the text, except for any descenders.&#xA; * &lt;/ul>&lt;p>&#xA; * All coordinates that appear as arguments to the methods of this&#xA; * &lt;code>Graphics&lt;/code> object are considered relative to the &#xA; * translation origin of this &lt;code>Graphics&lt;/code> object prior to &#xA; * the invocation of the method.&#xA; * &lt;p>&#xA; * All rendering operations modify only pixels which lie within the&#xA; * area bounded by the current clip, which is specified by a {@link Shape} &#xA; * in user space and is controlled by the program using the &#xA; * &lt;code>Graphics&lt;/code> object.  This &lt;i>user clip&lt;/i> &#xA; * is transformed into device space and combined with the &#xA; * &lt;i>device clip&lt;/i>, which is defined by the visibility of windows and&#xA; * device extents.  The combination of the user clip and device clip &#xA; * defines the &lt;i>composite clip&lt;/i>, which determines the final clipping&#xA; * region.  The user clip cannot be modified by the rendering &#xA; * system to reflect the resulting composite clip. The user clip can only&#xA; * be changed through the &lt;code>setClip&lt;/code> or &lt;code>clipRect&lt;/code> &#xA; * methods.&#xA; * All drawing or writing is done in the current color, &#xA; * using the current paint mode, and in the current font. &#xA; * &#xA; * @version &#x9;1.69, 05/18/04&#xA; * @author &#x9;Sami Shaio&#xA; * @author &#x9;Arthur van Hoff&#xA; * @see     java.awt.Component&#xA; * @see     java.awt.Graphics#clipRect(int, int, int, int)&#xA; * @see     java.awt.Graphics#setColor(java.awt.Color)&#xA; * @see     java.awt.Graphics#setPaintMode()&#xA; * @see     java.awt.Graphics#setXORMode(java.awt.Color)&#xA; * @see     java.awt.Graphics#setFont(java.awt.Font)&#xA; * @since       JDK1.0&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
