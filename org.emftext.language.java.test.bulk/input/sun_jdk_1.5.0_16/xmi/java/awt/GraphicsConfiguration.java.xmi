<?xml version="1.0" encoding="ASCII"?>
<containers:CompilationUnit xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:classifiers="http://www.emftext.org/java/classifiers" xmlns:containers="http://www.emftext.org/java/containers" xmlns:expressions="http://www.emftext.org/java/expressions" xmlns:imports="http://www.emftext.org/java/imports" xmlns:instantiations="http://www.emftext.org/java/instantiations" xmlns:literals="http://www.emftext.org/java/literals" xmlns:members="http://www.emftext.org/java/members" xmlns:modifiers="http://www.emftext.org/java/modifiers" xmlns:operators="http://www.emftext.org/java/operators" xmlns:parameters="http://www.emftext.org/java/parameters" xmlns:references="http://www.emftext.org/java/references" xmlns:statements="http://www.emftext.org/java/statements" xmlns:types="http://www.emftext.org/java/types" xsi:schemaLocation="http://www.emftext.org/java/classifiers ../../java.ecore#/2 http://www.emftext.org/java/containers ../../java.ecore#/4 http://www.emftext.org/java/expressions ../../java.ecore#/5 http://www.emftext.org/java/imports ../../java.ecore#/7 http://www.emftext.org/java/instantiations ../../java.ecore#/8 http://www.emftext.org/java/literals ../../java.ecore#/9 http://www.emftext.org/java/members ../../java.ecore#/10 http://www.emftext.org/java/modifiers ../../java.ecore#/11 http://www.emftext.org/java/operators ../../java.ecore#/12 http://www.emftext.org/java/parameters ../../java.ecore#/13 http://www.emftext.org/java/references ../../java.ecore#/14 http://www.emftext.org/java/statements ../../java.ecore#/15 http://www.emftext.org/java/types ../../java.ecore#/16" name="GraphicsConfiguration.java">
  <comments>/*&#xA; * @(#)GraphicsConfiguration.java&#x9;1.38 03/12/19&#xA; *&#xA; * Copyright 2004 Sun Microsystems, Inc. All rights reserved.&#xA; * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.&#xA; */</comments>
  <namespaces>java</namespaces>
  <namespaces>awt</namespaces>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>geom</namespaces>
    <classifier xsi:type="classifiers:Class" href="geom/AffineTransform.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="image/BufferedImage.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="image/ColorModel.class.xmi#//@classifiers.0"/>
  </imports>
  <imports xsi:type="imports:ClassifierImport">
    <namespaces>java</namespaces>
    <namespaces>awt</namespaces>
    <namespaces>image</namespaces>
    <classifier xsi:type="classifiers:Class" href="image/VolatileImage.class.xmi#//@classifiers.0"/>
  </imports>
  <classifiers xsi:type="classifiers:Class" name="GraphicsConfiguration">
    <members xsi:type="members:Field" name="defaultBufferCaps">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BufferCapabilities.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Field" name="defaultImageCaps">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ImageCapabilities.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
    </members>
    <members xsi:type="members:Constructor" name="GraphicsConfiguration">
      <annotationsAndModifiers xsi:type="modifiers:Protected">
        <comments>/**&#xA;     * This is an abstract class that cannot be instantiated directly.&#xA;     * Instances must be obtained from a suitable factory or query method.&#xA;     *&#xA;     * @see GraphicsDevice#getConfigurations&#xA;     * @see GraphicsDevice#getDefaultConfiguration&#xA;     * @see GraphicsDevice#getBestConfiguration&#xA;     * @see Graphics2D#getDeviceConfiguration&#xA;     */</comments>
      </annotationsAndModifiers>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDevice">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="GraphicsDevice.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the {@link GraphicsDevice} associated with this&#xA;     * &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     * @return a &lt;code>GraphicsDevice&lt;/code> object that is &#xA;     * associated with this &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createCompatibleImage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="image/BufferedImage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a {@link BufferedImage} with a data layout and color model&#xA;     * compatible with this &lt;code>GraphicsConfiguration&lt;/code>.  This&#xA;     * method has nothing to do with memory-mapping&#xA;     * a device.  The returned &lt;code>BufferedImage&lt;/code> has&#xA;     * a layout and color model that is closest to this native device&#xA;     * configuration and can therefore be optimally blitted to this&#xA;     * device.&#xA;     * @param width the width of the returned &lt;code>BufferedImage&lt;/code>&#xA;     * @param height the height of the returned &lt;code>BufferedImage&lt;/code>&#xA;     * @return a &lt;code>BufferedImage&lt;/code> whose data layout and color&#xA;     * model is compatible with this &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createCompatibleVolatileImage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="image/VolatileImage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a {@link VolatileImage} with a data layout and color model&#xA;     * compatible with this &lt;code>GraphicsConfiguration&lt;/code>.  &#xA;     * The returned &lt;code>VolatileImage&lt;/code> &#xA;     * may have data that is stored optimally for the underlying graphics &#xA;     * device and may therefore benefit from platform-specific rendering &#xA;     * acceleration.&#xA;     * @param width the width of the returned &lt;code>VolatileImage&lt;/code>&#xA;     * @param height the height of the returned &lt;code>VolatileImage&lt;/code>&#xA;     * @return a &lt;code>VolatileImage&lt;/code> whose data layout and color&#xA;     * model is compatible with this &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     * @see Component#createVolatileImage(int, int)&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createCompatibleVolatileImage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="image/VolatileImage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="transparency">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a {@link VolatileImage} with a data layout and color model&#xA;     * compatible with this &lt;code>GraphicsConfiguration&lt;/code>.  &#xA;     * The returned &lt;code>VolatileImage&lt;/code>&#xA;     * may have data that is stored optimally for the underlying graphics&#xA;     * device and may therefore benefit from platform-specific rendering&#xA;     * acceleration.&#xA;     * @param width the width of the returned &lt;code>VolatileImage&lt;/code>&#xA;     * @param height the height of the returned &lt;code>VolatileImage&lt;/code>&#xA;     * @param transparency the specified transparency mode&#xA;     * @return a &lt;code>VolatileImage&lt;/code> whose data layout and color&#xA;     * model is compatible with this &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     * @throws IllegalArgumentException if the transparency is not a valid value&#xA;     * @see Transparency#OPAQUE&#xA;     * @see Transparency#BITMASK&#xA;     * @see Transparency#TRANSLUCENT&#xA;     * @see Component#createVolatileImage(int, int)&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:ClassMethod" name="createCompatibleVolatileImage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="image/VolatileImage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="caps">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageCapabilities.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="AWTException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/** &#xA;     * Returns a {@link VolatileImage} with a data layout and color model &#xA;     * compatible with this &lt;code>GraphicsConfiguration&lt;/code>, using &#xA;     * the specified image capabilities. &#xA;     * The returned &lt;code>VolatileImage&lt;/code> has &#xA;     * a layout and color model that is closest to this native device &#xA;     * configuration and can therefore be optimally blitted to this &#xA;     * device. &#xA;     * @return a &lt;code>VolatileImage&lt;/code> whose data layout and color &#xA;     * model is compatible with this &lt;code>GraphicsConfiguration&lt;/code>. &#xA;     * @param width the width of the returned &lt;code>VolatileImage&lt;/code> &#xA;     * @param height the height of the returned &lt;code>VolatileImage&lt;/code> &#xA;     * @param caps the image capabilities &#xA;     * @exception AWTException if the supplied image capabilities could not &#xA;     * be met by this graphics configuration &#xA;     * @since 1.4 &#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// REMIND : check caps</comments>
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.5">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.7/@parameters.1"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="createCompatibleVolatileImage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="image/VolatileImage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="caps">
        <typeReference xsi:type="types:NamespaceClassifierReference">
          <classifierReferences>
            <target xsi:type="classifiers:Class" href="ImageCapabilities.class.xmi#//@classifiers.0"/>
          </classifierReferences>
        </typeReference>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="transparency">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <exceptions>
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="AWTException.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </exceptions>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a {@link VolatileImage} with a data layout and color model&#xA;     * compatible with this &lt;code>GraphicsConfiguration&lt;/code>, using&#xA;     * the specified image capabilities and transparency value.&#xA;     * The returned &lt;code>VolatileImage&lt;/code> has&#xA;     * a layout and color model that is closest to this native device&#xA;     * configuration and can therefore be optimally blitted to this&#xA;     * device.&#xA;     * @param width the width of the returned &lt;code>VolatileImage&lt;/code>&#xA;     * @param height the height of the returned &lt;code>VolatileImage&lt;/code>&#xA;     * @param caps the image capabilities&#xA;     * @param transparency the specified transparency mode&#xA;     * @return a &lt;code>VolatileImage&lt;/code> whose data layout and color&#xA;     * model is compatible with this &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     * @see Transparency#OPAQUE&#xA;     * @see Transparency#BITMASK&#xA;     * @see Transparency#TRANSLUCENT&#xA;     * @throws IllegalArgumentException if the transparency is not a valid value&#xA;     * @exception AWTException if the supplied image capabilities could not&#xA;     * be met by this graphics configuration&#xA;     * @see Component#createVolatileImage(int, int)&#xA;     * @since 1.5&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Return">
        <comments>// REMIND : check caps</comments>
        <returnValue xsi:type="references:MethodCall" target="//@classifiers.0/@members.6">
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.0"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.1"/>
          <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.8/@parameters.3"/>
        </returnValue>
      </statements>
    </members>
    <members xsi:type="members:InterfaceMethod" name="createCompatibleImage">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="image/BufferedImage.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="width">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="height">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <parameters xsi:type="parameters:OrdinaryParameter" name="transparency">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns a &lt;code>BufferedImage&lt;/code> that supports the specified&#xA;     * transparency and has a data layout and color model&#xA;     * compatible with this &lt;code>GraphicsConfiguration&lt;/code>.  This&#xA;     * method has nothing to do with memory-mapping&#xA;     * a device. The returned &lt;code>BufferedImage&lt;/code> has a layout and&#xA;     * color model that can be optimally blitted to a device&#xA;     * with this &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     * @param width the width of the returned &lt;code>BufferedImage&lt;/code>&#xA;     * @param height the height of the returned &lt;code>BufferedImage&lt;/code>&#xA;     * @param transparency the specified transparency mode&#xA;     * @return a &lt;code>BufferedImage&lt;/code> whose data layout and color  &#xA;     * model is compatible with this &lt;code>GraphicsConfiguration&lt;/code>&#xA;     * and also supports the specified transparency.&#xA;     * @throws IllegalArgumentException if the transparency is not a valid value&#xA;     * @see Transparency#OPAQUE&#xA;     * @see Transparency#BITMASK&#xA;     * @see Transparency#TRANSLUCENT&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getColorModel">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="image/ColorModel.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the {@link ColorModel} associated with this &#xA;     * &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     * @return a &lt;code>ColorModel&lt;/code> object that is associated with&#xA;     * this &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getColorModel">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="image/ColorModel.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <parameters xsi:type="parameters:OrdinaryParameter" name="transparency">
        <typeReference xsi:type="types:Int"/>
      </parameters>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the &lt;code>ColorModel&lt;/code> associated with this&#xA;     * &lt;code>GraphicsConfiguration&lt;/code> that supports the specified&#xA;     * transparency.&#xA;     * @param transparency the specified transparency mode&#xA;     * @return a &lt;code>ColorModel&lt;/code> object that is associated with&#xA;     * this &lt;code>GraphicsConfiguration&lt;/code> and supports the &#xA;     * specified transparency or null if the transparency is not a valid&#xA;     * value.&#xA;     * @see Transparency#OPAQUE&#xA;     * @see Transparency#BITMASK&#xA;     * @see Transparency#TRANSLUCENT&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getDefaultTransform">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="geom/AffineTransform.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the default {@link AffineTransform} for this &#xA;     * &lt;code>GraphicsConfiguration&lt;/code>. This&#xA;     * &lt;code>AffineTransform&lt;/code> is typically the Identity transform&#xA;     * for most normal screens.  The default &lt;code>AffineTransform&lt;/code>&#xA;     * maps coordinates onto the device such that 72 user space&#xA;     * coordinate units measure approximately 1 inch in device&#xA;     * space.  The normalizing transform can be used to make&#xA;     * this mapping more exact.  Coordinates in the coordinate space&#xA;     * defined by the default &lt;code>AffineTransform&lt;/code> for screen and&#xA;     * printer devices have the origin in the upper left-hand corner of&#xA;     * the target region of the device, with X coordinates&#xA;     * increasing to the right and Y coordinates increasing downwards.&#xA;     * For image buffers not associated with a device, such as those not&#xA;     * created by &lt;code>createCompatibleImage&lt;/code>,&#xA;     * this &lt;code>AffineTransform&lt;/code> is the Identity transform.&#xA;     * @return the default &lt;code>AffineTransform&lt;/code> for this&#xA;     * &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getNormalizingTransform">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="geom/AffineTransform.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     *&#xA;     * Returns a &lt;code>AffineTransform&lt;/code> that can be concatenated&#xA;     * with the default &lt;code>AffineTransform&lt;/code>&#xA;     * of a &lt;code>GraphicsConfiguration&lt;/code> so that 72 units in user&#xA;     * space equals 1 inch in device space.  &#xA;     * &lt;p>&#xA;     * For a particular {@link Graphics2D}, g, one&#xA;     * can reset the transformation to create&#xA;     * such a mapping by using the following pseudocode:&#xA;     * &lt;pre>&#xA;     *      GraphicsConfiguration gc = g.getGraphicsConfiguration();&#xA;     *&#xA;     *      g.setTransform(gc.getDefaultTransform());&#xA;     *      g.transform(gc.getNormalizingTransform());&#xA;     * &lt;/pre>&#xA;     * Note that sometimes this &lt;code>AffineTransform&lt;/code> is identity,&#xA;     * such as for printers or metafile output, and that this &#xA;     * &lt;code>AffineTransform&lt;/code> is only as accurate as the information&#xA;     * supplied by the underlying system.  For image buffers not&#xA;     * associated with a device, such as those not created by&#xA;     * &lt;code>createCompatibleImage&lt;/code>, this&#xA;     * &lt;code>AffineTransform&lt;/code> is the Identity transform&#xA;     * since there is no valid distance measurement.&#xA;     * @return an &lt;code>AffineTransform&lt;/code> to concatenate to the&#xA;     * default &lt;code>AffineTransform&lt;/code> so that 72 units in user&#xA;     * space is mapped to 1 inch in device space.&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="members:InterfaceMethod" name="getBounds">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="Rectangle.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the bounds of the &lt;code>GraphicsConfiguration&lt;/code>&#xA;     * in the device coordinates. In a multi-screen environment&#xA;     * with a virtual device, the bounds can have negative X&#xA;     * or Y origins.&#xA;     * @return the bounds of the area covered by this&#xA;     * &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     * @since 1.3&#xA;     */</comments>
      </annotationsAndModifiers>
      <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
    </members>
    <members xsi:type="classifiers:Class" name="DefaultBufferCapabilities">
      <members xsi:type="members:Constructor" name="DefaultBufferCapabilities">
        <statements xsi:type="statements:ExpressionStatement">
          <expression xsi:type="instantiations:ExplicitConstructorCall">
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@parameters.0"/>
            <arguments xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.15/@members.0/@parameters.0"/>
            <arguments xsi:type="literals:NullLiteral"/>
            <callTarget xsi:type="literals:Super"/>
          </expression>
        </statements>
        <parameters xsi:type="parameters:OrdinaryParameter" name="imageCaps">
          <typeReference xsi:type="types:NamespaceClassifierReference">
            <classifierReferences>
              <target xsi:type="classifiers:Class" href="ImageCapabilities.class.xmi#//@classifiers.0"/>
            </classifierReferences>
          </typeReference>
        </parameters>
        <annotationsAndModifiers xsi:type="modifiers:Public"/>
      </members>
      <annotationsAndModifiers xsi:type="modifiers:Private"/>
      <annotationsAndModifiers xsi:type="modifiers:Static"/>
      <extends xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BufferCapabilities.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </extends>
    </members>
    <members xsi:type="members:ClassMethod" name="getBufferCapabilities">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="BufferCapabilities.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the buffering capabilities of this&#xA;     * &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     * @return the buffering capabilities of this graphics&#xA;     * configuration object&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences target="//@classifiers.0/@members.15"/>
                </typeReference>
                <arguments xsi:type="references:MethodCall" target="//@classifiers.0/@members.17"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.0"/>
      </statements>
    </members>
    <members xsi:type="members:ClassMethod" name="getImageCapabilities">
      <typeReference xsi:type="types:NamespaceClassifierReference">
        <classifierReferences>
          <target xsi:type="classifiers:Class" href="ImageCapabilities.class.xmi#//@classifiers.0"/>
        </classifierReferences>
      </typeReference>
      <annotationsAndModifiers xsi:type="modifiers:Public">
        <comments>/**&#xA;     * Returns the image capabilities of this&#xA;     * &lt;code>GraphicsConfiguration&lt;/code>.&#xA;     * @return the image capabilities of this graphics&#xA;     * configuration object&#xA;     * @since 1.4&#xA;     */</comments>
      </annotationsAndModifiers>
      <statements xsi:type="statements:Condition">
        <statement xsi:type="statements:Block">
          <statements xsi:type="statements:ExpressionStatement">
            <expression xsi:type="expressions:AssignmentExpression">
              <child xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
              <assignmentOperator xsi:type="operators:Assignment"/>
              <value xsi:type="instantiations:NewConstructorCall">
                <typeReference xsi:type="types:NamespaceClassifierReference">
                  <classifierReferences>
                    <target xsi:type="classifiers:Class" href="ImageCapabilities.class.xmi#//@classifiers.0"/>
                  </classifierReferences>
                </typeReference>
                <arguments xsi:type="literals:BooleanLiteral"/>
              </value>
            </expression>
          </statements>
        </statement>
        <condition xsi:type="expressions:EqualityExpression">
          <equalityOperators xsi:type="operators:Equal"/>
          <children xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
          <children xsi:type="literals:NullLiteral"/>
        </condition>
      </statements>
      <statements xsi:type="statements:Return">
        <returnValue xsi:type="references:IdentifierReference" target="//@classifiers.0/@members.1"/>
      </statements>
    </members>
    <annotationsAndModifiers xsi:type="modifiers:Public">
      <comments>/**&#xA; * The &lt;code>GraphicsConfiguration&lt;/code> class describes the&#xA; * characteristics of a graphics destination such as a printer or monitor.&#xA; * There can be many &lt;code>GraphicsConfiguration&lt;/code> objects associated&#xA; * with a single graphics device, representing different drawing modes or&#xA; * capabilities.  The corresponding native structure will vary from platform&#xA; * to platform.  For example, on X11 windowing systems,&#xA; * each visual is a different &lt;code>GraphicsConfiguration&lt;/code>.  &#xA; * On Microsoft Windows, &lt;code>GraphicsConfiguration&lt;/code>s represent &#xA; * PixelFormats available in the current resolution and color depth.&#xA; * &lt;p>&#xA; * In a virtual device multi-screen environment in which the desktop&#xA; * area could span multiple physical screen devices, the bounds of the &#xA; * &lt;code>GraphicsConfiguration&lt;/code> objects are relative to the&#xA; * virtual coordinate system.  When setting the location of a &#xA; * component, use {@link #getBounds() getBounds} to get the bounds of &#xA; * the desired &lt;code>GraphicsConfiguration&lt;/code> and offset the location&#xA; * with the coordinates of the &lt;code>GraphicsConfiguration&lt;/code>,&#xA; * as the following code sample illustrates:&#xA; * &lt;/p>&#xA; *&#xA; * &lt;pre>&#xA; *      Frame f = new Frame(gc);  // where gc is a GraphicsConfiguration&#xA; *      Rectangle bounds = gc.getBounds();&#xA; *      f.setLocation(10 + bounds.x, 10 + bounds.y); &lt;/pre>&#xA; *&#xA; * &lt;p>&#xA; * To determine if your environment is a virtual device&#xA; * environment, call &lt;code>getBounds&lt;/code> on all of the &#xA; * &lt;code>GraphicsConfiguration&lt;/code> objects in your system.  If &#xA; * any of the origins of the returned bounds is not (0,&amp;nbsp;0),&#xA; * your environment is a virtual device environment.&#xA; *&#xA; * &lt;p>&#xA; * You can also use &lt;code>getBounds&lt;/code> to determine the bounds&#xA; * of the virtual device.  To do this, first call &lt;code>getBounds&lt;/code> on all&#xA; * of the &lt;code>GraphicsConfiguration&lt;/code> objects in your&#xA; * system.  Then calculate the union of all of the bounds returned&#xA; * from the calls to &lt;code>getBounds&lt;/code>.  The union is the&#xA; * bounds of the virtual device.  The following code sample&#xA; * calculates the bounds of the virtual device.&#xA; *&#xA; * &lt;pre>&#xA; *      Rectangle virtualBounds = new Rectangle();&#xA; *      GraphicsEnvironment ge = GraphicsEnvironment.&#xA; *              getLocalGraphicsEnvironment();&#xA; *      GraphicsDevice[] gs =&#xA; *              ge.getScreenDevices();&#xA; *      for (int j = 0; j &lt; gs.length; j++) { &#xA; *          GraphicsDevice gd = gs[j];&#xA; *          GraphicsConfiguration[] gc =&#xA; *              gd.getConfigurations();&#xA; *          for (int i=0; i &lt; gc.length; i++) {&#xA; *              virtualBounds =&#xA; *                  virtualBounds.union(gc[i].getBounds());&#xA; *          }&#xA; *      } &lt;/pre>                   &#xA; *&#xA; * @see Window&#xA; * @see Frame&#xA; * @see GraphicsEnvironment&#xA; * @see GraphicsDevice&#xA; */</comments>
      <comments>/*&#xA; * REMIND:  What to do about capabilities?&#xA; * The&#xA; * capabilities of the device can be determined by enumerating the possible&#xA; * capabilities and checking if the GraphicsConfiguration&#xA; * implements the interface for that capability.&#xA; *&#xA; * @version 1.38, 12/19/03&#xA; */</comments>
    </annotationsAndModifiers>
    <annotationsAndModifiers xsi:type="modifiers:Abstract"/>
  </classifiers>
</containers:CompilationUnit>
