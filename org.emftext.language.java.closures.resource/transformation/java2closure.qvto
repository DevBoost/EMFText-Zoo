modeltype CLOSURES uses 'http://www.emftext.org/language/java/closures';  
--modeltype CLOSURES uses 'platform:/resource/org.emftext.language.java.closures/model/closures.ecore';
modeltype JAVA uses "http://www.emftext.org/java";

-- in place transformation funktioniert nun auch
-- 'inout' ist entscheidend
-- grundsätzlich werden alle methoden und attribute übernommen,
-- sie müssen manuell entfernt werden per 'exclude()' methode' 

transformation Java2Closure(inout java : CLOSURES);

main() {
	java.objects()[JAVA::members::ClassMethod]->map Members_ClassMethod();
}

mapping inout JAVA::members::ClassMethod::Members_ClassMethod(){
	
	self.statements->forEach(s){
		if s.oclIsTypeOf(JAVA::statements::ExpressionStatement) then
			let ex : JAVA::statements::ExpressionStatement =
				s.oclAsType(JAVA::statements::ExpressionStatement) in
					if ex.expression.oclIsTypeOf(JAVA::instantiations::NewConstructorCall) then
						let ncc : JAVA::instantiations::NewConstructorCall =
							ex.expression.oclAsType(JAVA::instantiations::NewConstructorCall) in
								ncc.arguments->forEach(a){
									if a.oclIsTypeOf(JAVA::instantiations::NewConstructorCall) then
										let closure : CLOSURES::Closure =
											map Closures_Closure(a.oclAsType(JAVA::instantiations::NewConstructorCall)) in
										if closure <> null then
											ncc.arguments := ncc.arguments->append(closure)->
											asOrderedSet()->
											excluding(a)
										endif
									endif
								}
					endif
		endif 
						
		
		
	}
}

mapping Closures_Closure(in newConstructorCall : JAVA::instantiations::NewConstructorCall) : CLOSURES::Closure
	when{
		newConstructorCall.typeReference <> null
		and
		newConstructorCall.anonymousClass <> null
		and
		newConstructorCall.anonymousClass.members->size() = 1
		and
		newConstructorCall.anonymousClass.members->at(1).oclIsTypeOf(JAVA::members::ClassMethod) 
	}
	{
		var method : JAVA::members::ClassMethod := newConstructorCall.anonymousClass.members->at(1).oclAsType(JAVA::members::ClassMethod) ;
		annotationsAndModifiers := method.annotationsAndModifiers;
		method.parameters->forEach(p){
			parameterTypes := parameterTypes->append(p.typeReference.clone().oclAsType(JAVA::types::TypeReference))
		};
		valueType := method.typeReference;
		typeReference := newConstructorCall.typeReference;
		name := "";
		parameters := method.parameters;
		statements := method.statements;
		methodName := method.name;
	}


